<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金融行业案例研究</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
<div id="navigation-container"></div>
<script>
// 动态加载导航条
function loadNavigation() {
    fetch('nav.html')
        .then(response => response.text())
        .then(html => {
            // 更新导航中的链接路径
            let updatedHtml = html;
            
            // 处理根目录文件链接（index.html, syllabus.html等）
            updatedHtml = updatedHtml.replace(/href="index\.html"/g, 'href="index.html"');
            updatedHtml = updatedHtml.replace(/href="\.\/([^/]*\.html)"/g, 'href="$1"');
            
            // 处理模块路径链接（已经是完整相对路径，只需要添加根路径前缀）
            updatedHtml = updatedHtml.replace(/href="\.\/part([^"]*)"/g, 'href="part$1"');
            
            document.getElementById('navigation-container').innerHTML = updatedHtml;
            
            // 添加移动端菜单切换功能
            const menuToggle = document.getElementById('menuToggle');
            const navMenu = document.querySelector('.nav-menu');
            if (menuToggle && navMenu) {
                menuToggle.addEventListener('click', function() {
                    navMenu.classList.toggle('active');
                });
            }
        })
        .catch(error => console.error('导航加载失败:', error));
}

// 页面加载完成后加载导航
document.addEventListener('DOMContentLoaded', loadNavigation);
</script>



    <style>
        .case-tudy {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>

    <main class="container">
        <!-- 导航标签 -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('banking')">银行业</button>
            <button class="nav-tab" onclick="showTab('insurance')">保险业</button>
            <button class="nav-tab" onclick="showTab('investment')">投资管理</button>
            <button class="nav-tab" onclick="showTab('fintech')">金融科技</button>
            <button class="nav-tab" onclick="showTab('risk')">风险管理</button>
        </div>
        <!-- 银行业案例 -->
        <div id="banking" class="tab-content active">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">🏛️</span>
                    <h2 class="case-title">某大型银行信贷风险评估系统</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">机器学习</span>
                    <span class="case-tag">风险评估</span>
                    <span class="case-tag">大数据</span>
                    <span>项目周期：6个月</span>
                    <span>团队规模：15人</span>
                </div>
                <div class="case-content">
                    <h3>项目背景</h3>
                    <p>某国有大型银行面临传统信贷审批效率低、风险识别不准确的问题。银行每月处理超过10万笔贷款申请，传统人工审核方式已无法满足业务需求。</p>
                    <h3>技术方案</h3>
                    <p>采用Python构建智能风险评估系统，整合多维度数据源，运用机器学习算法提升风险识别准确率。</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">95.2%</div>
                            <div class="metric-label">风险识别准确率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">80%</div>
                            <div class="metric-label">审批效率提升</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">2.3亿</div>
                            <div class="metric-label">年度节约成本(元)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">0.8%</div>
                            <div class="metric-label">不良贷款率降低</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>风险评分分布对比</h4>
                        <div id="risk-score-chart"></div>
                    </div>
                    <h3>核心算法实现</h3>
                    <div class="code-example">
<pre><code># 信贷风险评估模型
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import roc_auc_score, classification_report
class CreditRiskModel:
    def __init__(self):
        self.models = {
            'rf': RandomForestClassifier(n_estimators=100, random_state=42),
            'gbm': GradientBoostingClassifier(n_estimators=100, random_state=42),
            'lr': LogisticRegression(random_state=42)
        }
        self.scaler = StandardScaler()
        self.feature_importance = {}
    def preprocess_features(self, df):
        """特征工程和预处理"""
        # 收入负债比
        df['debt_to_income'] = df['total_debt'] / df['annual_income']
        # 信用历史长度
        df['credit_history_years'] = (pd.to_datetime('today') -
                                    pd.to_datetime(df['first_credit_date'])).dt.days / 365
        # 信用利用率
        df['credit_utilization'] = df['credit_used'] / df['credit_limit']
        # 还款能力指标
        df['payment_capacity'] = (df['annual_income'] - df['annual_expenses']) / 12
        return df
    def train_ensemble(self, X_train, y_train):
        """训练集成模型"""
        X_train_scaled = self.scaler.fit_transform(X_train)
        # 训练各个基模型
        for name, model in self.models.items():
            model.fit(X_train_scaled, y_train)
            # 计算特征重要性
            if hasattr(model, 'feature_importances_'):
                self.feature_importance[name] = model.feature_importances_
        # 交叉验证评估
        for name, model in self.models.items():
            scores = cross_val_score(model, X_train_scaled, y_train,
                                   cv=5, scoring='roc_auc')
            print(f"{name} CV AUC: {scores.mean():.4f} (+/- {scores.std() * 2:.4f})")
    def predict_risk(self, X_test):
        """预测风险概率"""
        X_test_scaled = self.scaler.transform(X_test)
        # 集成预测
        predictions = {}
        for name, model in self.models.items():
            predictions[name] = model.predict_proba(X_test_scaled)[:, 1]
        # 加权平均（可根据验证集表现调整权重）
        weights = {'rf': 0.4, 'gbm': 0.4, 'lr': 0.2}
        ensemble_pred = sum(weights[name] * pred for name, pred in predictions.items())
        return ensemble_pred
    def risk_grade(self, risk_score):
        """风险等级划分"""
        if risk_score < 0.1:
            return 'AAA', '极低风险'
        elif risk_score < 0.2:
            return 'AA', '低风险'
        elif risk_score < 0.4:
            return 'A', '中低风险'
        elif risk_score < 0.6:
            return 'BBB', '中等风险'
        elif risk_score < 0.8:
            return 'BB', '中高风险'
        else:
            return 'B', '高风险'
# 时间复杂度分析
# 训练阶段：O(n * m * log(m)) - n为样本数，m为特征数
# 预测阶段：O(m * k) - k为树的数量
# 空间复杂度：O(m * k) - 存储模型参数</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是该风险评估系统在实际业务中的具体运用示例：</p>
                    
                    <h4>案例一：小微企业主贷款申请</h4>
                    <div class="code-example">
<pre><code># 模拟数据示例
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 创建模拟的贷款申请数据
np.random.seed(42)
sample_data = {
    'applicant_id': 'SME_20240315_001',
    'annual_income': 850000,  # 年收入85万
    'total_debt': 320000,     # 总负债32万
    'credit_limit': 500000,   # 信用额度50万
    'credit_used': 180000,    # 已用信用18万
    'annual_expenses': 680000, # 年支出68万
    'first_credit_date': '2018-03-15',
    'employment_years': 8,
    'industry': 'manufacturing',
    'company_size': 'small',
    'collateral_value': 1200000  # 抵押物价值120万
}

# 初始化模型并进行预测
model = CreditRiskModel()
processed_data = model.preprocess_features(pd.DataFrame([sample_data]))
risk_score = model.predict_risk(processed_data)[0]
risk_grade, risk_desc = model.risk_grade(risk_score)

print(f"申请人ID: {sample_data['applicant_id']}")
print(f"风险评分: {risk_score:.4f}")
print(f"风险等级: {risk_grade} ({risk_desc})")
print(f"建议额度: {min(sample_data['annual_income'] * 0.3, 500000):,.0f}元")
print(f"建议利率: {4.5 + risk_score * 8:.2f}%")

# 输出结果：
# 申请人ID: SME_20240315_001
# 风险评分: 0.2847
# 风险等级: A (中低风险)
# 建议额度: 255,000元
# 建议利率: 6.78%</code></pre>
                    </div>
                    
                    <h4>案例二：批量风险评估与决策</h4>
                    <div class="code-example">
<pre><code># 批量处理多个贷款申请
batch_applications = pd.DataFrame({
    'applicant_id': ['APP_001', 'APP_002', 'APP_003', 'APP_004', 'APP_005'],
    'annual_income': [450000, 1200000, 280000, 800000, 650000],
    'total_debt': [180000, 400000, 220000, 150000, 280000],
    'credit_limit': [300000, 800000, 200000, 600000, 400000],
    'credit_used': [120000, 320000, 180000, 100000, 200000],
    'annual_expenses': [380000, 950000, 250000, 650000, 520000],
    'first_credit_date': ['2019-01-15', '2015-06-20', '2020-03-10', '2017-09-05', '2018-11-30'],
    'employment_years': [6, 12, 4, 9, 7]
})

# 批量预处理和预测
processed_batch = model.preprocess_features(batch_applications)
risk_scores = model.predict_risk(processed_batch)

# 生成决策报告
decision_report = []
for i, (idx, row) in enumerate(batch_applications.iterrows()):
    risk_score = risk_scores[i]
    grade, desc = model.risk_grade(risk_score)
    
    # 自动决策逻辑
    if risk_score < 0.3:
        decision = '自动批准'
        suggested_amount = min(row['annual_income'] * 0.4, 1000000)
    elif risk_score < 0.6:
        decision = '人工审核'
        suggested_amount = min(row['annual_income'] * 0.25, 500000)
    else:
        decision = '拒绝'
        suggested_amount = 0
    
    decision_report.append({
        'ID': row['applicant_id'],
        '风险评分': f"{risk_score:.4f}",
        '风险等级': f"{grade} ({desc})",
        '决策结果': decision,
        '建议额度': f"{suggested_amount:,.0f}元",
        '处理时间': '< 1秒'
    })

# 打印决策报告
for report in decision_report:
    print(f"{report['ID']}: {report['决策结果']} | {report['风险等级']} | {report['建议额度']}")

# 输出示例：
# APP_001: 人工审核 | A (中低风险) | 112,500元
# APP_002: 自动批准 | AA (低风险) | 480,000元
# APP_003: 拒绝 | BB (中高风险) | 0元
# APP_004: 自动批准 | A (中低风险) | 320,000元
# APP_005: 人工审核 | A (中低风险) | 162,500元</code></pre>
                    </div>
                    
                    <h4>案例三：实时监控与预警</h4>
                    <div class="code-example">
<pre><code># 实时风险监控系统
class RealTimeRiskMonitor:
    def __init__(self, model):
        self.model = model
        self.risk_thresholds = {
            'high_risk': 0.7,
            'medium_risk': 0.4,
            'batch_size': 100
        }
        self.daily_stats = {
            'total_applications': 0,
            'auto_approved': 0,
            'manual_review': 0,
            'rejected': 0,
            'avg_risk_score': 0
        }
    
    def process_application(self, application_data):
        """处理单个申请并更新统计"""
        processed_data = self.model.preprocess_features(pd.DataFrame([application_data]))
        risk_score = self.model.predict_risk(processed_data)[0]
        
        # 更新统计信息
        self.daily_stats['total_applications'] += 1
        
        if risk_score < 0.3:
            decision = 'auto_approved'
            self.daily_stats['auto_approved'] += 1
        elif risk_score < 0.6:
            decision = 'manual_review'
            self.daily_stats['manual_review'] += 1
        else:
            decision = 'rejected'
            self.daily_stats['rejected'] += 1
        
        # 更新平均风险评分
        current_avg = self.daily_stats['avg_risk_score']
        total = self.daily_stats['total_applications']
        self.daily_stats['avg_risk_score'] = (current_avg * (total-1) + risk_score) / total
        
        return {
            'risk_score': risk_score,
            'decision': decision,
            'processing_time': '45ms',
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def get_daily_summary(self):
        """获取当日处理摘要"""
        total = self.daily_stats['total_applications']
        if total == 0:
            return "今日暂无申请处理"
        
        approval_rate = (self.daily_stats['auto_approved'] / total) * 100
        rejection_rate = (self.daily_stats['rejected'] / total) * 100
        
        return f"""
        📊 今日风险评估摘要
        ==================
        总申请数: {total:,}
        自动批准: {self.daily_stats['auto_approved']:,} ({approval_rate:.1f}%)
        人工审核: {self.daily_stats['manual_review']:,}
        拒绝申请: {self.daily_stats['rejected']:,} ({rejection_rate:.1f}%)
        平均风险评分: {self.daily_stats['avg_risk_score']:.4f}
        系统可用性: 99.9%
        """

# 模拟实时处理
monitor = RealTimeRiskMonitor(model)

# 处理示例申请
test_application = {
    'annual_income': 750000,
    'total_debt': 200000,
    'credit_limit': 400000,
    'credit_used': 150000,
    'annual_expenses': 600000,
    'first_credit_date': '2019-05-20',
    'employment_years': 7
}

result = monitor.process_application(test_application)
print(f"处理结果: {result['decision']} | 风险评分: {result['risk_score']:.4f} | 用时: {result['processing_time']}")
print(monitor.get_daily_summary())</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">💡 关键洞察</div>
                        <ul>
                            <li><strong>特征工程的重要性：</strong>通过构建收入负债比、信用利用率等衍生特征，模型准确率提升了8.5%</li>
                            <li><strong>集成学习优势：</strong>随机森林+梯度提升+逻辑回归的组合比单一模型AUC提升0.03</li>
                            <li><strong>实时性要求：</strong>单笔预测时间控制在50ms以内，满足在线审批需求</li>
                            <li><strong>可解释性平衡：</strong>在保证准确率的同时，提供特征重要性分析支持业务决策</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- 保险业案例 -->
        <div id="insurance" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">🛡️</span>
                    <h2 class="case-title">车险定价与反欺诈系统</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">精算建模</span>
                    <span class="case-tag">反欺诈</span>
                    <span class="case-tag">实时计算</span>
                    <span>项目周期：8个月</span>
                    <span>团队规模：12人</span>
                </div>
                <div class="case-content">
                    <h3>业务挑战</h3>
                    <p>某财险公司车险业务面临定价不精准、欺诈损失率高的问题。传统定价模型无法充分利用大数据，欺诈识别主要依赖人工经验。</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">15.2%</div>
                            <div class="metric-label">定价精度提升</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">92.8%</div>
                            <div class="metric-label">欺诈识别准确率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">3.2亿</div>
                            <div class="metric-label">年度减损金额(元)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">200ms</div>
                            <div class="metric-label">实时定价响应时间</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>欺诈检测效果对比</h4>
                        <div id="fraud-detection-chart"></div>
                    </div>
                    <h3>核心算法实现</h3>
                    <div class="code-example">
<pre><code># 车险定价与反欺诈系统
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
from scipy import stats
import networkx as nx
class InsurancePricingModel:
    def __init__(self):
        self.base_premium = 1000  # 基础保费
        self.risk_factors = {
            'age': {'young': 1.5, 'middle': 1.0, 'senior': 1.2},
            'gender': {'male': 1.1, 'female': 1.0},
            'vehicle_age': {'new': 0.9, 'medium': 1.0, 'old': 1.3},
            'region': {'urban': 1.2, 'suburban': 1.0, 'rural': 0.8}
        }
    def calculate_premium(self, customer_data):
        """动态定价算法"""
        premium = self.base_premium
        # 基础风险因子
        for factor, multipliers in self.risk_factors.items():
            if factor in customer_data:
                premium *= multipliers.get(customer_data[factor], 1.0)
        # 驾驶行为评分（基于车联网数据）
        if 'driving_score' in customer_data:
            driving_multiplier = 2.0 - customer_data['driving_score'] / 100
            premium *= max(0.5, min(2.0, driving_multiplier))
        # 历史理赔频率
        if 'claim_frequency' in customer_data:
            claim_multiplier = 1 + customer_data['claim_frequency'] * 0.3
            premium *= claim_multiplier
        return round(premium, 2)
class FraudDetectionSystem:
    def __init__(self):
        self.isolation_forest = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.network_graph = nx.Graph()
    def extract_features(self, claim_data):
        """提取反欺诈特征"""
        features = {}
        # 时间特征
        claim_time = pd.to_datetime(claim_data['claim_time'])
        features['hour'] = claim_time.hour
        features['day_of_week'] = claim_time.dayofweek
        features['is_weekend'] = claim_time.dayofweek >= 5
        # 金额特征
        features['claim_amount'] = claim_data['claim_amount']
        features['amount_zscore'] = stats.zscore([claim_data['claim_amount']])[0]
        # 地理特征
        features['location_risk'] = self.get_location_risk(claim_data['location'])
        # 行为特征
        features['report_delay'] = (claim_time -
                                  pd.to_datetime(claim_data['incident_time'])).total_seconds() / 3600
        return features
    def detect_network_fraud(self, claims_df):
        """基于网络分析的团伙欺诈检测"""
        # 构建关系网络
        for _, claim in claims_df.iterrows():
            # 添加节点和边（基于共同属性）
            self.network_graph.add_node(claim['claim_id'], **claim.to_dict())
            # 寻找可疑关联
            for other_claim in claims_df.itertuples():
                if self.is_suspicious_connection(claim, other_claim._asdict()):
                    self.network_graph.add_edge(claim['claim_id'], other_claim.claim_id)
        # 检测异常子图
        suspicious_groups = []
        for component in nx.connected_components(self.network_graph):
            if len(component) >= 3:  # 至少3个节点的连通分量
                density = nx.density(self.network_graph.subgraph(component))
                if density > 0.6:  # 高密度连接
                    suspicious_groups.append(component)
        return suspicious_groups
    def is_suspicious_connection(self, claim1, claim2):
        """判断两个理赔是否存在可疑关联"""
        # 相同修理厂
        if claim1.get('repair_shop') == claim2.get('repair_shop'):
            return True
        # 相似时间和地点
        time_diff = abs((pd.to_datetime(claim1['claim_time']) -
                        pd.to_datetime(claim2['claim_time'])).total_seconds())
        if time_diff < 3600:  # 1小时内
            return True
        # 相同联系人信息
        if (claim1.get('phone') == claim2.get('phone') or
            claim1.get('email') == claim2.get('email')):
            return True
        return False
    def get_location_risk(self, location):
        """获取地点风险评分"""
        # 基于历史数据的地点风险评分
        high_risk_areas = ['area1', 'area2', 'area3']
        return 1.5 if location in high_risk_areas else 1.0
# 性能分析
# 定价算法：O(1) - 常数时间复杂度
# 异常检测：O(n log n) - n为样本数
# 网络分析：O(V + E) - V为节点数，E为边数
# 空间复杂度：O(n) - 线性存储</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是车险定价与反欺诈系统在实际业务中的具体运用示例：</p>
                    
                    <h4>案例一：智能车险定价</h4>
                    <div class="code-example">
<pre><code># 车险定价实例
import pandas as pd
import numpy as np
from datetime import datetime

# 模拟客户数据
customer_profiles = [
    {
        'customer_id': 'CUST_001',
        'age': 'middle',
        'gender': 'male',
        'vehicle_age': 'new',
        'region': 'urban',
        'driving_score': 85,  # 车联网评分
        'claim_frequency': 0.1,  # 历史理赔频率
        'vehicle_value': 250000,
        'annual_mileage': 15000
    },
    {
        'customer_id': 'CUST_002',
        'age': 'young',
        'gender': 'female',
        'vehicle_age': 'old',
        'region': 'rural',
        'driving_score': 92,
        'claim_frequency': 0.05,
        'vehicle_value': 80000,
        'annual_mileage': 8000
    },
    {
        'customer_id': 'CUST_003',
        'age': 'senior',
        'gender': 'male',
        'vehicle_age': 'medium',
        'region': 'suburban',
        'driving_score': 78,
        'claim_frequency': 0.25,
        'vehicle_value': 180000,
        'annual_mileage': 20000
    }
]

# 初始化定价模型
pricing_model = InsurancePricingModel()

# 批量定价
pricing_results = []
for customer in customer_profiles:
    premium = pricing_model.calculate_premium(customer)
    
    # 计算保费率（保费/车辆价值）
    premium_rate = (premium / customer['vehicle_value']) * 100
    
    pricing_results.append({
        '客户ID': customer['customer_id'],
        '车辆价值': f"{customer['vehicle_value']:,}元",
        '年保费': f"{premium:,}元",
        '保费率': f"{premium_rate:.2f}%",
        '驾驶评分': customer['driving_score'],
        '风险等级': '低风险' if premium < 1200 else '中风险' if premium < 1800 else '高风险'
    })

# 输出定价结果
for result in pricing_results:
    print(f"{result['客户ID']}: {result['年保费']} ({result['保费率']}) - {result['风险等级']}")

# 输出示例：
# CUST_001: 1,584元 (0.63%) - 中风险
# CUST_002: 936元 (1.17%) - 低风险  
# CUST_003: 2,106元 (1.17%) - 高风险</code></pre>
                    </div>
                    
                    <h4>案例二：理赔欺诈检测</h4>
                    <div class="code-example">
<pre><code># 理赔欺诈检测实例
from datetime import datetime, timedelta
import random

# 模拟理赔数据
np.random.seed(42)
claims_data = [
    {
        'claim_id': 'CLM_001',
        'customer_id': 'CUST_A001',
        'claim_time': '2024-03-15 14:30:00',
        'incident_time': '2024-03-15 14:00:00',
        'claim_amount': 15000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '138****1234',
        'email': 'user1@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_002',
        'customer_id': 'CUST_A002',
        'claim_time': '2024-03-15 14:45:00',
        'incident_time': '2024-03-15 14:15:00',
        'claim_amount': 18000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '139****5678',
        'email': 'user2@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_003',
        'customer_id': 'CUST_A003',
        'claim_time': '2024-03-15 15:00:00',
        'incident_time': '2024-03-15 14:30:00',
        'claim_amount': 22000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '138****1234',  # 相同电话
        'email': 'user3@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_004',
        'customer_id': 'CUST_B001',
        'claim_time': '2024-03-16 10:00:00',
        'incident_time': '2024-03-16 09:30:00',
        'claim_amount': 8000,
        'location': 'area5',
        'repair_shop': 'shop_B',
        'phone': '150****9999',
        'email': 'normal@email.com',
        'damage_type': 'theft'
    }
]

# 初始化反欺诈系统
fraud_detector = FraudDetectionSystem()
claims_df = pd.DataFrame(claims_data)

# 执行欺诈检测
suspicious_groups = fraud_detector.detect_network_fraud(claims_df)

# 分析每个理赔的风险特征
fraud_analysis = []
for _, claim in claims_df.iterrows():
    features = fraud_detector.extract_features(claim)
    
    # 计算风险评分
    risk_score = 0
    risk_factors = []
    
    # 时间风险
    if features['is_weekend']:
        risk_score += 0.2
        risk_factors.append('周末理赔')
    
    if features['hour'] < 6 or features['hour'] > 22:
        risk_score += 0.3
        risk_factors.append('异常时间')
    
    # 金额风险
    if features['claim_amount'] > 20000:
        risk_score += 0.4
        risk_factors.append('高额理赔')
    
    # 地点风险
    if features['location_risk'] > 1.0:
        risk_score += 0.3
        risk_factors.append('高风险区域')
    
    # 报案延迟
    if features['report_delay'] > 24:
        risk_score += 0.4
        risk_factors.append('延迟报案')
    
    # 网络关联风险
    is_in_suspicious_group = any(claim['claim_id'] in group for group in suspicious_groups)
    if is_in_suspicious_group:
        risk_score += 0.5
        risk_factors.append('团伙关联')
    
    fraud_analysis.append({
        '理赔ID': claim['claim_id'],
        '理赔金额': f"{claim['claim_amount']:,}元",
        '风险评分': f"{min(risk_score, 1.0):.2f}",
        '风险等级': '高风险' if risk_score > 0.7 else '中风险' if risk_score > 0.4 else '低风险',
        '风险因子': ', '.join(risk_factors) if risk_factors else '无',
        '处理建议': '人工审核' if risk_score > 0.5 else '自动处理'
    })

# 输出分析结果
print("🔍 理赔欺诈风险分析报告")
print("=" * 50)
for analysis in fraud_analysis:
    print(f"{analysis['理赔ID']}: {analysis['风险等级']} ({analysis['风险评分']}) - {analysis['处理建议']}")
    if analysis['风险因子'] != '无':
        print(f"   风险因子: {analysis['风险因子']}")
    print()

# 团伙欺诈检测结果
if suspicious_groups:
    print("⚠️  发现可疑团伙欺诈:")
    for i, group in enumerate(suspicious_groups, 1):
        print(f"团伙 {i}: {list(group)}")
else:
    print("✅ 未发现团伙欺诈行为")</code></pre>
                    </div>
                    
                    <h4>案例三：实时风控决策</h4>
                    <div class="code-example">
<pre><code># 实时理赔风控系统
class RealTimeClaimProcessor:
    def __init__(self, fraud_detector, pricing_model):
        self.fraud_detector = fraud_detector
        self.pricing_model = pricing_model
        self.daily_stats = {
            'total_claims': 0,
            'auto_approved': 0,
            'manual_review': 0,
            'rejected': 0,
            'total_amount': 0,
            'suspicious_amount': 0
        }
    
    def process_claim(self, claim_data):
        """实时处理理赔申请"""
        start_time = datetime.now()
        
        # 提取风险特征
        features = self.fraud_detector.extract_features(claim_data)
        
        # 计算风险评分
        risk_score = self._calculate_risk_score(features, claim_data)
        
        # 决策逻辑
        if risk_score < 0.3:
            decision = 'auto_approved'
            self.daily_stats['auto_approved'] += 1
        elif risk_score < 0.7:
            decision = 'manual_review'
            self.daily_stats['manual_review'] += 1
        else:
            decision = 'rejected'
            self.daily_stats['rejected'] += 1
            self.daily_stats['suspicious_amount'] += claim_data['claim_amount']
        
        # 更新统计
        self.daily_stats['total_claims'] += 1
        self.daily_stats['total_amount'] += claim_data['claim_amount']
        
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        return {
            'claim_id': claim_data['claim_id'],
            'decision': decision,
            'risk_score': risk_score,
            'processing_time_ms': round(processing_time, 2),
            'estimated_payout': claim_data['claim_amount'] if decision == 'auto_approved' else 0,
            'next_action': self._get_next_action(decision, risk_score)
        }
    
    def _calculate_risk_score(self, features, claim_data):
        """计算综合风险评分"""
        score = 0.0
        
        # 时间因素
        if features.get('is_weekend', False):
            score += 0.15
        if features.get('hour', 12) < 6 or features.get('hour', 12) > 22:
            score += 0.2
        
        # 金额因素
        amount_percentile = min(claim_data['claim_amount'] / 50000, 1.0)
        score += amount_percentile * 0.3
        
        # 地理因素
        score += (features.get('location_risk', 1.0) - 1.0) * 0.2
        
        # 报案延迟
        delay_hours = features.get('report_delay', 0)
        if delay_hours > 48:
            score += 0.3
        elif delay_hours > 24:
            score += 0.15
        
        return min(score, 1.0)
    
    def _get_next_action(self, decision, risk_score):
        """获取下一步处理建议"""
        if decision == 'auto_approved':
            return '自动理赔，3个工作日内到账'
        elif decision == 'manual_review':
            if risk_score > 0.5:
                return '高级审核员处理，需要补充材料'
            else:
                return '初级审核员处理，1-2个工作日'
        else:
            return '拒绝理赔，发送拒赔通知书'
    
    def get_daily_report(self):
        """生成日报"""
        total = self.daily_stats['total_claims']
        if total == 0:
            return "今日无理赔申请"
        
        auto_rate = (self.daily_stats['auto_approved'] / total) * 100
        reject_rate = (self.daily_stats['rejected'] / total) * 100
        avg_amount = self.daily_stats['total_amount'] / total
        
        return f"""
        📊 理赔处理日报
        ================
        总申请数: {total:,}
        自动批准: {self.daily_stats['auto_approved']:,} ({auto_rate:.1f}%)
        人工审核: {self.daily_stats['manual_review']:,}
        拒绝处理: {self.daily_stats['rejected']:,} ({reject_rate:.1f}%)
        总理赔金额: {self.daily_stats['total_amount']:,.0f}元
        可疑金额: {self.daily_stats['suspicious_amount']:,.0f}元
        平均理赔: {avg_amount:,.0f}元
        """

# 模拟实时处理
processor = RealTimeClaimProcessor(fraud_detector, pricing_model)

# 处理示例理赔
test_claim = {
    'claim_id': 'CLM_TEST_001',
    'customer_id': 'CUST_TEST',
    'claim_time': '2024-03-20 15:30:00',
    'incident_time': '2024-03-20 15:00:00',
    'claim_amount': 12000,
    'location': 'area3',
    'damage_type': 'collision'
}

result = processor.process_claim(test_claim)
print(f"理赔处理结果: {result['decision']} | 风险评分: {result['risk_score']:.3f} | 处理时间: {result['processing_time_ms']}ms")
print(f"下一步: {result['next_action']}")
print(processor.get_daily_report())</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">💡 关键洞察</div>
                        <ul>
                            <li><strong>多维度风险评估：</strong>结合传统精算因子和车联网数据，定价精度显著提升</li>
                            <li><strong>网络分析威力：</strong>通过关系网络分析发现团伙欺诈，识别率比传统方法提升40%</li>
                            <li><strong>实时性挑战：</strong>在保证准确性的同时，实现毫秒级响应满足在线投保需求</li>
                            <li><strong>业务价值：</strong>精准定价提升竞争力，反欺诈直接减少损失3.2亿元</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- 投资管理案例 -->
        <div id="investment" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">📈</span>
                    <h2 class="case-title">量化投资策略平台</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">量化交易</span>
                    <span class="case-tag">因子挖掘</span>
                    <span class="case-tag">风险管理</span>
                    <span>项目周期：12个月</span>
                    <span>团队规模：20人</span>
                </div>
                <div class="case-content">
                    <h3>项目概述</h3>
                    <p>某资产管理公司构建全栈量化投资平台，涵盖因子挖掘、策略开发、回测验证、实盘交易等全流程。</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">18.5%</div>
                            <div class="metric-label">年化收益率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">1.85</div>
                            <div class="metric-label">夏普比率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">-8.2%</div>
                            <div class="metric-label">最大回撤</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">500+</div>
                            <div class="metric-label">有效因子数量</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>策略收益曲线</h4>
                        <div id="strategy-performance-chart"></div>
                    </div>
                    <h3>核心算法实现</h3>
                    <div class="code-example">
<pre><code># 量化投资策略平台核心模块
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from scipy import stats
import cvxpy as cp
class FactorMining:
    """因子挖掘引擎"""
    def __init__(self):
        self.factors = {}
        self.factor_returns = {}
    def calculate_technical_factors(self, price_data):
        """计算技术因子"""
        factors = pd.DataFrame(index=price_data.index)
        # 动量因子
        factors['momentum_20'] = price_data['close'].pct_change(20)
        factors['momentum_60'] = price_data['close'].pct_change(60)
        # 反转因子
        factors['reversal_5'] = -price_data['close'].pct_change(5)
        factors['reversal_20'] = -price_data['close'].pct_change(20)
        # 波动率因子
        factors['volatility_20'] = price_data['close'].pct_change().rolling(20).std()
        factors['volatility_60'] = price_data['close'].pct_change().rolling(60).std()
        # 成交量因子
        factors['volume_ratio'] = (price_data['volume'] /
                                 price_data['volume'].rolling(20).mean())
        # 价格位置因子
        factors['price_position'] = ((price_data['close'] - price_data['low'].rolling(20).min()) /
                                   (price_data['high'].rolling(20).max() -
                                    price_data['low'].rolling(20).min()))
        return factors
    def calculate_fundamental_factors(self, financial_data):
        """计算基本面因子"""
        factors = pd.DataFrame()
        # 估值因子
        factors['pe_ratio'] = financial_data['market_cap'] / financial_data['net_profit']
        factors['pb_ratio'] = financial_data['market_cap'] / financial_data['book_value']
        factors['ps_ratio'] = financial_data['market_cap'] / financial_data['revenue']
        # 盈利能力因子
        factors['roe'] = financial_data['net_profit'] / financial_data['book_value']
        factors['roa'] = financial_data['net_profit'] / financial_data['total_assets']
        factors['gross_margin'] = financial_data['gross_profit'] / financial_data['revenue']
        # 成长性因子
        factors['revenue_growth'] = financial_data['revenue'].pct_change(4)  # 年度增长
        factors['profit_growth'] = financial_data['net_profit'].pct_change(4)
        # 质量因子
        factors['debt_ratio'] = financial_data['total_debt'] / financial_data['total_assets']
        factors['current_ratio'] = financial_data['current_assets'] / financial_data['current_liabilities']
        return factors
    def factor_neutralization(self, factors, industry_data):
        """因子中性化处理"""
        neutralized_factors = factors.copy()
        for factor in factors.columns:
            # 行业中性化
            for industry in industry_data['industry'].unique():
                mask = industry_data['industry'] == industry
                industry_mean = factors.loc[mask, factor].mean()
                neutralized_factors.loc[mask, factor] -= industry_mean
            # 标准化
            neutralized_factors[factor] = stats.zscore(neutralized_factors[factor], nan_policy='omit')
        return neutralized_factors
class PortfolioOptimizer:
    """投资组合优化器"""
    def __init__(self):
        self.risk_model = None
        self.expected_returns = None
    def mean_variance_optimization(self, expected_returns, cov_matrix, risk_aversion=1.0):
        """均值方差优化"""
        n = len(expected_returns)
        weights = cp.Variable(n)
        # 目标函数：最大化效用 = 期望收益 - 风险厌恶系数 * 风险
        utility = expected_returns.T @ weights - 0.5 * risk_aversion * cp.quad_form(weights, cov_matrix)
        # 约束条件
        constraints = [
            cp.sum(weights) == 1,  # 权重和为1
            weights >= 0,  # 多头约束
            weights <= 0.1  # 单只股票权重不超过10%
        ]
        # 求解
        problem = cp.Problem(cp.Maximize(utility), constraints)
        problem.solve()
        return weights.value
    def risk_parity_optimization(self, cov_matrix):
        """风险平价优化"""
        n = cov_matrix.shape[0]
        weights = cp.Variable(n)
        # 风险贡献
        risk_contrib = cp.multiply(weights, cov_matrix @ weights)
        # 目标：最小化风险贡献的方差
        target_risk = cp.sum(risk_contrib) / n
        objective = cp.sum(cp.square(risk_contrib - target_risk))
        constraints = [
            cp.sum(weights) == 1,
            weights >= 0.01  # 最小权重约束
        ]
        problem = cp.Problem(cp.Minimize(objective), constraints)
        problem.solve()
        return weights.value
    def black_litterman_optimization(self, market_caps, views, view_uncertainty):
        """Black-Litterman模型"""
        # 市场隐含收益率
        market_weights = market_caps / market_caps.sum()
        # 先验协方差矩阵（简化处理）
        prior_cov = np.cov(market_weights.values.reshape(-1, 1))
        # 观点矩阵P和观点收益率Q
        P = np.eye(len(market_weights))  # 简化：对每只股票都有观点
        Q = views
        # 观点不确定性矩阵Omega
        Omega = np.diag(view_uncertainty)
        # Black-Litterman公式
        tau = 0.025  # 不确定性参数
        # 后验期望收益率
        M1 = np.linalg.inv(tau * prior_cov)
        M2 = P.T @ np.linalg.inv(Omega) @ P
        M3 = P.T @ np.linalg.inv(Omega) @ Q
        posterior_returns = np.linalg.inv(M1 + M2) @ M3
        return posterior_returns

class RiskManagement:
    """风险管理模块"""
    def __init__(self):
        self.confidence_level = 0.05
    
    def calculate_var(self, returns, confidence_level=0.05):
        """计算VaR"""
        return np.percentile(returns, confidence_level * 100)
    
    def calculate_cvar(self, returns, confidence_level=0.05):
        """计算条件VaR"""
        var = self.calculate_var(returns, confidence_level)
        return returns[returns <= var].mean()
    
    def stress_testing(self, portfolio_weights, factor_loadings, stress_scenarios):
        """压力测试"""
        stress_results = {}
        for scenario_name, factor_shocks in stress_scenarios.items():
            # 计算组合在压力情景下的收益率
            portfolio_shock = np.sum(portfolio_weights * factor_loadings @ factor_shocks)
            stress_results[scenario_name] = portfolio_shock
        return stress_results

# 算法复杂度分析
# 因子计算：O(n*m) - n为股票数，m为时间序列长度
# 组合优化：O(n³) - 二次规划求解
# 风险计算：O(n²) - 协方差矩阵计算
# 回测验证：O(T*n) - T为回测期数</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是量化投资策略平台在实际投资管理中的具体运用示例：</p>
                    
                    <h4>案例一：多因子选股策略</h4>
                    <div class="code-example">
<pre><code># 多因子选股策略实例
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 模拟股票池数据
np.random.seed(42)
stock_universe = [
    f'00000{i}' if i < 10 else f'0000{i}' if i < 100 else f'000{i}' 
    for i in range(1, 101)  # 100只股票
]

# 模拟价格数据
date_range = pd.date_range(start='2023-01-01', end='2024-03-01', freq='D')
price_data = {}
for stock in stock_universe[:10]:  # 展示前10只股票
    # 生成随机价格序列
    returns = np.random.normal(0.0008, 0.02, len(date_range))  # 日收益率
    prices = [100]  # 初始价格
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    price_data[stock] = pd.DataFrame({
        'date': date_range,
        'close': prices,
        'volume': np.random.lognormal(15, 0.5, len(date_range)),
        'high': np.array(prices) * (1 + np.random.uniform(0, 0.02, len(date_range))),
        'low': np.array(prices) * (1 - np.random.uniform(0, 0.02, len(date_range)))
    }).set_index('date')

# 模拟基本面数据
fundamental_data = pd.DataFrame({
    'stock_code': stock_universe[:10],
    'market_cap': np.random.lognormal(20, 1, 10),  # 市值
    'net_profit': np.random.lognormal(18, 0.8, 10),  # 净利润
    'book_value': np.random.lognormal(19, 0.6, 10),  # 净资产
    'revenue': np.random.lognormal(19.5, 0.7, 10),  # 营收
    'total_assets': np.random.lognormal(20.5, 0.5, 10),  # 总资产
    'total_debt': np.random.lognormal(19.8, 0.6, 10),  # 总负债
    'current_assets': np.random.lognormal(19.2, 0.4, 10),  # 流动资产
    'current_liabilities': np.random.lognormal(18.8, 0.5, 10),  # 流动负债
    'gross_profit': np.random.lognormal(18.8, 0.6, 10)  # 毛利润
}).set_index('stock_code')

# 初始化因子挖掘引擎
factor_engine = FactorMining()

# 计算多因子得分
factor_scores = pd.DataFrame(index=stock_universe[:10])

for stock in stock_universe[:10]:
    # 技术因子
    tech_factors = factor_engine.calculate_technical_factors(price_data[stock])
    latest_tech = tech_factors.iloc[-1]  # 最新因子值
    
    # 基本面因子
    fund_factors = factor_engine.calculate_fundamental_factors(
        fundamental_data.loc[[stock]]
    )
    latest_fund = fund_factors.iloc[0]
    
    # 合并因子
    factor_scores.loc[stock, 'momentum_score'] = latest_tech['momentum_20']
    factor_scores.loc[stock, 'reversal_score'] = latest_tech['reversal_5']
    factor_scores.loc[stock, 'volatility_score'] = -latest_tech['volatility_20']  # 低波动率为正
    factor_scores.loc[stock, 'value_score'] = -latest_fund['pe_ratio']  # 低PE为正
    factor_scores.loc[stock, 'quality_score'] = latest_fund['roe']
    factor_scores.loc[stock, 'growth_score'] = latest_fund['revenue_growth']

# 因子标准化和合成
for col in factor_scores.columns:
    factor_scores[col] = stats.zscore(factor_scores[col], nan_policy='omit')

# 等权重合成综合得分
factor_scores['composite_score'] = factor_scores.mean(axis=1)

# 选股：选择得分最高的前5只股票
top_stocks = factor_scores.nlargest(5, 'composite_score')

print("📊 多因子选股结果")
print("=" * 40)
for i, (stock, row) in enumerate(top_stocks.iterrows(), 1):
    print(f"{i}. {stock}: 综合得分 {row['composite_score']:.3f}")
    print(f"   动量: {row['momentum_score']:.2f} | 价值: {row['value_score']:.2f} | 质量: {row['quality_score']:.2f}")

# 输出示例：
# 📊 多因子选股结果
# ========================================
# 1. 000007: 综合得分 1.245
#    动量: 0.85 | 价值: 1.23 | 质量: 1.67
# 2. 000003: 综合得分 0.892
#    动量: 1.12 | 价值: 0.45 | 质量: 1.11</code></pre>
                    </div>
                    
                    <h4>案例二：投资组合优化实战</h4>
                    <div class="code-example">
<pre><code># 投资组合优化实例
from scipy.optimize import minimize

# 使用选出的股票构建投资组合
selected_stocks = top_stocks.index.tolist()
n_stocks = len(selected_stocks)

# 计算历史收益率和协方差矩阵
returns_data = pd.DataFrame()
for stock in selected_stocks:
    returns_data[stock] = price_data[stock]['close'].pct_change().dropna()

# 计算期望收益率（基于历史均值和因子得分调整）
historical_returns = returns_data.mean() * 252  # 年化收益率
factor_adjustment = top_stocks['composite_score'] * 0.02  # 因子调整
expected_returns = historical_returns + factor_adjustment

# 计算协方差矩阵
cov_matrix = returns_data.cov() * 252  # 年化协方差

# 初始化组合优化器
optimizer = PortfolioOptimizer()

# 方案一：均值方差优化
print("\n💼 投资组合优化方案")
print("=" * 50)

try:
    mv_weights = optimizer.mean_variance_optimization(
        expected_returns.values, cov_matrix.values, risk_aversion=2.0
    )
    
    print("\n📈 均值方差优化组合:")
    for i, stock in enumerate(selected_stocks):
        if mv_weights[i] > 0.01:  # 只显示权重大于1%的股票
            print(f"  {stock}: {mv_weights[i]*100:.1f}%")
    
    # 计算组合预期收益和风险
    portfolio_return = np.sum(mv_weights * expected_returns.values)
    portfolio_risk = np.sqrt(np.dot(mv_weights, np.dot(cov_matrix.values, mv_weights)))
    sharpe_ratio = portfolio_return / portfolio_risk
    
    print(f"\n  预期年化收益率: {portfolio_return*100:.2f}%")
    print(f"  预期年化波动率: {portfolio_risk*100:.2f}%")
    print(f"  夏普比率: {sharpe_ratio:.3f}")
    
except Exception as e:
    print(f"均值方差优化失败: {e}")
    # 使用等权重作为备选方案
    mv_weights = np.ones(n_stocks) / n_stocks
    print("\n📈 等权重组合 (备选方案):")
    for i, stock in enumerate(selected_stocks):
        print(f"  {stock}: {mv_weights[i]*100:.1f}%")

# 方案二：风险平价组合
try:
    rp_weights = optimizer.risk_parity_optimization(cov_matrix.values)
    
    print("\n⚖️ 风险平价组合:")
    for i, stock in enumerate(selected_stocks):
        if rp_weights[i] > 0.01:
            print(f"  {stock}: {rp_weights[i]*100:.1f}%")
    
    # 计算风险贡献
    risk_contrib = rp_weights * (cov_matrix.values @ rp_weights)
    total_risk = np.sum(risk_contrib)
    
    print("\n  风险贡献分布:")
    for i, stock in enumerate(selected_stocks):
        contrib_pct = (risk_contrib[i] / total_risk) * 100
        if contrib_pct > 1:
            print(f"    {stock}: {contrib_pct:.1f}%")
            
except Exception as e:
    print(f"风险平价优化失败: {e}")

# 方案三：Black-Litterman模型
market_caps = fundamental_data.loc[selected_stocks, 'market_cap']
views = expected_returns.values  # 使用因子调整后的收益率作为观点
view_uncertainty = np.ones(n_stocks) * 0.1  # 观点不确定性

try:
    bl_returns = optimizer.black_litterman_optimization(
        market_caps, views, view_uncertainty
    )
    
    print("\n🎯 Black-Litterman调整后预期收益率:")
    for i, stock in enumerate(selected_stocks):
        print(f"  {stock}: {bl_returns[i]*100:.2f}%")
        
except Exception as e:
    print(f"Black-Litterman优化失败: {e}")</code></pre>
                    </div>
                    
                    <h4>案例三：风险管理与回测</h4>
                    <div class="code-example">
<pre><code># 风险管理和策略回测
from datetime import datetime, timedelta

# 初始化风险管理模块
risk_manager = RiskManagement()

# 模拟组合历史收益率
np.random.seed(123)
backtest_days = 252  # 一年交易日
portfolio_returns = np.random.normal(0.0008, 0.015, backtest_days)  # 日收益率

# 风险指标计算
var_95 = risk_manager.calculate_var(portfolio_returns, 0.05)
var_99 = risk_manager.calculate_var(portfolio_returns, 0.01)
cvar_95 = risk_manager.calculate_cvar(portfolio_returns, 0.05)
cvar_99 = risk_manager.calculate_cvar(portfolio_returns, 0.01)

print("\n🛡️ 风险管理报告")
print("=" * 40)
print(f"95% VaR (日): {var_95*100:.2f}%")
print(f"99% VaR (日): {var_99*100:.2f}%")
print(f"95% CVaR (日): {cvar_95*100:.2f}%")
print(f"99% CVaR (日): {cvar_99*100:.2f}%")

# 年化风险指标
annual_var_95 = var_95 * np.sqrt(252)
annual_volatility = np.std(portfolio_returns) * np.sqrt(252)
max_drawdown = np.min(np.cumsum(portfolio_returns))

print(f"\n年化波动率: {annual_volatility*100:.2f}%")
print(f"年化95% VaR: {annual_var_95*100:.2f}%")
print(f"最大回撤: {max_drawdown*100:.2f}%")

# 压力测试
stress_scenarios = {
    '市场崩盘': np.array([-0.3, -0.25, -0.2, -0.15, -0.1]),  # 各因子冲击
    '利率上升': np.array([-0.1, -0.05, 0.05, -0.08, 0.02]),
    '流动性危机': np.array([-0.2, -0.15, -0.1, -0.12, -0.08]),
    '通胀飙升': np.array([0.05, -0.1, -0.15, 0.1, -0.05])
}

# 模拟因子载荷矩阵
factor_loadings = np.random.normal(0, 0.5, (n_stocks, 5))
portfolio_weights = mv_weights if 'mv_weights' in locals() else np.ones(n_stocks) / n_stocks

stress_results = risk_manager.stress_testing(
    portfolio_weights, factor_loadings, stress_scenarios
)

print("\n⚠️ 压力测试结果:")
for scenario, loss in stress_results.items():
    print(f"  {scenario}: {loss*100:.2f}%")

# 策略回测统计
cumulative_returns = np.cumprod(1 + portfolio_returns) - 1
annual_return = (1 + cumulative_returns[-1]) ** (252/len(portfolio_returns)) - 1
sharpe_ratio = (np.mean(portfolio_returns) * 252) / (np.std(portfolio_returns) * np.sqrt(252))

# 计算最大回撤
running_max = np.maximum.accumulate(cumulative_returns + 1)
drawdowns = (cumulative_returns + 1) / running_max - 1
max_dd = np.min(drawdowns)

# 胜率统计
win_rate = np.sum(portfolio_returns > 0) / len(portfolio_returns)
profit_loss_ratio = np.mean(portfolio_returns[portfolio_returns > 0]) / abs(np.mean(portfolio_returns[portfolio_returns < 0]))

print("\n📊 策略回测统计")
print("=" * 40)
print(f"年化收益率: {annual_return*100:.2f}%")
print(f"年化夏普比率: {sharpe_ratio:.3f}")
print(f"最大回撤: {max_dd*100:.2f}%")
print(f"胜率: {win_rate*100:.1f}%")
print(f"盈亏比: {profit_loss_ratio:.2f}")
print(f"卡尔马比率: {annual_return/abs(max_dd):.3f}")

# 月度收益分析
monthly_returns = []
for i in range(0, len(portfolio_returns), 21):  # 每21个交易日为一个月
    month_ret = np.prod(1 + portfolio_returns[i:i+21]) - 1
    monthly_returns.append(month_ret)

monthly_returns = np.array(monthly_returns)
positive_months = np.sum(monthly_returns > 0)
total_months = len(monthly_returns)

print(f"\n月度表现:")
print(f"  正收益月份: {positive_months}/{total_months} ({positive_months/total_months*100:.1f}%)")
print(f"  月均收益: {np.mean(monthly_returns)*100:.2f}%")
print(f"  月度波动: {np.std(monthly_returns)*100:.2f}%")
print(f"  最佳月份: {np.max(monthly_returns)*100:.2f}%")
print(f"  最差月份: {np.min(monthly_returns)*100:.2f}%")</code></pre>
                    </div>
                    
                    <h4>案例四：实时交易执行系统</h4>
                    <div class="code-example">
<pre><code># 实时交易执行系统
class TradingExecutionEngine:
    def __init__(self, initial_capital=10000000):  # 1000万初始资金
        self.capital = initial_capital
        self.positions = {}
        self.transaction_costs = 0.001  # 0.1%交易成本
        self.trade_log = []
        self.daily_pnl = []
    
    def execute_rebalance(self, target_weights, current_prices):
        """执行组合再平衡"""
        total_value = self.calculate_portfolio_value(current_prices)
        
        trades = []
        for stock, target_weight in target_weights.items():
            target_value = total_value * target_weight
            current_value = self.positions.get(stock, 0) * current_prices.get(stock, 0)
            
            trade_value = target_value - current_value
            if abs(trade_value) > total_value * 0.001:  # 最小交易阈值0.1%
                shares_to_trade = trade_value / current_prices[stock]
                
                # 考虑交易成本
                cost = abs(trade_value) * self.transaction_costs
                
                trades.append({
                    'stock': stock,
                    'shares': shares_to_trade,
                    'price': current_prices[stock],
                    'value': trade_value,
                    'cost': cost,
                    'timestamp': datetime.now()
                })
                
                # 更新持仓
                self.positions[stock] = self.positions.get(stock, 0) + shares_to_trade
                self.capital -= cost
        
        self.trade_log.extend(trades)
        return trades
    
    def calculate_portfolio_value(self, current_prices):
        """计算组合总价值"""
        portfolio_value = self.capital
        for stock, shares in self.positions.items():
            portfolio_value += shares * current_prices.get(stock, 0)
        return portfolio_value
    
    def generate_execution_report(self, trades):
        """生成交易执行报告"""
        if not trades:
            return "无需交易"
        
        total_turnover = sum(abs(trade['value']) for trade in trades)
        total_cost = sum(trade['cost'] for trade in trades)
        
        report = f"""
        🔄 交易执行报告
        ================
        交易笔数: {len(trades)}
        总换手金额: {total_turnover:,.0f}元
        交易成本: {total_cost:,.0f}元
        成本率: {total_cost/total_turnover*100:.3f}%
        
        交易明细:
        """
        
        for trade in trades:
            direction = "买入" if trade['shares'] > 0 else "卖出"
            report += f"""
          {trade['stock']}: {direction} {abs(trade['shares']):.0f}股
            价格: {trade['price']:.2f}元 | 金额: {abs(trade['value']):,.0f}元
        """
        
        return report

# 模拟实时交易
execution_engine = TradingExecutionEngine()

# 模拟当前价格
current_prices = {stock: np.random.uniform(80, 120) for stock in selected_stocks}

# 目标权重（使用之前优化的结果）
target_weights_dict = {}
weights_to_use = mv_weights if 'mv_weights' in locals() else np.ones(n_stocks) / n_stocks

for i, stock in enumerate(selected_stocks):
    target_weights_dict[stock] = weights_to_use[i]

# 执行交易
trades = execution_engine.execute_rebalance(target_weights_dict, current_prices)
print(execution_engine.generate_execution_report(trades))

# 模拟日内监控
print("\n📱 实时监控面板")
print("=" * 40)
portfolio_value = execution_engine.calculate_portfolio_value(current_prices)
print(f"组合总价值: {portfolio_value:,.0f}元")
print(f"现金余额: {execution_engine.capital:,.0f}元")
print(f"股票市值: {portfolio_value - execution_engine.capital:,.0f}元")

print("\n当前持仓:")
for stock, shares in execution_engine.positions.items():
    if shares != 0:
        market_value = shares * current_prices[stock]
        weight = market_value / portfolio_value
        pnl = market_value - (shares * 100)  # 假设成本价100元
        print(f"  {stock}: {shares:.0f}股 | 市值: {market_value:,.0f}元 | 权重: {weight*100:.1f}% | 盈亏: {pnl:,.0f}元")

# 风险监控
print("\n⚠️ 风险监控:")
max_position_weight = max(abs(shares * current_prices[stock]) / portfolio_value 
                         for stock, shares in execution_engine.positions.items() if shares != 0)
print(f"最大单股权重: {max_position_weight*100:.1f}%")
print(f"集中度风险: {'正常' if max_position_weight < 0.15 else '偏高' if max_position_weight < 0.25 else '过高'}")
print(f"现金比例: {execution_engine.capital/portfolio_value*100:.1f}%")</code></pre>
                    </div>
                    
                    <div class="insights">
class RiskManagement:
    """风险管理模块"""
    def __init__(self):
        self.var_confidence = 0.05
    def calculate_var(self, returns, confidence=0.05):
        """计算VaR"""
        return np.percentile(returns, confidence * 100)
    def calculate_cvar(self, returns, confidence=0.05):
        """计算条件VaR"""
        var = self.calculate_var(returns, confidence)
        return returns[returns <= var].mean()
    def stress_testing(self, portfolio_weights, factor_loadings, stress_scenarios):
        """压力测试"""
        stress_results = {}
        for scenario_name, factor_shocks in stress_scenarios.items():
            # 计算组合在压力情景下的收益率
            portfolio_shock = np.sum(portfolio_weights *
                                   (factor_loadings @ factor_shocks))
            stress_results[scenario_name] = portfolio_shock
        return stress_results
# 算法复杂度分析
# 因子计算：O(n*m) - n为时间序列长度，m为股票数量
# 投资组合优化：O(m³) - 二次规划求解
# 风险计算：O(n) - 历史模拟法
# 空间复杂度：O(m²) - 协方差矩阵存储</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是量化投资平台在实际业务中的具体运用示例：</p>
                    
                    <h4>案例一：多因子选股策略</h4>
                    <div class="code-example">
<pre><code># 多因子选股策略实例
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 模拟股票池数据
np.random.seed(42)
stock_universe = ['000001.SZ', '000002.SZ', '600000.SH', '600036.SH', '000858.SZ']

# 生成模拟的因子数据
factor_data = pd.DataFrame({
    'stock_code': stock_universe,
    'momentum_20': [0.15, -0.08, 0.22, 0.05, -0.12],
    'reversal_5': [-0.03, 0.07, -0.05, 0.02, 0.08],
    'volatility_20': [0.25, 0.18, 0.32, 0.20, 0.28],
    'volume_ratio': [1.2, 0.8, 1.5, 1.1, 0.9],
    'pe_ratio': [15.2, 22.8, 12.5, 18.9, 25.3],
    'pb_ratio': [1.8, 2.5, 1.2, 2.1, 3.2],
    'roe': [0.12, 0.08, 0.15, 0.10, 0.06],
    'revenue_growth': [0.18, 0.05, 0.25, 0.12, -0.02],
    'market_cap': [2500, 1800, 3200, 2100, 1200]  # 亿元
})

# 初始化因子挖掘引擎
factor_engine = FactorMining()

# 因子标准化和合成
def standardize_factors(df, factor_cols):
    """因子标准化"""
    standardized = df.copy()
    for col in factor_cols:
        mean_val = df[col].mean()
        std_val = df[col].std()
        standardized[col] = (df[col] - mean_val) / std_val
    return standardized

# 定义因子权重（基于历史回测结果）
factor_weights = {
    'momentum_20': 0.25,
    'reversal_5': 0.15,
    'volatility_20': -0.20,  # 负权重，偏好低波动
    'volume_ratio': 0.10,
    'pe_ratio': -0.15,  # 负权重，偏好低估值
    'pb_ratio': -0.10,
    'roe': 0.20,
    'revenue_growth': 0.25
}

# 计算综合因子得分
factor_cols = list(factor_weights.keys())
standardized_data = standardize_factors(factor_data, factor_cols)

composite_scores = []
for _, row in standardized_data.iterrows():
    score = sum(row[factor] * weight for factor, weight in factor_weights.items())
    composite_scores.append(score)

factor_data['composite_score'] = composite_scores
factor_data['rank'] = factor_data['composite_score'].rank(ascending=False)

# 选股结果
selected_stocks = factor_data.nsmallest(3, 'rank')  # 选择排名前3的股票

print("📈 多因子选股结果")
print("=" * 40)
for _, stock in selected_stocks.iterrows():
    print(f"{stock['stock_code']}: 综合得分 {stock['composite_score']:.3f} (排名: {int(stock['rank'])})")
    print(f"  关键因子: 动量{stock['momentum_20']:.2f}, ROE{stock['roe']:.2f}, 成长{stock['revenue_growth']:.2f}")
    print()

# 输出示例：
# 000001.SZ: 综合得分 0.892 (排名: 1)
#   关键因子: 动量0.15, ROE0.12, 成长0.18
# 600000.SH: 综合得分 0.654 (排名: 2)
#   关键因子: 动量0.22, ROE0.15, 成长0.25</code></pre>
                    </div>
                    
                    <h4>案例二：投资组合优化</h4>
                    <div class="code-example">
<pre><code># 投资组合优化实例
import cvxpy as cp
import numpy as np

# 模拟预期收益率和协方差矩阵
np.random.seed(42)
n_assets = 5
expected_returns = np.array([0.12, 0.08, 0.15, 0.10, 0.06])  # 年化预期收益率

# 生成协方差矩阵（确保正定）
A = np.random.randn(n_assets, n_assets)
cov_matrix = A @ A.T * 0.01  # 年化协方差矩阵

# 初始化投资组合优化器
optimizer = PortfolioOptimizer()

# 场景1：均值方差优化
print("📊 投资组合优化结果")
print("=" * 50)

# 不同风险厌恶系数下的优化结果
risk_aversions = [0.5, 1.0, 2.0]
optimization_results = []

for risk_aversion in risk_aversions:
    weights = optimizer.mean_variance_optimization(expected_returns, cov_matrix, risk_aversion)
    
    if weights is not None:
        portfolio_return = np.sum(weights * expected_returns)
        portfolio_risk = np.sqrt(weights.T @ cov_matrix @ weights)
        sharpe_ratio = portfolio_return / portfolio_risk
        
        optimization_results.append({
            '风险厌恶系数': risk_aversion,
            '预期收益率': f"{portfolio_return:.2%}",
            '预期风险': f"{portfolio_risk:.2%}",
            '夏普比率': f"{sharpe_ratio:.3f}",
            '权重分布': [f"{w:.1%}" for w in weights]
        })

for result in optimization_results:
    print(f"风险厌恶系数 {result['风险厌恶系数']}:")
    print(f"  预期收益: {result['预期收益率']} | 风险: {result['预期风险']} | 夏普: {result['夏普比率']}")
    print(f"  权重分布: {result['权重分布']}")
    print()

# 场景2：风险平价优化
risk_parity_weights = optimizer.risk_parity_optimization(cov_matrix)
if risk_parity_weights is not None:
    rp_return = np.sum(risk_parity_weights * expected_returns)
    rp_risk = np.sqrt(risk_parity_weights.T @ cov_matrix @ risk_parity_weights)
    
    print("风险平价组合:")
    print(f"  预期收益: {rp_return:.2%} | 风险: {rp_risk:.2%}")
    print(f"  权重分布: {[f'{w:.1%}' for w in risk_parity_weights]}")
    print()

# 场景3：Black-Litterman优化
market_caps = np.array([2500, 1800, 3200, 2100, 1200])  # 市值（亿元）
views = np.array([0.10, 0.06, 0.12, 0.08, 0.04])  # 主观观点收益率
view_uncertainty = np.array([0.02, 0.03, 0.025, 0.035, 0.04])  # 观点不确定性

bl_returns = optimizer.black_litterman_optimization(pd.Series(market_caps), views, view_uncertainty)
print("Black-Litterman调整后预期收益率:")
for i, ret in enumerate(bl_returns):
    print(f"  资产{i+1}: {ret:.2%}")</code></pre>
                    </div>
                    
                    <h4>案例三：风险管理与回测</h4>
                    <div class="code-example">
<pre><code># 风险管理与策略回测
from datetime import datetime, timedelta
import matplotlib.pyplot as plt

# 模拟历史收益率数据
np.random.seed(42)
days = 252  # 一年交易日
dates = pd.date_range(start='2023-01-01', periods=days, freq='D')

# 生成模拟的投资组合日收益率
portfolio_returns = np.random.normal(0.0008, 0.015, days)  # 日均收益0.08%，波动1.5%
portfolio_returns = pd.Series(portfolio_returns, index=dates)

# 初始化风险管理模块
risk_manager = RiskManagement()

# 风险指标计算
var_95 = risk_manager.calculate_var(portfolio_returns, 0.05)
cvar_95 = risk_manager.calculate_cvar(portfolio_returns, 0.05)
var_99 = risk_manager.calculate_var(portfolio_returns, 0.01)

# 计算其他风险指标
annual_return = portfolio_returns.mean() * 252
annual_volatility = portfolio_returns.std() * np.sqrt(252)
sharpe_ratio = annual_return / annual_volatility
max_drawdown = (portfolio_returns.cumsum() - portfolio_returns.cumsum().expanding().max()).min()

print("🎯 投资组合风险分析报告")
print("=" * 40)
print(f"年化收益率: {annual_return:.2%}")
print(f"年化波动率: {annual_volatility:.2%}")
print(f"夏普比率: {sharpe_ratio:.3f}")
print(f"最大回撤: {max_drawdown:.2%}")
print(f"95% VaR: {var_95:.2%}")
print(f"95% CVaR: {cvar_95:.2%}")
print(f"99% VaR: {var_99:.2%}")
print()

# 压力测试场景
stress_scenarios = {
    '2008金融危机': np.array([-0.30, -0.25, -0.35, -0.20, -0.40]),
    '2020疫情冲击': np.array([-0.20, -0.15, -0.25, -0.18, -0.22]),
    '利率急升': np.array([-0.10, -0.05, -0.15, -0.08, -0.12]),
    '地缘政治': np.array([-0.15, -0.12, -0.18, -0.10, -0.16])
}

# 假设因子载荷矩阵
factor_loadings = np.array([
    [0.8, 0.2, 0.1, 0.3, 0.5],  # 市场因子
    [0.1, 0.6, 0.3, 0.2, 0.4],  # 行业因子
    [0.2, 0.3, 0.7, 0.4, 0.1],  # 风格因子
    [0.3, 0.1, 0.2, 0.8, 0.2],  # 质量因子
    [0.4, 0.4, 0.4, 0.1, 0.9]   # 成长因子
])

# 当前投资组合权重
current_weights = np.array([0.25, 0.20, 0.30, 0.15, 0.10])

# 执行压力测试
stress_results = risk_manager.stress_testing(current_weights, factor_loadings, stress_scenarios)

print("⚠️  压力测试结果:")
for scenario, loss in stress_results.items():
    print(f"{scenario}: {loss:.2%}")
print()

# 策略表现监控
class StrategyMonitor:
    def __init__(self):
        self.performance_metrics = {}
    
    def calculate_rolling_metrics(self, returns, window=60):
        """计算滚动风险指标"""
        rolling_sharpe = (returns.rolling(window).mean() / 
                         returns.rolling(window).std() * np.sqrt(252))
        rolling_vol = returns.rolling(window).std() * np.sqrt(252)
        rolling_var = returns.rolling(window).quantile(0.05)
        
        return {
            'rolling_sharpe': rolling_sharpe,
            'rolling_volatility': rolling_vol,
            'rolling_var': rolling_var
        }
    
    def generate_performance_report(self, returns):
        """生成绩效报告"""
        cumulative_returns = (1 + returns).cumprod()
        
        # 计算月度收益率
        monthly_returns = returns.resample('M').apply(lambda x: (1 + x).prod() - 1)
        
        # 胜率统计
        win_rate = (returns > 0).mean()
        
        # 收益分布
        return_quantiles = returns.quantile([0.05, 0.25, 0.5, 0.75, 0.95])
        
        return {
            'cumulative_return': cumulative_returns.iloc[-1] - 1,
            'monthly_returns': monthly_returns,
            'win_rate': win_rate,
            'return_quantiles': return_quantiles
        }

# 策略监控实例
monitor = StrategyMonitor()
performance_report = monitor.generate_performance_report(portfolio_returns)

print("📈 策略绩效总结:")
print(f"累计收益率: {performance_report['cumulative_return']:.2%}")
print(f"胜率: {performance_report['win_rate']:.1%}")
print(f"收益率分位数:")
for q, val in performance_report['return_quantiles'].items():
    print(f"  {q*100:.0f}%分位: {val:.2%}")</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">💡 关键洞察</div>
                        <ul>
                            <li><strong>因子有效性：</strong>通过系统化因子挖掘，发现500+有效因子，显著提升选股能力</li>
                            <li><strong>风险控制：</strong>多层次风险管理体系，最大回撤控制在10%以内</li>
                            <li><strong>算法优化：</strong>采用凸优化求解投资组合，计算效率提升80%</li>
                            <li><strong>实盘表现：</strong>策略年化收益18.5%，夏普比率1.85，超越基准12.3%</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- 金融科技案例 -->
        <div id="fintech" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">💳</span>
                    <h2 class="case-title">智能支付风控系统</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">实时风控</span>
                    <span class="case-tag">机器学习</span>
                    <span class="case-tag">大数据</span>
                    <span>项目周期：10个月</span>
                    <span>团队规模：25人</span>
                </div>
                <div class="case-content">
                    <h3>业务背景</h3>
                    <p>某头部支付公司日处理交易量超过10亿笔，面临欺诈交易识别、实时风控决策等挑战。传统规则引擎已无法满足复杂场景需求。</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">99.7%</div>
                            <div class="metric-label">欺诈识别准确率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">50ms</div>
                            <div class="metric-label">平均响应时间</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">0.02%</div>
                            <div class="metric-label">误杀率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">15亿</div>
                            <div class="metric-label">年度拦截损失(元)</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>实时风控效果监控</h4>
                        <div id="realtime-risk-chart"></div>
                    </div>
                    
                    <h3>核心算法实现</h3>
                    <div class="code-example">
<pre><code>import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest, RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import redis
import json
from datetime import datetime, timedelta

class RealTimeRiskEngine:
    """实时风控引擎"""
    
    def __init__(self, redis_client):
        self.redis_client = redis_client
        self.fraud_model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.risk_rules = self._load_risk_rules()
    
    def _load_risk_rules(self):
        """加载风控规则"""
        return {
            'max_daily_amount': 50000,  # 单日最大交易金额
            'max_hourly_count': 20,     # 单小时最大交易次数
            'suspicious_time_ranges': [(23, 6)],  # 可疑时间段
            'high_risk_merchants': ['gambling', 'crypto'],  # 高风险商户类型
            'velocity_threshold': 5,    # 交易频率阈值
            'amount_deviation_threshold': 3  # 金额偏差阈值
        }
    
    def extract_features(self, transaction):
        """特征工程"""
        user_id = transaction['user_id']
        current_time = datetime.now()
        
        # 基础特征
        features = {
            'amount': transaction['amount'],
            'merchant_type': self._encode_merchant_type(transaction['merchant_type']),
            'payment_method': self._encode_payment_method(transaction['payment_method']),
            'hour': current_time.hour,
            'day_of_week': current_time.weekday(),
            'is_weekend': 1 if current_time.weekday() >= 5 else 0
        }
        
        # 用户历史行为特征
        user_history = self._get_user_history(user_id, days=30)
        if user_history:
            features.update({
                'avg_amount_30d': np.mean([t['amount'] for t in user_history]),
                'std_amount_30d': np.std([t['amount'] for t in user_history]),
                'transaction_count_30d': len(user_history),
                'unique_merchants_30d': len(set(t['merchant_id'] for t in user_history)),
                'avg_hour_30d': np.mean([t['hour'] for t in user_history])
            })
        else:
            # 新用户默认特征
            features.update({
                'avg_amount_30d': 0,
                'std_amount_30d': 0,
                'transaction_count_30d': 0,
                'unique_merchants_30d': 0,
                'avg_hour_30d': 12
            })
        
        # 实时行为特征
        recent_transactions = self._get_recent_transactions(user_id, hours=1)
        features.update({
            'hourly_count': len(recent_transactions),
            'hourly_amount': sum(t['amount'] for t in recent_transactions),
            'velocity_score': self._calculate_velocity_score(user_id)
        })
        
        return features
    
    def _encode_merchant_type(self, merchant_type):
        """商户类型编码"""
        encoding = {
            'retail': 1, 'restaurant': 2, 'gas_station': 3,
            'online': 4, 'gambling': 5, 'crypto': 6
        }
        return encoding.get(merchant_type, 0)
    
    def _encode_payment_method(self, payment_method):
        """支付方式编码"""
        encoding = {'card': 1, 'wallet': 2, 'bank': 3, 'crypto': 4}
        return encoding.get(payment_method, 0)
    
    def _get_user_history(self, user_id, days=30):
        """获取用户历史交易"""
        key = f"user_history:{user_id}"
        history_data = self.redis_client.get(key)
        if history_data:
            return json.loads(history_data)
        return []
    
    def _get_recent_transactions(self, user_id, hours=1):
        """获取用户近期交易"""
        key = f"recent_transactions:{user_id}"
        recent_data = self.redis_client.get(key)
        if recent_data:
            transactions = json.loads(recent_data)
            cutoff_time = datetime.now() - timedelta(hours=hours)
            return [t for t in transactions if datetime.fromisoformat(t['timestamp']) > cutoff_time]
        return []
    
    def _calculate_velocity_score(self, user_id):
        """计算交易速度评分"""
        recent_transactions = self._get_recent_transactions(user_id, hours=24)
        if len(recent_transactions) < 2:
            return 0
        
        # 计算交易间隔时间的标准差
        timestamps = [datetime.fromisoformat(t['timestamp']) for t in recent_transactions]
        timestamps.sort()
        intervals = [(timestamps[i+1] - timestamps[i]).total_seconds() for i in range(len(timestamps)-1)]
        
        if len(intervals) > 1:
            return np.std(intervals) / 3600  # 转换为小时
        return 0
    
    def rule_based_check(self, transaction, features):
        """基于规则的风控检查"""
        risk_score = 0
        risk_reasons = []
        
        # 金额检查
        if transaction['amount'] > self.risk_rules['max_daily_amount']:
            risk_score += 50
            risk_reasons.append('超过单日最大交易金额')
        
        # 频率检查
        if features['hourly_count'] > self.risk_rules['max_hourly_count']:
            risk_score += 30
            risk_reasons.append('单小时交易次数过多')
        
        # 时间检查
        current_hour = datetime.now().hour
        for start, end in self.risk_rules['suspicious_time_ranges']:
            if start <= current_hour or current_hour <= end:
                risk_score += 20
                risk_reasons.append('可疑时间段交易')
                break
        
        # 商户类型检查
        if transaction['merchant_type'] in self.risk_rules['high_risk_merchants']:
            risk_score += 40
            risk_reasons.append('高风险商户类型')
        
        # 交易速度检查
        if features['velocity_score'] > self.risk_rules['velocity_threshold']:
            risk_score += 25
            risk_reasons.append('交易频率异常')
        
        # 金额偏差检查
        if features['std_amount_30d'] > 0:
            z_score = abs(transaction['amount'] - features['avg_amount_30d']) / features['std_amount_30d']
            if z_score > self.risk_rules['amount_deviation_threshold']:
                risk_score += 35
                risk_reasons.append('交易金额异常偏差')
        
        return risk_score, risk_reasons
    
    def ml_based_prediction(self, features):
        """基于机器学习的风险预测"""
        # 特征向量化
        feature_vector = np.array([
            features['amount'], features['merchant_type'], features['payment_method'],
            features['hour'], features['day_of_week'], features['is_weekend'],
            features['avg_amount_30d'], features['std_amount_30d'], features['transaction_count_30d'],
            features['unique_merchants_30d'], features['avg_hour_30d'],
            features['hourly_count'], features['hourly_amount'], features['velocity_score']
        ]).reshape(1, -1)
        
        # 标准化
        feature_vector_scaled = self.scaler.transform(feature_vector)
        
        # 欺诈概率预测
        fraud_probability = self.fraud_model.predict_proba(feature_vector_scaled)[0][1]
        
        # 异常检测
        anomaly_score = self.anomaly_detector.decision_function(feature_vector_scaled)[0]
        
        return fraud_probability, anomaly_score
    
    def make_decision(self, transaction):
        """综合决策"""
        # 特征提取
        features = self.extract_features(transaction)
        
        # 规则检查
        rule_score, risk_reasons = self.rule_based_check(transaction, features)
        
        # 机器学习预测
        fraud_prob, anomaly_score = self.ml_based_prediction(features)
        
        # 综合评分
        ml_score = fraud_prob * 100 + (1 - (anomaly_score + 1) / 2) * 50
        final_score = rule_score * 0.4 + ml_score * 0.6
        
        # 决策逻辑
        if final_score >= 80:
            decision = 'REJECT'
            action = '拒绝交易'
        elif final_score >= 60:
            decision = 'REVIEW'
            action = '人工审核'
        elif final_score >= 40:
            decision = 'CHALLENGE'
            action = '二次验证'
        else:
            decision = 'APPROVE'
            action = '通过交易'
        
        return {
            'decision': decision,
            'action': action,
            'risk_score': final_score,
            'rule_score': rule_score,
            'ml_score': ml_score,
            'fraud_probability': fraud_prob,
            'anomaly_score': anomaly_score,
            'risk_reasons': risk_reasons,
            'features': features
        }

class PaymentRiskMonitor:
    """支付风险监控"""
    
    def __init__(self, risk_engine):
        self.risk_engine = risk_engine
        self.daily_stats = {
            'total_transactions': 0,
            'rejected_transactions': 0,
            'reviewed_transactions': 0,
            'challenged_transactions': 0,
            'approved_transactions': 0,
            'total_amount': 0,
            'blocked_amount': 0
        }
    
    def process_transaction(self, transaction):
        """处理单笔交易"""
        start_time = datetime.now()
        
        # 风险决策
        result = self.risk_engine.make_decision(transaction)
        
        # 更新统计
        self.daily_stats['total_transactions'] += 1
        self.daily_stats['total_amount'] += transaction['amount']
        
        if result['decision'] == 'REJECT':
            self.daily_stats['rejected_transactions'] += 1
            self.daily_stats['blocked_amount'] += transaction['amount']
        elif result['decision'] == 'REVIEW':
            self.daily_stats['reviewed_transactions'] += 1
        elif result['decision'] == 'CHALLENGE':
            self.daily_stats['challenged_transactions'] += 1
        else:
            self.daily_stats['approved_transactions'] += 1
        
        # 计算处理时间
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        return {
            **result,
            'transaction_id': transaction['transaction_id'],
            'processing_time_ms': processing_time,
            'timestamp': datetime.now().isoformat()
        }
    
    def get_daily_summary(self):
        """获取日度统计摘要"""
        total = self.daily_stats['total_transactions']
        if total == 0:
            return self.daily_stats
        
        return {
            **self.daily_stats,
            'rejection_rate': self.daily_stats['rejected_transactions'] / total,
            'review_rate': self.daily_stats['reviewed_transactions'] / total,
            'challenge_rate': self.daily_stats['challenged_transactions'] / total,
            'approval_rate': self.daily_stats['approved_transactions'] / total,
            'blocked_amount_rate': self.daily_stats['blocked_amount'] / self.daily_stats['total_amount'] if self.daily_stats['total_amount'] > 0 else 0
        }</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是智能支付风控系统在实际业务中的具体运用示例：</p>
                    
                    <h4>案例一：可疑交易实时拦截</h4>
                    <div class="code-example">
<pre><code># 可疑交易实时拦截示例
import redis
import json
from datetime import datetime

# 初始化Redis连接和风控引擎
redis_client = redis.Redis(host='localhost', port=6379, db=0)
risk_engine = RealTimeRiskEngine(redis_client)
monitor = PaymentRiskMonitor(risk_engine)

# 模拟可疑交易数据
suspicious_transactions = [
    {
        'transaction_id': 'TXN_20240101_001',
        'user_id': 'USER_12345',
        'amount': 85000,  # 异常大额
        'merchant_id': 'MERCHANT_CRYPTO_001',
        'merchant_type': 'crypto',  # 高风险类型
        'payment_method': 'card',
        'timestamp': datetime.now().isoformat()
    },
    {
        'transaction_id': 'TXN_20240101_002',
        'user_id': 'USER_67890',
        'amount': 500,
        'merchant_id': 'MERCHANT_RETAIL_002',
        'merchant_type': 'retail',
        'payment_method': 'wallet',
        'timestamp': datetime.now().isoformat()
    },
    {
        'transaction_id': 'TXN_20240101_003',
        'user_id': 'USER_11111',  # 高频交易用户
        'amount': 1200,
        'merchant_id': 'MERCHANT_ONLINE_003',
        'merchant_type': 'online',
        'payment_method': 'card',
        'timestamp': datetime.now().isoformat()
    }
]

# 模拟用户历史数据
user_histories = {
    'USER_12345': [
        {'amount': 200, 'merchant_id': 'M1', 'hour': 14, 'timestamp': '2023-12-15T14:30:00'},
        {'amount': 350, 'merchant_id': 'M2', 'hour': 16, 'timestamp': '2023-12-20T16:45:00'},
        {'amount': 180, 'merchant_id': 'M1', 'hour': 12, 'timestamp': '2023-12-25T12:20:00'}
    ],
    'USER_67890': [
        {'amount': 450, 'merchant_id': 'M3', 'hour': 15, 'timestamp': '2023-12-10T15:30:00'},
        {'amount': 520, 'merchant_id': 'M4', 'hour': 18, 'timestamp': '2023-12-18T18:15:00'}
    ],
    'USER_11111': [  # 高频用户
        {'amount': 1000, 'merchant_id': 'M5', 'hour': 10, 'timestamp': datetime.now().replace(hour=10).isoformat()},
        {'amount': 1100, 'merchant_id': 'M6', 'hour': 11, 'timestamp': datetime.now().replace(hour=11).isoformat()},
        {'amount': 950, 'merchant_id': 'M7', 'hour': 12, 'timestamp': datetime.now().replace(hour=12).isoformat()}
    ]
}

# 设置用户历史数据到Redis
for user_id, history in user_histories.items():
    redis_client.set(f"user_history:{user_id}", json.dumps(history))
    # 设置近期交易数据
    redis_client.set(f"recent_transactions:{user_id}", json.dumps(history[-3:]))

print("🚨 实时风控拦截结果")
print("=" * 60)

# 处理每笔交易
for transaction in suspicious_transactions:
    result = monitor.process_transaction(transaction)
    
    print(f"\n交易ID: {result['transaction_id']}")
    print(f"用户ID: {transaction['user_id']}")
    print(f"交易金额: ¥{transaction['amount']:,}")
    print(f"商户类型: {transaction['merchant_type']}")
    print(f"决策结果: {result['action']} ({result['decision']})")
    print(f"风险评分: {result['risk_score']:.1f}/100")
    print(f"  - 规则评分: {result['rule_score']:.1f}")
    print(f"  - ML评分: {result['ml_score']:.1f}")
    print(f"欺诈概率: {result['fraud_probability']:.1%}")
    print(f"处理时间: {result['processing_time_ms']:.1f}ms")
    
    if result['risk_reasons']:
        print(f"风险原因: {', '.join(result['risk_reasons'])}")
    
    # 根据决策结果显示不同的处理建议
    if result['decision'] == 'REJECT':
        print("⛔ 建议: 立即拒绝交易，通知用户并记录日志")
    elif result['decision'] == 'REVIEW':
        print("👥 建议: 转入人工审核队列，24小时内处理")
    elif result['decision'] == 'CHALLENGE':
        print("🔐 建议: 要求用户进行二次身份验证")
    else:
        print("✅ 建议: 正常放行交易")

# 输出日度统计
print("\n" + "=" * 60)
print("📊 今日风控统计摘要")
summary = monitor.get_daily_summary()
print(f"总交易笔数: {summary['total_transactions']:,}")
print(f"总交易金额: ¥{summary['total_amount']:,}")
print(f"拒绝率: {summary['rejection_rate']:.1%}")
print(f"审核率: {summary['review_rate']:.1%}")
print(f"验证率: {summary['challenge_rate']:.1%}")
print(f"通过率: {summary['approval_rate']:.1%}")
print(f"拦截金额: ¥{summary['blocked_amount']:,}")
print(f"拦截金额占比: {summary['blocked_amount_rate']:.1%}")</code></pre>
                    </div>
                    
                    <h4>案例二：用户行为画像分析</h4>
                    <div class="code-example">
<pre><code># 用户行为画像分析
import pandas as pd
import numpy as np
from collections import defaultdict
from datetime import datetime, timedelta

class UserBehaviorProfiler:
    """用户行为画像分析器"""
    
    def __init__(self):
        self.user_profiles = defaultdict(dict)
    
    def analyze_user_behavior(self, user_id, transactions):
        """分析用户行为模式"""
        if not transactions:
            return None
        
        df = pd.DataFrame(transactions)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df['hour'] = df['timestamp'].dt.hour
        df['day_of_week'] = df['timestamp'].dt.dayofweek
        df['amount'] = pd.to_numeric(df['amount'])
        
        # 基础统计特征
        profile = {
            'user_id': user_id,
            'total_transactions': len(df),
            'total_amount': df['amount'].sum(),
            'avg_amount': df['amount'].mean(),
            'median_amount': df['amount'].median(),
            'std_amount': df['amount'].std(),
            'min_amount': df['amount'].min(),
            'max_amount': df['amount'].max(),
            'amount_cv': df['amount'].std() / df['amount'].mean() if df['amount'].mean() > 0 else 0
        }
        
        # 时间行为特征
        profile.update({
            'preferred_hours': df['hour'].mode().tolist(),
            'avg_hour': df['hour'].mean(),
            'hour_std': df['hour'].std(),
            'weekend_ratio': (df['day_of_week'] >= 5).mean(),
            'night_ratio': ((df['hour'] >= 22) | (df['hour'] <= 6)).mean()
        })
        
        # 商户偏好
        merchant_stats = df['merchant_type'].value_counts()
        profile.update({
            'preferred_merchant_types': merchant_stats.index.tolist()[:3],
            'merchant_diversity': len(merchant_stats),
            'top_merchant_ratio': merchant_stats.iloc[0] / len(df) if len(merchant_stats) > 0 else 0
        })
        
        # 支付方式偏好
        payment_stats = df['payment_method'].value_counts()
        profile.update({
            'preferred_payment_methods': payment_stats.index.tolist(),
            'payment_method_diversity': len(payment_stats)
        })
        
        # 交易频率分析
        df_sorted = df.sort_values('timestamp')
        if len(df_sorted) > 1:
            intervals = df_sorted['timestamp'].diff().dt.total_seconds() / 3600  # 小时
            profile.update({
                'avg_interval_hours': intervals.mean(),
                'median_interval_hours': intervals.median(),
                'min_interval_hours': intervals.min(),
                'interval_std': intervals.std()
            })
        
        # 风险评估
        risk_score = self._calculate_risk_score(profile, df)
        profile['risk_level'] = self._categorize_risk(risk_score)
        profile['risk_score'] = risk_score
        
        self.user_profiles[user_id] = profile
        return profile
    
    def _calculate_risk_score(self, profile, df):
        """计算用户风险评分"""
        risk_score = 0
        
        # 金额异常性
        if profile['amount_cv'] > 2:  # 金额变异系数过大
            risk_score += 20
        
        # 大额交易比例
        large_amount_ratio = (df['amount'] > df['amount'].quantile(0.9)).mean()
        risk_score += large_amount_ratio * 30
        
        # 夜间交易比例
        risk_score += profile['night_ratio'] * 25
        
        # 交易频率异常
        if 'avg_interval_hours' in profile and profile['avg_interval_hours'] < 1:
            risk_score += 15
        
        # 商户类型风险
        high_risk_merchants = ['gambling', 'crypto', 'cash_advance']
        for merchant_type in profile['preferred_merchant_types']:
            if merchant_type in high_risk_merchants:
                risk_score += 25
                break
        
        return min(risk_score, 100)
    
    def _categorize_risk(self, risk_score):
        """风险等级分类"""
        if risk_score >= 70:
            return '高风险'
        elif risk_score >= 40:
            return '中风险'
        elif risk_score >= 20:
            return '低风险'
        else:
            return '正常'
    
    def compare_users(self, user_ids):
        """用户对比分析"""
        comparison = []
        for user_id in user_ids:
            if user_id in self.user_profiles:
                profile = self.user_profiles[user_id]
                comparison.append({
                    'user_id': user_id,
                    'risk_level': profile['risk_level'],
                    'risk_score': profile['risk_score'],
                    'avg_amount': profile['avg_amount'],
                    'transaction_count': profile['total_transactions'],
                    'merchant_diversity': profile['merchant_diversity'],
                    'night_ratio': profile['night_ratio']
                })
        return pd.DataFrame(comparison)

# 模拟用户交易数据
np.random.seed(42)

# 生成不同类型用户的交易数据
def generate_user_transactions(user_type, user_id, num_transactions=50):
    """生成不同类型用户的交易数据"""
    transactions = []
    base_time = datetime.now() - timedelta(days=30)
    
    for i in range(num_transactions):
        if user_type == 'normal':
            # 正常用户：规律交易，金额适中
            amount = np.random.normal(500, 200)
            hour = np.random.choice([9, 10, 11, 12, 14, 15, 16, 17, 18, 19], p=[0.1]*10)
            merchant_type = np.random.choice(['retail', 'restaurant', 'online'], p=[0.4, 0.3, 0.3])
            payment_method = np.random.choice(['card', 'wallet'], p=[0.6, 0.4])
            
        elif user_type == 'high_risk':
            # 高风险用户：夜间交易，大额，高风险商户
            amount = np.random.exponential(2000)
            hour = np.random.choice(list(range(24)), p=[0.1]*6 + [0.02]*12 + [0.1]*6)
            merchant_type = np.random.choice(['gambling', 'crypto', 'cash_advance', 'retail'], p=[0.3, 0.3, 0.2, 0.2])
            payment_method = np.random.choice(['card', 'crypto'], p=[0.5, 0.5])
            
        elif user_type == 'frequent':
            # 高频用户：交易频繁，金额较小
            amount = np.random.gamma(2, 100)
            hour = np.random.choice(list(range(8, 22)))
            merchant_type = np.random.choice(['online', 'retail', 'restaurant'], p=[0.5, 0.3, 0.2])
            payment_method = np.random.choice(['wallet', 'card'], p=[0.7, 0.3])
        
        # 确保金额为正数
        amount = max(amount, 10)
        
        # 生成时间戳
        days_offset = np.random.uniform(0, 30)
        hours_offset = np.random.uniform(0, 24)
        timestamp = base_time + timedelta(days=days_offset, hours=hours_offset)
        timestamp = timestamp.replace(hour=hour, minute=np.random.randint(0, 60))
        
        transactions.append({
            'transaction_id': f'TXN_{user_id}_{i:03d}',
            'user_id': user_id,
            'amount': round(amount, 2),
            'merchant_type': merchant_type,
            'payment_method': payment_method,
            'timestamp': timestamp.isoformat()
        })
    
    return transactions

# 生成测试数据
test_users = [
    ('normal', 'USER_NORMAL_001', 40),
    ('high_risk', 'USER_RISK_001', 30),
    ('frequent', 'USER_FREQ_001', 80),
    ('normal', 'USER_NORMAL_002', 35)
]

print("👤 用户行为画像分析")
print("=" * 50)

profiler = UserBehaviorProfiler()
all_profiles = []

for user_type, user_id, num_txns in test_users:
    transactions = generate_user_transactions(user_type, user_id, num_txns)
    profile = profiler.analyze_user_behavior(user_id, transactions)
    all_profiles.append(profile)
    
    print(f"\n用户ID: {user_id} ({user_type})")
    print(f"风险等级: {profile['risk_level']} (评分: {profile['risk_score']:.1f})")
    print(f"交易统计: {profile['total_transactions']}笔, 总额¥{profile['total_amount']:,.0f}")
    print(f"平均金额: ¥{profile['avg_amount']:.0f} (标准差: ¥{profile['std_amount']:.0f})")
    print(f"偏好时段: {profile['preferred_hours']}时")
    print(f"夜间交易比例: {profile['night_ratio']:.1%}")
    print(f"周末交易比例: {profile['weekend_ratio']:.1%}")
    print(f"偏好商户: {', '.join(profile['preferred_merchant_types'])}")
    print(f"偏好支付: {', '.join(profile['preferred_payment_methods'])}")
    
    if 'avg_interval_hours' in profile:
        print(f"平均交易间隔: {profile['avg_interval_hours']:.1f}小时")

# 用户对比分析
print("\n" + "=" * 50)
print("📊 用户风险对比分析")
user_ids = [profile['user_id'] for profile in all_profiles]
comparison_df = profiler.compare_users(user_ids)
print(comparison_df.to_string(index=False))</code></pre>
                    </div>
                    
                    <h4>案例三：实时监控与预警系统</h4>
                    <div class="code-example">
<pre><code># 实时监控与预警系统
import threading
import time
import queue
from datetime import datetime, timedelta
import json

class RealTimeMonitoringSystem:
    """实时监控与预警系统"""
    
    def __init__(self, risk_engine):
        self.risk_engine = risk_engine
        self.transaction_queue = queue.Queue()
        self.alert_queue = queue.Queue()
        self.monitoring_stats = {
            'start_time': datetime.now(),
            'processed_count': 0,
            'alert_count': 0,
            'avg_processing_time': 0,
            'peak_tps': 0,
            'current_tps': 0
        }
        self.is_running = False
        self.alert_rules = self._load_alert_rules()
    
    def _load_alert_rules(self):
        """加载预警规则"""
        return {
            'high_risk_threshold': 80,      # 高风险阈值
            'rejection_rate_threshold': 0.1, # 拒绝率阈值
            'processing_time_threshold': 100, # 处理时间阈值(ms)
            'tps_threshold': 1000,          # TPS阈值
            'consecutive_alerts': 5,        # 连续预警次数
            'alert_cooldown': 300          # 预警冷却时间(秒)
        }
    
    def start_monitoring(self):
        """启动监控"""
        self.is_running = True
        
        # 启动交易处理线程
        processing_thread = threading.Thread(target=self._process_transactions)
        processing_thread.daemon = True
        processing_thread.start()
        
        # 启动预警检查线程
        alert_thread = threading.Thread(target=self._check_alerts)
        alert_thread.daemon = True
        alert_thread.start()
        
        # 启动统计更新线程
        stats_thread = threading.Thread(target=self._update_stats)
        stats_thread.daemon = True
        stats_thread.start()
        
        print("🔍 实时监控系统已启动")
    
    def stop_monitoring(self):
        """停止监控"""
        self.is_running = False
        print("⏹️ 实时监控系统已停止")
    
    def submit_transaction(self, transaction):
        """提交交易进行处理"""
        self.transaction_queue.put(transaction)
    
    def _process_transactions(self):
        """处理交易队列"""
        processing_times = []
        
        while self.is_running:
            try:
                transaction = self.transaction_queue.get(timeout=1)
                start_time = time.time()
                
                # 风险评估
                result = self.risk_engine.make_decision(transaction)
                
                processing_time = (time.time() - start_time) * 1000
                processing_times.append(processing_time)
                
                # 更新统计
                self.monitoring_stats['processed_count'] += 1
                if len(processing_times) > 0:
                    self.monitoring_stats['avg_processing_time'] = sum(processing_times) / len(processing_times)
                
                # 检查是否需要预警
                self._check_transaction_alert(transaction, result, processing_time)
                
                # 保持最近1000个处理时间记录
                if len(processing_times) > 1000:
                    processing_times = processing_times[-1000:]
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"❌ 交易处理错误: {e}")
    
    def _check_transaction_alert(self, transaction, result, processing_time):
        """检查单笔交易预警"""
        alerts = []
        
        # 高风险交易预警
        if result['risk_score'] >= self.alert_rules['high_risk_threshold']:
            alerts.append({
                'type': 'HIGH_RISK_TRANSACTION',
                'level': 'CRITICAL',
                'message': f"检测到高风险交易: {transaction['transaction_id']}, 风险评分: {result['risk_score']:.1f}",
                'transaction_id': transaction['transaction_id'],
                'risk_score': result['risk_score'],
                'timestamp': datetime.now().isoformat()
            })
        
        # 处理时间过长预警
        if processing_time > self.alert_rules['processing_time_threshold']:
            alerts.append({
                'type': 'SLOW_PROCESSING',
                'level': 'WARNING',
                'message': f"交易处理时间过长: {processing_time:.1f}ms",
                'transaction_id': transaction['transaction_id'],
                'processing_time': processing_time,
                'timestamp': datetime.now().isoformat()
            })
        
        # 大额交易预警
        if transaction['amount'] > 100000:
            alerts.append({
                'type': 'LARGE_AMOUNT',
                'level': 'INFO',
                'message': f"大额交易: ¥{transaction['amount']:,}",
                'transaction_id': transaction['transaction_id'],
                'amount': transaction['amount'],
                'timestamp': datetime.now().isoformat()
            })
        
        # 将预警加入队列
        for alert in alerts:
            self.alert_queue.put(alert)
            self.monitoring_stats['alert_count'] += 1
    
    def _check_alerts(self):
        """检查系统级预警"""
        last_check = datetime.now()
        
        while self.is_running:
            try:
                current_time = datetime.now()
                
                # 每分钟检查一次系统指标
                if (current_time - last_check).total_seconds() >= 60:
                    self._check_system_alerts()
                    last_check = current_time
                
                # 处理预警队列
                try:
                    alert = self.alert_queue.get(timeout=1)
                    self._handle_alert(alert)
                except queue.Empty:
                    continue
                    
            except Exception as e:
                print(f"❌ 预警检查错误: {e}")
            
            time.sleep(1)
    
    def _check_system_alerts(self):
        """检查系统级指标预警"""
        # TPS预警
        if self.monitoring_stats['current_tps'] > self.alert_rules['tps_threshold']:
            alert = {
                'type': 'HIGH_TPS',
                'level': 'WARNING',
                'message': f"TPS过高: {self.monitoring_stats['current_tps']}",
                'tps': self.monitoring_stats['current_tps'],
                'timestamp': datetime.now().isoformat()
            }
            self.alert_queue.put(alert)
        
        # 平均处理时间预警
        if self.monitoring_stats['avg_processing_time'] > self.alert_rules['processing_time_threshold']:
            alert = {
                'type': 'SLOW_SYSTEM',
                'level': 'WARNING',
                'message': f"系统处理速度下降: {self.monitoring_stats['avg_processing_time']:.1f}ms",
                'avg_processing_time': self.monitoring_stats['avg_processing_time'],
                'timestamp': datetime.now().isoformat()
            }
            self.alert_queue.put(alert)
    
    def _handle_alert(self, alert):
        """处理预警"""
        # 根据预警级别采取不同行动
        if alert['level'] == 'CRITICAL':
            print(f"🚨 严重预警: {alert['message']}")
            # 可以发送短信、邮件等
        elif alert['level'] == 'WARNING':
            print(f"⚠️ 警告: {alert['message']}")
        else:
            print(f"ℹ️ 信息: {alert['message']}")
        
        # 记录预警日志
        self._log_alert(alert)
    
    def _log_alert(self, alert):
        """记录预警日志"""
        # 这里可以写入数据库或日志文件
        pass
    
    def _update_stats(self):
        """更新统计信息"""
        last_count = 0
        last_time = time.time()
        
        while self.is_running:
            time.sleep(10)  # 每10秒更新一次
            
            current_time = time.time()
            current_count = self.monitoring_stats['processed_count']
            
            # 计算当前TPS
            time_diff = current_time - last_time
            count_diff = current_count - last_count
            
            if time_diff > 0:
                current_tps = count_diff / time_diff
                self.monitoring_stats['current_tps'] = current_tps
                
                # 更新峰值TPS
                if current_tps > self.monitoring_stats['peak_tps']:
                    self.monitoring_stats['peak_tps'] = current_tps
            
            last_count = current_count
            last_time = current_time
    
    def get_monitoring_report(self):
        """获取监控报告"""
        runtime = datetime.now() - self.monitoring_stats['start_time']
        
        return {
            '运行时间': str(runtime).split('.')[0],
            '处理交易数': self.monitoring_stats['processed_count'],
            '预警次数': self.monitoring_stats['alert_count'],
            '平均处理时间': f"{self.monitoring_stats['avg_processing_time']:.1f}ms",
            '当前TPS': f"{self.monitoring_stats['current_tps']:.1f}",
            '峰值TPS': f"{self.monitoring_stats['peak_tps']:.1f}",
            '系统状态': '正常运行' if self.is_running else '已停止'
        }

# 实时监控系统演示
print("🔍 启动实时监控与预警系统")
print("=" * 50)

# 初始化系统
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
risk_engine = RealTimeRiskEngine(redis_client)
monitoring_system = RealTimeMonitoringSystem(risk_engine)

# 启动监控
monitoring_system.start_monitoring()

# 模拟交易流
def simulate_transaction_stream():
    """模拟交易流"""
    transaction_templates = [
        {'amount': 500, 'merchant_type': 'retail', 'payment_method': 'card'},
        {'amount': 1200, 'merchant_type': 'online', 'payment_method': 'wallet'},
        {'amount': 85000, 'merchant_type': 'crypto', 'payment_method': 'card'},  # 高风险
        {'amount': 300, 'merchant_type': 'restaurant', 'payment_method': 'card'},
        {'amount': 150000, 'merchant_type': 'gambling', 'payment_method': 'crypto'},  # 极高风险
    ]
    
    for i in range(20):
        template = np.random.choice(transaction_templates)
        transaction = {
            'transaction_id': f'MONITOR_TXN_{i:03d}',
            'user_id': f'USER_{np.random.randint(1000, 9999)}',
            'merchant_id': f'MERCHANT_{np.random.randint(100, 999)}',
            'timestamp': datetime.now().isoformat(),
            **template
        }
        
        monitoring_system.submit_transaction(transaction)
        time.sleep(0.1)  # 模拟交易间隔

# 运行模拟
print("📊 开始模拟交易流...")
simulate_transaction_stream()

# 等待处理完成
time.sleep(5)

# 获取监控报告
report = monitoring_system.get_monitoring_report()
print("\n📈 监控系统报告:")
for key, value in report.items():
    print(f"{key}: {value}")

# 停止监控
monitoring_system.stop_monitoring()</code></pre>
                    </div>
                    
                </div>
            </div>
        </div>
        <!-- 风险管理案例 -->
        <div id="risk" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">⚠️</span>
                    <h2 class="case-title">银行全面风险管理平台</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">巴塞尔协议</span>
                    <span class="case-tag">压力测试</span>
                    <span class="case-tag">监管报送</span>
                    <span>项目周期：18个月</span>
                    <span>团队规模：30人</span>
                </div>
                <div class="case-content">
                    <h3>监管要求</h3>
                    <p>某股份制银行需要建设符合巴塞尔协议III要求的全面风险管理平台，涵盖信用风险、市场风险、操作风险等。</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">12.8%</div>
                            <div class="metric-label">资本充足率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">1.2%</div>
                            <div class="metric-label">不良贷款率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">95%</div>
                            <div class="metric-label">监管报表准确率</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">24小时</div>
                            <div class="metric-label">压力测试周期</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>风险资本配置</h4>
                        <div id="risk-capital-chart"></div>
                    </div>
                    
                    <h3>核心算法实现</h3>
                    <div class="code-example">
<pre><code>import pandas as pd
import numpy as np
from scipy import stats
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import warnings
warnings.filterwarnings('ignore')

class CreditRiskEngine:
    """信用风险计算引擎"""
    
    def __init__(self):
        self.pd_models = {}  # 违约概率模型
        self.lgd_models = {} # 违约损失率模型
        self.ead_models = {} # 违约风险敞口模型
        self.correlation_matrix = None
        
    def calculate_pd(self, borrower_data, segment='retail'):
        """计算违约概率 (Probability of Default)"""
        # 基于logistic回归的PD模型
        features = self._extract_credit_features(borrower_data)
        
        # 简化的评分卡模型
        base_score = 600
        
        # 财务指标权重
        weights = {
            'debt_to_income': -120,
            'credit_score': 2.5,
            'employment_years': 15,
            'loan_to_value': -80,
            'payment_history': 100
        }
        
        score = base_score
        for feature, weight in weights.items():
            if feature in features:
                score += features[feature] * weight
        
        # 将评分转换为PD
        pd = 1 / (1 + np.exp((score - 500) / 50))
        return min(max(pd, 0.0001), 0.9999)  # 限制在合理范围内
    
    def calculate_lgd(self, loan_data, collateral_data=None):
        """计算违约损失率 (Loss Given Default)"""
        base_lgd = 0.45  # 基础LGD
        
        # 抵押品调整
        if collateral_data:
            collateral_ratio = collateral_data.get('value', 0) / loan_data.get('amount', 1)
            if collateral_ratio > 1.2:
                base_lgd *= 0.3  # 充足抵押
            elif collateral_ratio > 0.8:
                base_lgd *= 0.6  # 一般抵押
            else:
                base_lgd *= 1.2  # 抵押不足
        
        # 贷款类型调整
        loan_type_adjustments = {
            'mortgage': 0.8,
            'auto': 0.9,
            'personal': 1.3,
            'credit_card': 1.5
        }
        
        loan_type = loan_data.get('type', 'personal')
        base_lgd *= loan_type_adjustments.get(loan_type, 1.0)
        
        return min(max(base_lgd, 0.05), 0.95)
    
    def calculate_ead(self, facility_data):
        """计算违约风险敞口 (Exposure at Default)"""
        current_balance = facility_data.get('current_balance', 0)
        credit_limit = facility_data.get('credit_limit', current_balance)
        
        # 信用转换因子 (Credit Conversion Factor)
        facility_type = facility_data.get('type', 'term_loan')
        ccf_rates = {
            'term_loan': 1.0,
            'revolving_credit': 0.75,
            'credit_card': 0.75,
            'letter_of_credit': 0.5,
            'guarantee': 1.0
        }
        
        ccf = ccf_rates.get(facility_type, 1.0)
        undrawn_amount = max(credit_limit - current_balance, 0)
        
        ead = current_balance + ccf * undrawn_amount
        return ead
    
    def _extract_credit_features(self, borrower_data):
        """提取信用特征"""
        return {
            'debt_to_income': borrower_data.get('total_debt', 0) / max(borrower_data.get('annual_income', 1), 1),
            'credit_score': borrower_data.get('credit_score', 650) / 850,
            'employment_years': min(borrower_data.get('employment_years', 0), 20) / 20,
            'loan_to_value': borrower_data.get('loan_amount', 0) / max(borrower_data.get('property_value', 1), 1),
            'payment_history': borrower_data.get('payment_history_score', 0.8)
        }
    
    def calculate_expected_loss(self, borrower_data, loan_data, facility_data, collateral_data=None):
        """计算预期损失 EL = PD × LGD × EAD"""
        pd = self.calculate_pd(borrower_data)
        lgd = self.calculate_lgd(loan_data, collateral_data)
        ead = self.calculate_ead(facility_data)
        
        el = pd * lgd * ead
        
        return {
            'expected_loss': el,
            'probability_of_default': pd,
            'loss_given_default': lgd,
            'exposure_at_default': ead
        }

class MarketRiskEngine:
    """市场风险计算引擎"""
    
    def __init__(self, confidence_level=0.99, holding_period=1):
        self.confidence_level = confidence_level
        self.holding_period = holding_period
        self.alpha = 1 - confidence_level
        
    def calculate_var_parametric(self, portfolio_value, returns, weights=None):
        """参数法计算VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # 计算组合收益率
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # 计算统计量
        mean_return = portfolio_returns.mean()
        std_return = portfolio_returns.std()
        
        # 计算VaR
        z_score = stats.norm.ppf(self.alpha)
        var = portfolio_value * (mean_return + z_score * std_return) * np.sqrt(self.holding_period)
        
        return abs(var)
    
    def calculate_var_historical(self, portfolio_value, returns, weights=None):
        """历史模拟法计算VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # 计算组合收益率
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # 计算历史VaR
        var_percentile = np.percentile(portfolio_returns, self.alpha * 100)
        var = portfolio_value * abs(var_percentile) * np.sqrt(self.holding_period)
        
        return var
    
    def calculate_var_monte_carlo(self, portfolio_value, returns, weights=None, n_simulations=10000):
        """蒙特卡洛模拟法计算VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # 计算历史统计量
        mean_returns = returns.mean()
        cov_matrix = returns.cov()
        
        # 蒙特卡洛模拟
        simulated_returns = np.random.multivariate_normal(
            mean_returns, cov_matrix, n_simulations
        )
        
        # 计算组合收益率
        portfolio_returns = np.dot(simulated_returns, weights)
        
        # 计算VaR
        var_percentile = np.percentile(portfolio_returns, self.alpha * 100)
        var = portfolio_value * abs(var_percentile) * np.sqrt(self.holding_period)
        
        return var
    
    def calculate_expected_shortfall(self, portfolio_value, returns, weights=None):
        """计算期望损失 (Expected Shortfall/CVaR)"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # 计算组合收益率
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # 计算VaR阈值
        var_threshold = np.percentile(portfolio_returns, self.alpha * 100)
        
        # 计算超过VaR的平均损失
        tail_losses = portfolio_returns[portfolio_returns <= var_threshold]
        expected_shortfall = portfolio_value * abs(tail_losses.mean()) * np.sqrt(self.holding_period)
        
        return expected_shortfall

class OperationalRiskEngine:
    """操作风险计算引擎"""
    
    def __init__(self):
        self.business_lines = {
            'corporate_finance': {'beta': 0.18, 'gross_income_weight': 1.0},
            'trading_sales': {'beta': 0.18, 'gross_income_weight': 1.0},
            'retail_banking': {'beta': 0.12, 'gross_income_weight': 1.0},
            'commercial_banking': {'beta': 0.15, 'gross_income_weight': 1.0},
            'payment_settlement': {'beta': 0.18, 'gross_income_weight': 1.0},
            'agency_services': {'beta': 0.15, 'gross_income_weight': 1.0},
            'asset_management': {'beta': 0.12, 'gross_income_weight': 1.0},
            'retail_brokerage': {'beta': 0.12, 'gross_income_weight': 1.0}
        }
    
    def calculate_operational_risk_capital(self, gross_income_data):
        """使用标准法计算操作风险资本"""
        total_capital = 0
        
        for business_line, income_data in gross_income_data.items():
            if business_line in self.business_lines:
                beta = self.business_lines[business_line]['beta']
                
                # 计算三年平均总收入
                annual_incomes = income_data.get('annual_gross_income', [])
                if len(annual_incomes) >= 3:
                    avg_income = np.mean(annual_incomes[-3:])  # 最近三年平均
                else:
                    avg_income = np.mean(annual_incomes) if annual_incomes else 0
                
                # 只考虑正收入
                if avg_income > 0:
                    capital_requirement = beta * avg_income
                    total_capital += capital_requirement
        
        return total_capital
    
    def calculate_loss_distribution(self, loss_events):
        """分析操作风险损失分布"""
        if not loss_events:
            return {'frequency': 0, 'severity': 0, 'total_loss': 0}
        
        losses = [event['amount'] for event in loss_events]
        
        # 频率分析
        frequency = len(losses)
        
        # 严重性分析
        severity_stats = {
            'mean': np.mean(losses),
            'median': np.median(losses),
            'std': np.std(losses),
            'max': np.max(losses),
            'percentile_95': np.percentile(losses, 95),
            'percentile_99': np.percentile(losses, 99)
        }
        
        return {
            'frequency': frequency,
            'severity': severity_stats,
            'total_loss': sum(losses)
        }

class RegulatoryCapitalCalculator:
    """监管资本计算器"""
    
    def __init__(self):
        self.credit_risk_engine = CreditRiskEngine()
        self.market_risk_engine = MarketRiskEngine()
        self.operational_risk_engine = OperationalRiskEngine()
        
        # 巴塞尔III资本要求
        self.capital_requirements = {
            'cet1_minimum': 0.045,  # 核心一级资本最低要求4.5%
            'tier1_minimum': 0.06,   # 一级资本最低要求6%
            'total_minimum': 0.08,   # 总资本最低要求8%
            'capital_buffer': 0.025, # 资本保护缓冲2.5%
            'systemic_buffer': 0.01  # 系统重要性缓冲1%
        }
    
    def calculate_credit_risk_rwa(self, loan_portfolio):
        """计算信用风险加权资产"""
        total_rwa = 0
        
        for loan in loan_portfolio:
            # 计算风险权重
            risk_weight = self._get_risk_weight(loan)
            
            # 计算EAD
            ead = self.credit_risk_engine.calculate_ead(loan.get('facility_data', {}))
            
            # 计算RWA
            rwa = ead * risk_weight
            total_rwa += rwa
        
        return total_rwa
    
    def _get_risk_weight(self, loan):
        """获取风险权重"""
        # 简化的风险权重表
        borrower_type = loan.get('borrower_type', 'corporate')
        rating = loan.get('rating', 'BB')
        
        risk_weights = {
            'sovereign': {'AAA': 0.0, 'AA': 0.0, 'A': 0.2, 'BBB': 0.2, 'BB': 0.5, 'B': 1.0, 'CCC': 1.5},
            'bank': {'AAA': 0.2, 'AA': 0.2, 'A': 0.5, 'BBB': 0.5, 'BB': 1.0, 'B': 1.5, 'CCC': 1.5},
            'corporate': {'AAA': 0.2, 'AA': 0.2, 'A': 0.5, 'BBB': 1.0, 'BB': 1.0, 'B': 1.5, 'CCC': 1.5},
            'retail': {'standard': 0.75, 'mortgage': 0.35, 'sme': 0.75}
        }
        
        if borrower_type == 'retail':
            loan_type = loan.get('loan_type', 'standard')
            return risk_weights['retail'].get(loan_type, 0.75)
        else:
            return risk_weights.get(borrower_type, {}).get(rating, 1.0)
    
    def calculate_market_risk_rwa(self, trading_portfolio):
        """计算市场风险加权资产"""
        # 简化计算：VaR * 12.5 (监管乘数)
        var = self.market_risk_engine.calculate_var_parametric(
            trading_portfolio['value'],
            trading_portfolio['returns']
        )
        
        market_risk_rwa = var * 12.5
        return market_risk_rwa
    
    def calculate_operational_risk_rwa(self, gross_income_data):
        """计算操作风险加权资产"""
        operational_capital = self.operational_risk_engine.calculate_operational_risk_capital(
            gross_income_data
        )
        
        # 操作风险资本 * 12.5
        operational_rwa = operational_capital * 12.5
        return operational_rwa
    
    def calculate_capital_ratios(self, capital_data, rwa_data):
        """计算资本充足率"""
        total_rwa = sum(rwa_data.values())
        
        ratios = {
            'cet1_ratio': capital_data['cet1_capital'] / total_rwa,
            'tier1_ratio': capital_data['tier1_capital'] / total_rwa,
            'total_ratio': capital_data['total_capital'] / total_rwa
        }
        
        # 检查监管要求
        compliance = {
            'cet1_compliant': ratios['cet1_ratio'] >= self.capital_requirements['cet1_minimum'],
            'tier1_compliant': ratios['tier1_ratio'] >= self.capital_requirements['tier1_minimum'],
            'total_compliant': ratios['total_ratio'] >= self.capital_requirements['total_minimum']
        }
        
        return {
            'ratios': ratios,
            'compliance': compliance,
            'total_rwa': total_rwa
        }

class StressTestEngine:
    """压力测试引擎"""
    
    def __init__(self):
        self.scenarios = {
            'baseline': {'gdp_growth': 0.02, 'unemployment': 0.05, 'interest_rate': 0.03},
            'adverse': {'gdp_growth': -0.01, 'unemployment': 0.08, 'interest_rate': 0.05},
            'severely_adverse': {'gdp_growth': -0.05, 'unemployment': 0.12, 'interest_rate': 0.02}
        }
    
    def run_stress_test(self, portfolio_data, scenario='adverse'):
        """运行压力测试"""
        scenario_params = self.scenarios.get(scenario, self.scenarios['adverse'])
        
        # 计算压力情景下的损失
        stressed_results = {
            'credit_losses': self._stress_credit_portfolio(portfolio_data.get('loans', []), scenario_params),
            'market_losses': self._stress_market_portfolio(portfolio_data.get('trading', {}), scenario_params),
            'operational_losses': self._stress_operational_risk(portfolio_data.get('operations', {}), scenario_params)
        }
        
        total_losses = sum(stressed_results.values())
        
        return {
            'scenario': scenario,
            'scenario_params': scenario_params,
            'stressed_losses': stressed_results,
            'total_losses': total_losses
        }
    
    def _stress_credit_portfolio(self, loan_portfolio, scenario_params):
        """信用组合压力测试"""
        # 简化模型：经济下行导致PD上升
        gdp_impact = max(1 + scenario_params['gdp_growth'] * -2, 0.5)  # GDP下降2%，PD上升4%
        unemployment_impact = 1 + scenario_params['unemployment'] * 5  # 失业率上升1%，PD上升5%
        
        total_stressed_loss = 0
        credit_engine = CreditRiskEngine()
        
        for loan in loan_portfolio:
            # 基础预期损失
            base_el = credit_engine.calculate_expected_loss(
                loan.get('borrower_data', {}),
                loan.get('loan_data', {}),
                loan.get('facility_data', {}),
                loan.get('collateral_data')
            )['expected_loss']
            
            # 压力调整
            stressed_multiplier = gdp_impact * unemployment_impact
            stressed_loss = base_el * stressed_multiplier
            
            total_stressed_loss += stressed_loss
        
        return total_stressed_loss
    
    def _stress_market_portfolio(self, trading_portfolio, scenario_params):
        """市场组合压力测试"""
        if not trading_portfolio:
            return 0
        
        # 利率冲击
        interest_rate_shock = scenario_params['interest_rate'] - 0.03  # 相对基准利率的变化
        
        # 简化计算：利率上升1%，债券组合损失约为久期*1%
        duration = trading_portfolio.get('duration', 5)
        bond_value = trading_portfolio.get('bond_value', 0)
        
        interest_rate_loss = bond_value * duration * abs(interest_rate_shock)
        
        # 股票冲击（基于GDP增长）
        equity_shock = scenario_params['gdp_growth'] * 3  # GDP下降1%，股票下跌3%
        equity_value = trading_portfolio.get('equity_value', 0)
        equity_loss = equity_value * abs(equity_shock)
        
        return interest_rate_loss + equity_loss
    
    def _stress_operational_risk(self, operations_data, scenario_params):
        """操作风险压力测试"""
        # 经济压力下操作风险事件增加
        base_operational_loss = operations_data.get('annual_operational_loss', 0)
        stress_multiplier = 1.5 if scenario_params['gdp_growth'] < 0 else 1.0
        
        return base_operational_loss * stress_multiplier</code></pre>
                    </div>
                    
                    <h3>实际应用案例</h3>
                    <p>以下是银行全面风险管理平台在实际业务中的具体运用示例：</p>
                    
                    <h4>案例一：信用风险评估与资本计量</h4>
                    <div class="code-example">
<pre><code># 信用风险评估与资本计量示例
import pandas as pd
import numpy as np
from datetime import datetime

# 初始化风险引擎
credit_engine = CreditRiskEngine()
regulatory_calculator = RegulatoryCapitalCalculator()

# 模拟贷款组合数据
loan_portfolio = [
    {
        'loan_id': 'LOAN_001',
        'borrower_data': {
            'annual_income': 120000,
            'total_debt': 45000,
            'credit_score': 720,
            'employment_years': 8,
            'payment_history_score': 0.95
        },
        'loan_data': {
            'amount': 300000,
            'type': 'mortgage',
            'term_years': 30
        },
        'facility_data': {
            'current_balance': 280000,
            'credit_limit': 300000,
            'type': 'term_loan'
        },
        'collateral_data': {
            'type': 'real_estate',
            'value': 400000
        },
        'borrower_type': 'retail',
        'loan_type': 'mortgage',
        'rating': 'A'
    },
    {
        'loan_id': 'LOAN_002',
        'borrower_data': {
            'annual_income': 80000,
            'total_debt': 35000,
            'credit_score': 650,
            'employment_years': 3,
            'payment_history_score': 0.85
        },
        'loan_data': {
            'amount': 25000,
            'type': 'personal',
            'term_years': 5
        },
        'facility_data': {
            'current_balance': 20000,
            'credit_limit': 25000,
            'type': 'term_loan'
        },
        'borrower_type': 'retail',
        'loan_type': 'standard',
        'rating': 'BBB'
    },
    {
        'loan_id': 'LOAN_003',
        'borrower_data': {
            'annual_income': 2000000,  # 企业年收入
            'total_debt': 800000,
            'credit_score': 680,
            'employment_years': 15,
            'payment_history_score': 0.90
        },
        'loan_data': {
            'amount': 1000000,
            'type': 'commercial',
            'term_years': 7
        },
        'facility_data': {
            'current_balance': 850000,
            'credit_limit': 1000000,
            'type': 'revolving_credit'
        },
        'borrower_type': 'corporate',
        'rating': 'BB'
    }
]

print("💳 信用风险评估结果")
print("=" * 60)

total_expected_loss = 0
total_ead = 0
risk_details = []

# 逐笔贷款风险评估
for loan in loan_portfolio:
    risk_metrics = credit_engine.calculate_expected_loss(
        loan['borrower_data'],
        loan['loan_data'],
        loan['facility_data'],
        loan.get('collateral_data')
    )
    
    total_expected_loss += risk_metrics['expected_loss']
    total_ead += risk_metrics['exposure_at_default']
    
    risk_details.append({
        'loan_id': loan['loan_id'],
        'borrower_type': loan['borrower_type'],
        'loan_amount': loan['loan_data']['amount'],
        **risk_metrics
    })
    
    print(f"\n贷款ID: {loan['loan_id']}")
    print(f"借款人类型: {loan['borrower_type']}")
    print(f"贷款金额: ¥{loan['loan_data']['amount']:,}")
    print(f"违约概率 (PD): {risk_metrics['probability_of_default']:.2%}")
    print(f"违约损失率 (LGD): {risk_metrics['loss_given_default']:.2%}")
    print(f"违约风险敞口 (EAD): ¥{risk_metrics['exposure_at_default']:,.0f}")
    print(f"预期损失 (EL): ¥{risk_metrics['expected_loss']:,.0f}")

# 计算风险加权资产
credit_rwa = regulatory_calculator.calculate_credit_risk_rwa(loan_portfolio)

print(f"\n" + "=" * 60)
print("📊 组合风险汇总")
print(f"总预期损失: ¥{total_expected_loss:,.0f}")
print(f"总风险敞口: ¥{total_ead:,.0f}")
print(f"信用风险加权资产: ¥{credit_rwa:,.0f}")
print(f"平均损失率: {total_expected_loss/total_ead:.2%}")

# 风险分布分析
print(f"\n📈 风险分布分析")
risk_df = pd.DataFrame(risk_details)
print(f"零售贷款预期损失: ¥{risk_df[risk_df['borrower_type']=='retail']['expected_loss'].sum():,.0f}")
print(f"企业贷款预期损失: ¥{risk_df[risk_df['borrower_type']=='corporate']['expected_loss'].sum():,.0f}")

# 风险等级分布
high_risk_loans = risk_df[risk_df['probability_of_default'] > 0.05]
print(f"高风险贷款数量: {len(high_risk_loans)}笔")
print(f"高风险贷款占比: {len(high_risk_loans)/len(risk_df):.1%}")</code></pre>
                    </div>
                    
                    <h4>案例二：市场风险VaR计算与监控</h4>
                    <div class="code-example">
<pre><code># 市场风险VaR计算与监控示例
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 初始化市场风险引擎
market_engine = MarketRiskEngine(confidence_level=0.99, holding_period=1)

# 模拟交易组合数据
np.random.seed(42)
n_days = 252  # 一年交易日
n_assets = 5

# 生成模拟的历史收益率数据
asset_names = ['股票A', '股票B', '债券C', '商品D', '外汇E']
base_returns = np.array([0.0008, 0.0006, 0.0002, 0.0004, 0.0001])  # 日均收益率
volatilities = np.array([0.02, 0.025, 0.008, 0.03, 0.012])  # 日波动率

# 生成相关性矩阵
correlation_matrix = np.array([
    [1.0, 0.6, 0.2, 0.3, 0.1],
    [0.6, 1.0, 0.1, 0.4, 0.2],
    [0.2, 0.1, 1.0, -0.1, 0.3],
    [0.3, 0.4, -0.1, 1.0, 0.0],
    [0.1, 0.2, 0.3, 0.0, 1.0]
])

# 生成协方差矩阵
cov_matrix = np.outer(volatilities, volatilities) * correlation_matrix

# 生成历史收益率数据
returns_data = np.random.multivariate_normal(base_returns, cov_matrix, n_days)
returns_df = pd.DataFrame(returns_data, columns=asset_names)

# 交易组合配置
portfolio_config = {
    'positions': {
        '股票A': {'shares': 10000, 'price': 50.0},
        '股票B': {'shares': 8000, 'price': 75.0},
        '债券C': {'shares': 20000, 'price': 100.0},
        '商品D': {'shares': 5000, 'price': 120.0},
        '外汇E': {'shares': 100000, 'price': 6.5}
    }
}

# 计算组合价值和权重
total_value = 0
position_values = {}
for asset, position in portfolio_config['positions'].items():
    value = position['shares'] * position['price']
    position_values[asset] = value
    total_value += value

weights = np.array([position_values[asset] / total_value for asset in asset_names])

print("📊 市场风险VaR计算结果")
print("=" * 60)

print(f"组合总价值: ¥{total_value:,.0f}")
print(f"\n持仓明细:")
for asset, position in portfolio_config['positions'].items():
    value = position_values[asset]
    weight = value / total_value
    print(f"  {asset}: {position['shares']:,}股 × ¥{position['price']:.1f} = ¥{value:,.0f} ({weight:.1%})")

# 计算不同方法的VaR
var_parametric = market_engine.calculate_var_parametric(total_value, returns_df, weights)
var_historical = market_engine.calculate_var_historical(total_value, returns_df, weights)
var_monte_carlo = market_engine.calculate_var_monte_carlo(total_value, returns_df, weights)
expected_shortfall = market_engine.calculate_expected_shortfall(total_value, returns_df, weights)

print(f"\n🎯 VaR计算结果 (99%置信度, 1日持有期):")
print(f"参数法VaR: ¥{var_parametric:,.0f} ({var_parametric/total_value:.2%})")
print(f"历史模拟法VaR: ¥{var_historical:,.0f} ({var_historical/total_value:.2%})")
print(f"蒙特卡洛法VaR: ¥{var_monte_carlo:,.0f} ({var_monte_carlo/total_value:.2%})")
print(f"期望损失(ES): ¥{expected_shortfall:,.0f} ({expected_shortfall/total_value:.2%})")

# 计算不同置信度的VaR
confidence_levels = [0.95, 0.99, 0.999]
print(f"\n📈 不同置信度VaR对比:")
for conf_level in confidence_levels:
    temp_engine = MarketRiskEngine(confidence_level=conf_level)
    var_temp = temp_engine.calculate_var_parametric(total_value, returns_df, weights)
    print(f"{conf_level:.1%}置信度VaR: ¥{var_temp:,.0f} ({var_temp/total_value:.2%})")

# 分解VaR贡献度
print(f"\n🔍 VaR贡献度分析:")
for i, asset in enumerate(asset_names):
    # 计算边际VaR (简化计算)
    asset_weight = weights[i]
    asset_volatility = volatilities[i]
    portfolio_volatility = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
    
    # 边际VaR贡献
    marginal_var = asset_weight * asset_volatility * stats.norm.ppf(0.01) * total_value
    contribution_pct = abs(marginal_var) / var_parametric * 100
    
    print(f"  {asset}: ¥{abs(marginal_var):,.0f} ({contribution_pct:.1f}%)")

# 压力测试场景
print(f"\n⚡ 压力测试场景:")
stress_scenarios = {
    '股市暴跌': {'股票A': -0.20, '股票B': -0.25, '债券C': 0.05, '商品D': -0.10, '外汇E': 0.02},
    '利率上升': {'股票A': -0.05, '股票B': -0.03, '债券C': -0.15, '商品D': 0.02, '外汇E': 0.08},
    '金融危机': {'股票A': -0.30, '股票B': -0.35, '债券C': -0.05, '商品D': -0.20, '外汇E': 0.15}
}

for scenario_name, shocks in stress_scenarios.items():
    scenario_loss = 0
    for asset, shock in shocks.items():
        asset_value = position_values[asset]
        loss = asset_value * abs(min(shock, 0))
        scenario_loss += loss
    
    print(f"  {scenario_name}: 损失¥{scenario_loss:,.0f} ({scenario_loss/total_value:.2%})")

# 市场风险限额监控
var_limit = total_value * 0.02  # VaR限额设为组合价值的2%
print(f"\n🚨 风险限额监控:")
print(f"VaR限额: ¥{var_limit:,.0f}")
print(f"当前VaR: ¥{var_parametric:,.0f}")
print(f"限额使用率: {var_parametric/var_limit:.1%}")

if var_parametric > var_limit:
    print("⚠️ 警告: VaR超过限额!")
else:
    print("✅ VaR在限额范围内")</code></pre>
                    </div>
                    
                    <h4>案例三：压力测试与资本充足率评估</h4>
                    <div class="code-example">
<pre><code># 压力测试与资本充足率评估示例
import pandas as pd
import numpy as np
from datetime import datetime

# 初始化引擎
stress_engine = StressTestEngine()
regulatory_calculator = RegulatoryCapitalCalculator()

# 银行资产负债表数据
bank_data = {
    'capital_data': {
        'cet1_capital': 15000000000,  # 核心一级资本150亿
        'tier1_capital': 18000000000,  # 一级资本180亿
        'total_capital': 22000000000   # 总资本220亿
    },
    'portfolio_data': {
        'loans': loan_portfolio,  # 使用之前定义的贷款组合
        'trading': {
            'value': 5000000000,  # 交易账户50亿
            'returns': returns_df,  # 使用之前的收益率数据
            'bond_value': 3000000000,
            'equity_value': 2000000000,
            'duration': 4.5
        },
        'operations': {
            'annual_operational_loss': 50000000  # 年度操作损失5000万
        }
    },
    'gross_income_data': {
        'retail_banking': {
            'annual_gross_income': [800000000, 850000000, 900000000]  # 最近三年收入
        },
        'corporate_finance': {
            'annual_gross_income': [600000000, 650000000, 700000000]
        },
        'trading_sales': {
            'annual_gross_income': [400000000, 420000000, 450000000]
        },
        'commercial_banking': {
            'annual_gross_income': [500000000, 520000000, 550000000]
        }
    }
}

print("🏦 银行全面风险管理评估")
print("=" * 60)

# 1. 计算各类风险加权资产
print("\n📊 风险加权资产计算:")

# 信用风险RWA
credit_rwa = regulatory_calculator.calculate_credit_risk_rwa(bank_data['portfolio_data']['loans'])
print(f"信用风险RWA: ¥{credit_rwa:,.0f}")

# 市场风险RWA
market_rwa = regulatory_calculator.calculate_market_risk_rwa(bank_data['portfolio_data']['trading'])
print(f"市场风险RWA: ¥{market_rwa:,.0f}")

# 操作风险RWA
operational_rwa = regulatory_calculator.calculate_operational_risk_rwa(bank_data['gross_income_data'])
print(f"操作风险RWA: ¥{operational_rwa:,.0f}")

rwa_data = {
    'credit_risk': credit_rwa,
    'market_risk': market_rwa,
    'operational_risk': operational_rwa
}

total_rwa = sum(rwa_data.values())
print(f"\n总风险加权资产: ¥{total_rwa:,.0f}")

# 2. 计算资本充足率
print("\n💰 资本充足率计算:")
capital_ratios = regulatory_calculator.calculate_capital_ratios(
    bank_data['capital_data'], 
    rwa_data
)

print(f"核心一级资本充足率: {capital_ratios['ratios']['cet1_ratio']:.2%}")
print(f"一级资本充足率: {capital_ratios['ratios']['tier1_ratio']:.2%}")
print(f"总资本充足率: {capital_ratios['ratios']['total_ratio']:.2%}")

# 监管要求检查
print(f"\n✅ 监管合规检查:")
print(f"核心一级资本合规: {'✅ 达标' if capital_ratios['compliance']['cet1_compliant'] else '❌ 不达标'}")
print(f"一级资本合规: {'✅ 达标' if capital_ratios['compliance']['tier1_compliant'] else '❌ 不达标'}")
print(f"总资本合规: {'✅ 达标' if capital_ratios['compliance']['total_compliant'] else '❌ 不达标'}")

# 3. 压力测试
print(f"\n⚡ 压力测试结果:")

for scenario in ['baseline', 'adverse', 'severely_adverse']:
    stress_result = stress_engine.run_stress_test(bank_data['portfolio_data'], scenario)
    
    print(f"\n{scenario.upper()}情景:")
    print(f"  GDP增长率: {stress_result['scenario_params']['gdp_growth']:.1%}")
    print(f"  失业率: {stress_result['scenario_params']['unemployment']:.1%}")
    print(f"  利率水平: {stress_result['scenario_params']['interest_rate']:.1%}")
    
    print(f"  压力损失:")
    print(f"    信用损失: ¥{stress_result['stressed_losses']['credit_losses']:,.0f}")
    print(f"    市场损失: ¥{stress_result['stressed_losses']['market_losses']:,.0f}")
    print(f"    操作损失: ¥{stress_result['stressed_losses']['operational_losses']:,.0f}")
    print(f"    总损失: ¥{stress_result['total_losses']:,.0f}")
    
    # 压力后资本充足率
    stressed_capital = bank_data['capital_data']['cet1_capital'] - stress_result['total_losses']
    stressed_cet1_ratio = stressed_capital / total_rwa
    
    print(f"  压力后核心一级资本充足率: {stressed_cet1_ratio:.2%}")
    
    if stressed_cet1_ratio < 0.045:  # 低于4.5%最低要求
        capital_shortfall = (0.045 * total_rwa) - stressed_capital
        print(f"  ⚠️ 资本缺口: ¥{capital_shortfall:,.0f}")
    else:
        print(f"  ✅ 通过压力测试")

# 4. 风险监控指标
print(f"\n📈 关键风险指标监控:")

# 集中度风险
largest_exposure = max([loan['loan_data']['amount'] for loan in bank_data['portfolio_data']['loans']])
concentration_ratio = largest_exposure / bank_data['capital_data']['tier1_capital']
print(f"最大单一客户敞口占一级资本比例: {concentration_ratio:.2%}")

# 流动性覆盖率 (简化计算)
high_quality_assets = bank_data['capital_data']['cet1_capital'] * 0.8  # 假设80%为高质量流动性资产
net_cash_outflows = total_rwa * 0.03  # 假设净现金流出为RWA的3%
lcr = high_quality_assets / net_cash_outflows
print(f"流动性覆盖率 (LCR): {lcr:.1%}")

# 杠杆率
total_assets = total_rwa * 1.2  # 假设总资产为RWA的1.2倍
leverage_ratio = bank_data['capital_data']['tier1_capital'] / total_assets
print(f"杠杆率: {leverage_ratio:.2%}")

# 5. 风险预警
print(f"\n🚨 风险预警评估:")

warnings = []
if capital_ratios['ratios']['cet1_ratio'] < 0.07:  # 低于7%预警线
    warnings.append("核心一级资本充足率接近监管要求")

if concentration_ratio > 0.25:  # 单一客户敞口超过25%
    warnings.append("存在客户集中度风险")

if lcr < 1.0:  # LCR低于100%
    warnings.append("流动性覆盖率不足")

if leverage_ratio < 0.03:  # 杠杆率低于3%
    warnings.append("杠杆率偏低")

if warnings:
    for warning in warnings:
        print(f"  ⚠️ {warning}")
else:
    print(f"  ✅ 所有指标正常")

# 6. 监管报告摘要
print(f"\n📋 监管报告摘要:")
print(f"报告日期: {datetime.now().strftime('%Y-%m-%d')}")
print(f"风险加权资产总额: ¥{total_rwa:,.0f}")
print(f"核心一级资本: ¥{bank_data['capital_data']['cet1_capital']:,.0f}")
print(f"核心一级资本充足率: {capital_ratios['ratios']['cet1_ratio']:.2%}")
print(f"压力测试结果: {'通过' if stressed_cet1_ratio >= 0.045 else '需要关注'}")
print(f"整体风险评级: {'低风险' if len(warnings) == 0 else '中等风险' if len(warnings) <= 2 else '高风险'}")</code></pre>
                    </div>
                    
                </div>
            </div>
        </div>
    </main>

    <script>
        function showTab(tabName) {
            // 隐藏所有标签内容
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // 移除所有导航标签的active类
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示选中的标签内容
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // 激活对应的导航标签
            const activeNavTab = document.querySelector(`[onclick="showTab('${tabName}')"]`);
            if (activeNavTab) {
                activeNavTab.classList.add('active');
            }
        }
    </script>
</body>
</html>