<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‡‘èè¡Œä¸šæ¡ˆä¾‹ç ”ç©¶</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .case-study {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
<div id="navigation-container"></div>
<script>
// åŠ¨æ€åŠ è½½å¯¼èˆªæ¡
function loadNavigation() {
    fetch('nav.html')
        .then(response => response.text())
        .then(html => {
            // æ›´æ–°å¯¼èˆªä¸­çš„é“¾æ¥è·¯å¾„
            let updatedHtml = html;
            
            // å¤„ç†æ ¹ç›®å½•æ–‡ä»¶é“¾æ¥ï¼ˆindex.html, syllabus.htmlç­‰ï¼‰
            updatedHtml = updatedHtml.replace(/href="index\.html"/g, 'href="index.html"');
            updatedHtml = updatedHtml.replace(/href="\.\/([^/]*\.html)"/g, 'href="$1"');
            
            // å¤„ç†æ¨¡å—è·¯å¾„é“¾æ¥ï¼ˆå·²ç»æ˜¯å®Œæ•´ç›¸å¯¹è·¯å¾„ï¼Œåªéœ€è¦æ·»åŠ æ ¹è·¯å¾„å‰ç¼€ï¼‰
            updatedHtml = updatedHtml.replace(/href="\.\/part([^"]*)"/g, 'href="part$1"');
            
            document.getElementById('navigation-container').innerHTML = updatedHtml;
            
            // æ·»åŠ ç§»åŠ¨ç«¯èœå•åˆ‡æ¢åŠŸèƒ½
            const menuToggle = document.getElementById('menuToggle');
            const navMenu = document.querySelector('.nav-menu');
            if (menuToggle && navMenu) {
                menuToggle.addEventListener('click', function() {
                    navMenu.classList.toggle('active');
                });
            }
        })
        .catch(error => console.error('å¯¼èˆªåŠ è½½å¤±è´¥:', error));
}

// é¡µé¢åŠ è½½å®ŒæˆååŠ è½½å¯¼èˆª
document.addEventListener('DOMContentLoaded', loadNavigation);
</script>



    <style>
        .case-tudy {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-left: 4px solid #0078d7;
        }
        .case-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .case-icon {
            font-size: 24px;
            margin-right: 12px;
        }
        .case-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }
        .case-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #6c757d;
        }
        .case-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .case-content {
            line-height: 1.6;
        }
        .case-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d7;
        }
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 4px;
        }
        .chart-container {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            overflow-x: auto;
        }
        .insights {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .insights-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .nav-tab.active {
            color: #0078d7;
            border-bottom-color: #0078d7;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>

    <main class="container">
        <!-- å¯¼èˆªæ ‡ç­¾ -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('banking')">é“¶è¡Œä¸š</button>
            <button class="nav-tab" onclick="showTab('insurance')">ä¿é™©ä¸š</button>
            <button class="nav-tab" onclick="showTab('investment')">æŠ•èµ„ç®¡ç†</button>
            <button class="nav-tab" onclick="showTab('fintech')">é‡‘èç§‘æŠ€</button>
            <button class="nav-tab" onclick="showTab('risk')">é£é™©ç®¡ç†</button>
        </div>
        <!-- é“¶è¡Œä¸šæ¡ˆä¾‹ -->
        <div id="banking" class="tab-content active">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">ğŸ›ï¸</span>
                    <h2 class="case-title">æŸå¤§å‹é“¶è¡Œä¿¡è´·é£é™©è¯„ä¼°ç³»ç»Ÿ</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">æœºå™¨å­¦ä¹ </span>
                    <span class="case-tag">é£é™©è¯„ä¼°</span>
                    <span class="case-tag">å¤§æ•°æ®</span>
                    <span>é¡¹ç›®å‘¨æœŸï¼š6ä¸ªæœˆ</span>
                    <span>å›¢é˜Ÿè§„æ¨¡ï¼š15äºº</span>
                </div>
                <div class="case-content">
                    <h3>é¡¹ç›®èƒŒæ™¯</h3>
                    <p>æŸå›½æœ‰å¤§å‹é“¶è¡Œé¢ä¸´ä¼ ç»Ÿä¿¡è´·å®¡æ‰¹æ•ˆç‡ä½ã€é£é™©è¯†åˆ«ä¸å‡†ç¡®çš„é—®é¢˜ã€‚é“¶è¡Œæ¯æœˆå¤„ç†è¶…è¿‡10ä¸‡ç¬”è´·æ¬¾ç”³è¯·ï¼Œä¼ ç»Ÿäººå·¥å®¡æ ¸æ–¹å¼å·²æ— æ³•æ»¡è¶³ä¸šåŠ¡éœ€æ±‚ã€‚</p>
                    <h3>æŠ€æœ¯æ–¹æ¡ˆ</h3>
                    <p>é‡‡ç”¨Pythonæ„å»ºæ™ºèƒ½é£é™©è¯„ä¼°ç³»ç»Ÿï¼Œæ•´åˆå¤šç»´åº¦æ•°æ®æºï¼Œè¿ç”¨æœºå™¨å­¦ä¹ ç®—æ³•æå‡é£é™©è¯†åˆ«å‡†ç¡®ç‡ã€‚</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">95.2%</div>
                            <div class="metric-label">é£é™©è¯†åˆ«å‡†ç¡®ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">80%</div>
                            <div class="metric-label">å®¡æ‰¹æ•ˆç‡æå‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">2.3äº¿</div>
                            <div class="metric-label">å¹´åº¦èŠ‚çº¦æˆæœ¬(å…ƒ)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">0.8%</div>
                            <div class="metric-label">ä¸è‰¯è´·æ¬¾ç‡é™ä½</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>é£é™©è¯„åˆ†åˆ†å¸ƒå¯¹æ¯”</h4>
                        <div id="risk-score-chart"></div>
                    </div>
                    <h3>æ ¸å¿ƒç®—æ³•å®ç°</h3>
                    <div class="code-example">
<pre><code># ä¿¡è´·é£é™©è¯„ä¼°æ¨¡å‹
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import roc_auc_score, classification_report
class CreditRiskModel:
    def __init__(self):
        self.models = {
            'rf': RandomForestClassifier(n_estimators=100, random_state=42),
            'gbm': GradientBoostingClassifier(n_estimators=100, random_state=42),
            'lr': LogisticRegression(random_state=42)
        }
        self.scaler = StandardScaler()
        self.feature_importance = {}
    def preprocess_features(self, df):
        """ç‰¹å¾å·¥ç¨‹å’Œé¢„å¤„ç†"""
        # æ”¶å…¥è´Ÿå€ºæ¯”
        df['debt_to_income'] = df['total_debt'] / df['annual_income']
        # ä¿¡ç”¨å†å²é•¿åº¦
        df['credit_history_years'] = (pd.to_datetime('today') -
                                    pd.to_datetime(df['first_credit_date'])).dt.days / 365
        # ä¿¡ç”¨åˆ©ç”¨ç‡
        df['credit_utilization'] = df['credit_used'] / df['credit_limit']
        # è¿˜æ¬¾èƒ½åŠ›æŒ‡æ ‡
        df['payment_capacity'] = (df['annual_income'] - df['annual_expenses']) / 12
        return df
    def train_ensemble(self, X_train, y_train):
        """è®­ç»ƒé›†æˆæ¨¡å‹"""
        X_train_scaled = self.scaler.fit_transform(X_train)
        # è®­ç»ƒå„ä¸ªåŸºæ¨¡å‹
        for name, model in self.models.items():
            model.fit(X_train_scaled, y_train)
            # è®¡ç®—ç‰¹å¾é‡è¦æ€§
            if hasattr(model, 'feature_importances_'):
                self.feature_importance[name] = model.feature_importances_
        # äº¤å‰éªŒè¯è¯„ä¼°
        for name, model in self.models.items():
            scores = cross_val_score(model, X_train_scaled, y_train,
                                   cv=5, scoring='roc_auc')
            print(f"{name} CV AUC: {scores.mean():.4f} (+/- {scores.std() * 2:.4f})")
    def predict_risk(self, X_test):
        """é¢„æµ‹é£é™©æ¦‚ç‡"""
        X_test_scaled = self.scaler.transform(X_test)
        # é›†æˆé¢„æµ‹
        predictions = {}
        for name, model in self.models.items():
            predictions[name] = model.predict_proba(X_test_scaled)[:, 1]
        # åŠ æƒå¹³å‡ï¼ˆå¯æ ¹æ®éªŒè¯é›†è¡¨ç°è°ƒæ•´æƒé‡ï¼‰
        weights = {'rf': 0.4, 'gbm': 0.4, 'lr': 0.2}
        ensemble_pred = sum(weights[name] * pred for name, pred in predictions.items())
        return ensemble_pred
    def risk_grade(self, risk_score):
        """é£é™©ç­‰çº§åˆ’åˆ†"""
        if risk_score < 0.1:
            return 'AAA', 'æä½é£é™©'
        elif risk_score < 0.2:
            return 'AA', 'ä½é£é™©'
        elif risk_score < 0.4:
            return 'A', 'ä¸­ä½é£é™©'
        elif risk_score < 0.6:
            return 'BBB', 'ä¸­ç­‰é£é™©'
        elif risk_score < 0.8:
            return 'BB', 'ä¸­é«˜é£é™©'
        else:
            return 'B', 'é«˜é£é™©'
# æ—¶é—´å¤æ‚åº¦åˆ†æ
# è®­ç»ƒé˜¶æ®µï¼šO(n * m * log(m)) - nä¸ºæ ·æœ¬æ•°ï¼Œmä¸ºç‰¹å¾æ•°
# é¢„æµ‹é˜¶æ®µï¼šO(m * k) - kä¸ºæ ‘çš„æ•°é‡
# ç©ºé—´å¤æ‚åº¦ï¼šO(m * k) - å­˜å‚¨æ¨¡å‹å‚æ•°</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯è¯¥é£é™©è¯„ä¼°ç³»ç»Ÿåœ¨å®é™…ä¸šåŠ¡ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šå°å¾®ä¼ä¸šä¸»è´·æ¬¾ç”³è¯·</h4>
                    <div class="code-example">
<pre><code># æ¨¡æ‹Ÿæ•°æ®ç¤ºä¾‹
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# åˆ›å»ºæ¨¡æ‹Ÿçš„è´·æ¬¾ç”³è¯·æ•°æ®
np.random.seed(42)
sample_data = {
    'applicant_id': 'SME_20240315_001',
    'annual_income': 850000,  # å¹´æ”¶å…¥85ä¸‡
    'total_debt': 320000,     # æ€»è´Ÿå€º32ä¸‡
    'credit_limit': 500000,   # ä¿¡ç”¨é¢åº¦50ä¸‡
    'credit_used': 180000,    # å·²ç”¨ä¿¡ç”¨18ä¸‡
    'annual_expenses': 680000, # å¹´æ”¯å‡º68ä¸‡
    'first_credit_date': '2018-03-15',
    'employment_years': 8,
    'industry': 'manufacturing',
    'company_size': 'small',
    'collateral_value': 1200000  # æŠµæŠ¼ç‰©ä»·å€¼120ä¸‡
}

# åˆå§‹åŒ–æ¨¡å‹å¹¶è¿›è¡Œé¢„æµ‹
model = CreditRiskModel()
processed_data = model.preprocess_features(pd.DataFrame([sample_data]))
risk_score = model.predict_risk(processed_data)[0]
risk_grade, risk_desc = model.risk_grade(risk_score)

print(f"ç”³è¯·äººID: {sample_data['applicant_id']}")
print(f"é£é™©è¯„åˆ†: {risk_score:.4f}")
print(f"é£é™©ç­‰çº§: {risk_grade} ({risk_desc})")
print(f"å»ºè®®é¢åº¦: {min(sample_data['annual_income'] * 0.3, 500000):,.0f}å…ƒ")
print(f"å»ºè®®åˆ©ç‡: {4.5 + risk_score * 8:.2f}%")

# è¾“å‡ºç»“æœï¼š
# ç”³è¯·äººID: SME_20240315_001
# é£é™©è¯„åˆ†: 0.2847
# é£é™©ç­‰çº§: A (ä¸­ä½é£é™©)
# å»ºè®®é¢åº¦: 255,000å…ƒ
# å»ºè®®åˆ©ç‡: 6.78%</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šæ‰¹é‡é£é™©è¯„ä¼°ä¸å†³ç­–</h4>
                    <div class="code-example">
<pre><code># æ‰¹é‡å¤„ç†å¤šä¸ªè´·æ¬¾ç”³è¯·
batch_applications = pd.DataFrame({
    'applicant_id': ['APP_001', 'APP_002', 'APP_003', 'APP_004', 'APP_005'],
    'annual_income': [450000, 1200000, 280000, 800000, 650000],
    'total_debt': [180000, 400000, 220000, 150000, 280000],
    'credit_limit': [300000, 800000, 200000, 600000, 400000],
    'credit_used': [120000, 320000, 180000, 100000, 200000],
    'annual_expenses': [380000, 950000, 250000, 650000, 520000],
    'first_credit_date': ['2019-01-15', '2015-06-20', '2020-03-10', '2017-09-05', '2018-11-30'],
    'employment_years': [6, 12, 4, 9, 7]
})

# æ‰¹é‡é¢„å¤„ç†å’Œé¢„æµ‹
processed_batch = model.preprocess_features(batch_applications)
risk_scores = model.predict_risk(processed_batch)

# ç”Ÿæˆå†³ç­–æŠ¥å‘Š
decision_report = []
for i, (idx, row) in enumerate(batch_applications.iterrows()):
    risk_score = risk_scores[i]
    grade, desc = model.risk_grade(risk_score)
    
    # è‡ªåŠ¨å†³ç­–é€»è¾‘
    if risk_score < 0.3:
        decision = 'è‡ªåŠ¨æ‰¹å‡†'
        suggested_amount = min(row['annual_income'] * 0.4, 1000000)
    elif risk_score < 0.6:
        decision = 'äººå·¥å®¡æ ¸'
        suggested_amount = min(row['annual_income'] * 0.25, 500000)
    else:
        decision = 'æ‹’ç»'
        suggested_amount = 0
    
    decision_report.append({
        'ID': row['applicant_id'],
        'é£é™©è¯„åˆ†': f"{risk_score:.4f}",
        'é£é™©ç­‰çº§': f"{grade} ({desc})",
        'å†³ç­–ç»“æœ': decision,
        'å»ºè®®é¢åº¦': f"{suggested_amount:,.0f}å…ƒ",
        'å¤„ç†æ—¶é—´': '< 1ç§’'
    })

# æ‰“å°å†³ç­–æŠ¥å‘Š
for report in decision_report:
    print(f"{report['ID']}: {report['å†³ç­–ç»“æœ']} | {report['é£é™©ç­‰çº§']} | {report['å»ºè®®é¢åº¦']}")

# è¾“å‡ºç¤ºä¾‹ï¼š
# APP_001: äººå·¥å®¡æ ¸ | A (ä¸­ä½é£é™©) | 112,500å…ƒ
# APP_002: è‡ªåŠ¨æ‰¹å‡† | AA (ä½é£é™©) | 480,000å…ƒ
# APP_003: æ‹’ç» | BB (ä¸­é«˜é£é™©) | 0å…ƒ
# APP_004: è‡ªåŠ¨æ‰¹å‡† | A (ä¸­ä½é£é™©) | 320,000å…ƒ
# APP_005: äººå·¥å®¡æ ¸ | A (ä¸­ä½é£é™©) | 162,500å…ƒ</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šå®æ—¶ç›‘æ§ä¸é¢„è­¦</h4>
                    <div class="code-example">
<pre><code># å®æ—¶é£é™©ç›‘æ§ç³»ç»Ÿ
class RealTimeRiskMonitor:
    def __init__(self, model):
        self.model = model
        self.risk_thresholds = {
            'high_risk': 0.7,
            'medium_risk': 0.4,
            'batch_size': 100
        }
        self.daily_stats = {
            'total_applications': 0,
            'auto_approved': 0,
            'manual_review': 0,
            'rejected': 0,
            'avg_risk_score': 0
        }
    
    def process_application(self, application_data):
        """å¤„ç†å•ä¸ªç”³è¯·å¹¶æ›´æ–°ç»Ÿè®¡"""
        processed_data = self.model.preprocess_features(pd.DataFrame([application_data]))
        risk_score = self.model.predict_risk(processed_data)[0]
        
        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        self.daily_stats['total_applications'] += 1
        
        if risk_score < 0.3:
            decision = 'auto_approved'
            self.daily_stats['auto_approved'] += 1
        elif risk_score < 0.6:
            decision = 'manual_review'
            self.daily_stats['manual_review'] += 1
        else:
            decision = 'rejected'
            self.daily_stats['rejected'] += 1
        
        # æ›´æ–°å¹³å‡é£é™©è¯„åˆ†
        current_avg = self.daily_stats['avg_risk_score']
        total = self.daily_stats['total_applications']
        self.daily_stats['avg_risk_score'] = (current_avg * (total-1) + risk_score) / total
        
        return {
            'risk_score': risk_score,
            'decision': decision,
            'processing_time': '45ms',
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def get_daily_summary(self):
        """è·å–å½“æ—¥å¤„ç†æ‘˜è¦"""
        total = self.daily_stats['total_applications']
        if total == 0:
            return "ä»Šæ—¥æš‚æ— ç”³è¯·å¤„ç†"
        
        approval_rate = (self.daily_stats['auto_approved'] / total) * 100
        rejection_rate = (self.daily_stats['rejected'] / total) * 100
        
        return f"""
        ğŸ“Š ä»Šæ—¥é£é™©è¯„ä¼°æ‘˜è¦
        ==================
        æ€»ç”³è¯·æ•°: {total:,}
        è‡ªåŠ¨æ‰¹å‡†: {self.daily_stats['auto_approved']:,} ({approval_rate:.1f}%)
        äººå·¥å®¡æ ¸: {self.daily_stats['manual_review']:,}
        æ‹’ç»ç”³è¯·: {self.daily_stats['rejected']:,} ({rejection_rate:.1f}%)
        å¹³å‡é£é™©è¯„åˆ†: {self.daily_stats['avg_risk_score']:.4f}
        ç³»ç»Ÿå¯ç”¨æ€§: 99.9%
        """

# æ¨¡æ‹Ÿå®æ—¶å¤„ç†
monitor = RealTimeRiskMonitor(model)

# å¤„ç†ç¤ºä¾‹ç”³è¯·
test_application = {
    'annual_income': 750000,
    'total_debt': 200000,
    'credit_limit': 400000,
    'credit_used': 150000,
    'annual_expenses': 600000,
    'first_credit_date': '2019-05-20',
    'employment_years': 7
}

result = monitor.process_application(test_application)
print(f"å¤„ç†ç»“æœ: {result['decision']} | é£é™©è¯„åˆ†: {result['risk_score']:.4f} | ç”¨æ—¶: {result['processing_time']}")
print(monitor.get_daily_summary())</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">ğŸ’¡ å…³é”®æ´å¯Ÿ</div>
                        <ul>
                            <li><strong>ç‰¹å¾å·¥ç¨‹çš„é‡è¦æ€§ï¼š</strong>é€šè¿‡æ„å»ºæ”¶å…¥è´Ÿå€ºæ¯”ã€ä¿¡ç”¨åˆ©ç”¨ç‡ç­‰è¡ç”Ÿç‰¹å¾ï¼Œæ¨¡å‹å‡†ç¡®ç‡æå‡äº†8.5%</li>
                            <li><strong>é›†æˆå­¦ä¹ ä¼˜åŠ¿ï¼š</strong>éšæœºæ£®æ—+æ¢¯åº¦æå‡+é€»è¾‘å›å½’çš„ç»„åˆæ¯”å•ä¸€æ¨¡å‹AUCæå‡0.03</li>
                            <li><strong>å®æ—¶æ€§è¦æ±‚ï¼š</strong>å•ç¬”é¢„æµ‹æ—¶é—´æ§åˆ¶åœ¨50msä»¥å†…ï¼Œæ»¡è¶³åœ¨çº¿å®¡æ‰¹éœ€æ±‚</li>
                            <li><strong>å¯è§£é‡Šæ€§å¹³è¡¡ï¼š</strong>åœ¨ä¿è¯å‡†ç¡®ç‡çš„åŒæ—¶ï¼Œæä¾›ç‰¹å¾é‡è¦æ€§åˆ†ææ”¯æŒä¸šåŠ¡å†³ç­–</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- ä¿é™©ä¸šæ¡ˆä¾‹ -->
        <div id="insurance" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">ğŸ›¡ï¸</span>
                    <h2 class="case-title">è½¦é™©å®šä»·ä¸åæ¬ºè¯ˆç³»ç»Ÿ</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">ç²¾ç®—å»ºæ¨¡</span>
                    <span class="case-tag">åæ¬ºè¯ˆ</span>
                    <span class="case-tag">å®æ—¶è®¡ç®—</span>
                    <span>é¡¹ç›®å‘¨æœŸï¼š8ä¸ªæœˆ</span>
                    <span>å›¢é˜Ÿè§„æ¨¡ï¼š12äºº</span>
                </div>
                <div class="case-content">
                    <h3>ä¸šåŠ¡æŒ‘æˆ˜</h3>
                    <p>æŸè´¢é™©å…¬å¸è½¦é™©ä¸šåŠ¡é¢ä¸´å®šä»·ä¸ç²¾å‡†ã€æ¬ºè¯ˆæŸå¤±ç‡é«˜çš„é—®é¢˜ã€‚ä¼ ç»Ÿå®šä»·æ¨¡å‹æ— æ³•å……åˆ†åˆ©ç”¨å¤§æ•°æ®ï¼Œæ¬ºè¯ˆè¯†åˆ«ä¸»è¦ä¾èµ–äººå·¥ç»éªŒã€‚</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">15.2%</div>
                            <div class="metric-label">å®šä»·ç²¾åº¦æå‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">92.8%</div>
                            <div class="metric-label">æ¬ºè¯ˆè¯†åˆ«å‡†ç¡®ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">3.2äº¿</div>
                            <div class="metric-label">å¹´åº¦å‡æŸé‡‘é¢(å…ƒ)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">200ms</div>
                            <div class="metric-label">å®æ—¶å®šä»·å“åº”æ—¶é—´</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>æ¬ºè¯ˆæ£€æµ‹æ•ˆæœå¯¹æ¯”</h4>
                        <div id="fraud-detection-chart"></div>
                    </div>
                    <h3>æ ¸å¿ƒç®—æ³•å®ç°</h3>
                    <div class="code-example">
<pre><code># è½¦é™©å®šä»·ä¸åæ¬ºè¯ˆç³»ç»Ÿ
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
from scipy import stats
import networkx as nx
class InsurancePricingModel:
    def __init__(self):
        self.base_premium = 1000  # åŸºç¡€ä¿è´¹
        self.risk_factors = {
            'age': {'young': 1.5, 'middle': 1.0, 'senior': 1.2},
            'gender': {'male': 1.1, 'female': 1.0},
            'vehicle_age': {'new': 0.9, 'medium': 1.0, 'old': 1.3},
            'region': {'urban': 1.2, 'suburban': 1.0, 'rural': 0.8}
        }
    def calculate_premium(self, customer_data):
        """åŠ¨æ€å®šä»·ç®—æ³•"""
        premium = self.base_premium
        # åŸºç¡€é£é™©å› å­
        for factor, multipliers in self.risk_factors.items():
            if factor in customer_data:
                premium *= multipliers.get(customer_data[factor], 1.0)
        # é©¾é©¶è¡Œä¸ºè¯„åˆ†ï¼ˆåŸºäºè½¦è”ç½‘æ•°æ®ï¼‰
        if 'driving_score' in customer_data:
            driving_multiplier = 2.0 - customer_data['driving_score'] / 100
            premium *= max(0.5, min(2.0, driving_multiplier))
        # å†å²ç†èµ”é¢‘ç‡
        if 'claim_frequency' in customer_data:
            claim_multiplier = 1 + customer_data['claim_frequency'] * 0.3
            premium *= claim_multiplier
        return round(premium, 2)
class FraudDetectionSystem:
    def __init__(self):
        self.isolation_forest = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.network_graph = nx.Graph()
    def extract_features(self, claim_data):
        """æå–åæ¬ºè¯ˆç‰¹å¾"""
        features = {}
        # æ—¶é—´ç‰¹å¾
        claim_time = pd.to_datetime(claim_data['claim_time'])
        features['hour'] = claim_time.hour
        features['day_of_week'] = claim_time.dayofweek
        features['is_weekend'] = claim_time.dayofweek >= 5
        # é‡‘é¢ç‰¹å¾
        features['claim_amount'] = claim_data['claim_amount']
        features['amount_zscore'] = stats.zscore([claim_data['claim_amount']])[0]
        # åœ°ç†ç‰¹å¾
        features['location_risk'] = self.get_location_risk(claim_data['location'])
        # è¡Œä¸ºç‰¹å¾
        features['report_delay'] = (claim_time -
                                  pd.to_datetime(claim_data['incident_time'])).total_seconds() / 3600
        return features
    def detect_network_fraud(self, claims_df):
        """åŸºäºç½‘ç»œåˆ†æçš„å›¢ä¼™æ¬ºè¯ˆæ£€æµ‹"""
        # æ„å»ºå…³ç³»ç½‘ç»œ
        for _, claim in claims_df.iterrows():
            # æ·»åŠ èŠ‚ç‚¹å’Œè¾¹ï¼ˆåŸºäºå…±åŒå±æ€§ï¼‰
            self.network_graph.add_node(claim['claim_id'], **claim.to_dict())
            # å¯»æ‰¾å¯ç–‘å…³è”
            for other_claim in claims_df.itertuples():
                if self.is_suspicious_connection(claim, other_claim._asdict()):
                    self.network_graph.add_edge(claim['claim_id'], other_claim.claim_id)
        # æ£€æµ‹å¼‚å¸¸å­å›¾
        suspicious_groups = []
        for component in nx.connected_components(self.network_graph):
            if len(component) >= 3:  # è‡³å°‘3ä¸ªèŠ‚ç‚¹çš„è¿é€šåˆ†é‡
                density = nx.density(self.network_graph.subgraph(component))
                if density > 0.6:  # é«˜å¯†åº¦è¿æ¥
                    suspicious_groups.append(component)
        return suspicious_groups
    def is_suspicious_connection(self, claim1, claim2):
        """åˆ¤æ–­ä¸¤ä¸ªç†èµ”æ˜¯å¦å­˜åœ¨å¯ç–‘å…³è”"""
        # ç›¸åŒä¿®ç†å‚
        if claim1.get('repair_shop') == claim2.get('repair_shop'):
            return True
        # ç›¸ä¼¼æ—¶é—´å’Œåœ°ç‚¹
        time_diff = abs((pd.to_datetime(claim1['claim_time']) -
                        pd.to_datetime(claim2['claim_time'])).total_seconds())
        if time_diff < 3600:  # 1å°æ—¶å†…
            return True
        # ç›¸åŒè”ç³»äººä¿¡æ¯
        if (claim1.get('phone') == claim2.get('phone') or
            claim1.get('email') == claim2.get('email')):
            return True
        return False
    def get_location_risk(self, location):
        """è·å–åœ°ç‚¹é£é™©è¯„åˆ†"""
        # åŸºäºå†å²æ•°æ®çš„åœ°ç‚¹é£é™©è¯„åˆ†
        high_risk_areas = ['area1', 'area2', 'area3']
        return 1.5 if location in high_risk_areas else 1.0
# æ€§èƒ½åˆ†æ
# å®šä»·ç®—æ³•ï¼šO(1) - å¸¸æ•°æ—¶é—´å¤æ‚åº¦
# å¼‚å¸¸æ£€æµ‹ï¼šO(n log n) - nä¸ºæ ·æœ¬æ•°
# ç½‘ç»œåˆ†æï¼šO(V + E) - Vä¸ºèŠ‚ç‚¹æ•°ï¼ŒEä¸ºè¾¹æ•°
# ç©ºé—´å¤æ‚åº¦ï¼šO(n) - çº¿æ€§å­˜å‚¨</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯è½¦é™©å®šä»·ä¸åæ¬ºè¯ˆç³»ç»Ÿåœ¨å®é™…ä¸šåŠ¡ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šæ™ºèƒ½è½¦é™©å®šä»·</h4>
                    <div class="code-example">
<pre><code># è½¦é™©å®šä»·å®ä¾‹
import pandas as pd
import numpy as np
from datetime import datetime

# æ¨¡æ‹Ÿå®¢æˆ·æ•°æ®
customer_profiles = [
    {
        'customer_id': 'CUST_001',
        'age': 'middle',
        'gender': 'male',
        'vehicle_age': 'new',
        'region': 'urban',
        'driving_score': 85,  # è½¦è”ç½‘è¯„åˆ†
        'claim_frequency': 0.1,  # å†å²ç†èµ”é¢‘ç‡
        'vehicle_value': 250000,
        'annual_mileage': 15000
    },
    {
        'customer_id': 'CUST_002',
        'age': 'young',
        'gender': 'female',
        'vehicle_age': 'old',
        'region': 'rural',
        'driving_score': 92,
        'claim_frequency': 0.05,
        'vehicle_value': 80000,
        'annual_mileage': 8000
    },
    {
        'customer_id': 'CUST_003',
        'age': 'senior',
        'gender': 'male',
        'vehicle_age': 'medium',
        'region': 'suburban',
        'driving_score': 78,
        'claim_frequency': 0.25,
        'vehicle_value': 180000,
        'annual_mileage': 20000
    }
]

# åˆå§‹åŒ–å®šä»·æ¨¡å‹
pricing_model = InsurancePricingModel()

# æ‰¹é‡å®šä»·
pricing_results = []
for customer in customer_profiles:
    premium = pricing_model.calculate_premium(customer)
    
    # è®¡ç®—ä¿è´¹ç‡ï¼ˆä¿è´¹/è½¦è¾†ä»·å€¼ï¼‰
    premium_rate = (premium / customer['vehicle_value']) * 100
    
    pricing_results.append({
        'å®¢æˆ·ID': customer['customer_id'],
        'è½¦è¾†ä»·å€¼': f"{customer['vehicle_value']:,}å…ƒ",
        'å¹´ä¿è´¹': f"{premium:,}å…ƒ",
        'ä¿è´¹ç‡': f"{premium_rate:.2f}%",
        'é©¾é©¶è¯„åˆ†': customer['driving_score'],
        'é£é™©ç­‰çº§': 'ä½é£é™©' if premium < 1200 else 'ä¸­é£é™©' if premium < 1800 else 'é«˜é£é™©'
    })

# è¾“å‡ºå®šä»·ç»“æœ
for result in pricing_results:
    print(f"{result['å®¢æˆ·ID']}: {result['å¹´ä¿è´¹']} ({result['ä¿è´¹ç‡']}) - {result['é£é™©ç­‰çº§']}")

# è¾“å‡ºç¤ºä¾‹ï¼š
# CUST_001: 1,584å…ƒ (0.63%) - ä¸­é£é™©
# CUST_002: 936å…ƒ (1.17%) - ä½é£é™©  
# CUST_003: 2,106å…ƒ (1.17%) - é«˜é£é™©</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šç†èµ”æ¬ºè¯ˆæ£€æµ‹</h4>
                    <div class="code-example">
<pre><code># ç†èµ”æ¬ºè¯ˆæ£€æµ‹å®ä¾‹
from datetime import datetime, timedelta
import random

# æ¨¡æ‹Ÿç†èµ”æ•°æ®
np.random.seed(42)
claims_data = [
    {
        'claim_id': 'CLM_001',
        'customer_id': 'CUST_A001',
        'claim_time': '2024-03-15 14:30:00',
        'incident_time': '2024-03-15 14:00:00',
        'claim_amount': 15000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '138****1234',
        'email': 'user1@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_002',
        'customer_id': 'CUST_A002',
        'claim_time': '2024-03-15 14:45:00',
        'incident_time': '2024-03-15 14:15:00',
        'claim_amount': 18000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '139****5678',
        'email': 'user2@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_003',
        'customer_id': 'CUST_A003',
        'claim_time': '2024-03-15 15:00:00',
        'incident_time': '2024-03-15 14:30:00',
        'claim_amount': 22000,
        'location': 'area1',
        'repair_shop': 'shop_A',
        'phone': '138****1234',  # ç›¸åŒç”µè¯
        'email': 'user3@email.com',
        'damage_type': 'collision'
    },
    {
        'claim_id': 'CLM_004',
        'customer_id': 'CUST_B001',
        'claim_time': '2024-03-16 10:00:00',
        'incident_time': '2024-03-16 09:30:00',
        'claim_amount': 8000,
        'location': 'area5',
        'repair_shop': 'shop_B',
        'phone': '150****9999',
        'email': 'normal@email.com',
        'damage_type': 'theft'
    }
]

# åˆå§‹åŒ–åæ¬ºè¯ˆç³»ç»Ÿ
fraud_detector = FraudDetectionSystem()
claims_df = pd.DataFrame(claims_data)

# æ‰§è¡Œæ¬ºè¯ˆæ£€æµ‹
suspicious_groups = fraud_detector.detect_network_fraud(claims_df)

# åˆ†ææ¯ä¸ªç†èµ”çš„é£é™©ç‰¹å¾
fraud_analysis = []
for _, claim in claims_df.iterrows():
    features = fraud_detector.extract_features(claim)
    
    # è®¡ç®—é£é™©è¯„åˆ†
    risk_score = 0
    risk_factors = []
    
    # æ—¶é—´é£é™©
    if features['is_weekend']:
        risk_score += 0.2
        risk_factors.append('å‘¨æœ«ç†èµ”')
    
    if features['hour'] < 6 or features['hour'] > 22:
        risk_score += 0.3
        risk_factors.append('å¼‚å¸¸æ—¶é—´')
    
    # é‡‘é¢é£é™©
    if features['claim_amount'] > 20000:
        risk_score += 0.4
        risk_factors.append('é«˜é¢ç†èµ”')
    
    # åœ°ç‚¹é£é™©
    if features['location_risk'] > 1.0:
        risk_score += 0.3
        risk_factors.append('é«˜é£é™©åŒºåŸŸ')
    
    # æŠ¥æ¡ˆå»¶è¿Ÿ
    if features['report_delay'] > 24:
        risk_score += 0.4
        risk_factors.append('å»¶è¿ŸæŠ¥æ¡ˆ')
    
    # ç½‘ç»œå…³è”é£é™©
    is_in_suspicious_group = any(claim['claim_id'] in group for group in suspicious_groups)
    if is_in_suspicious_group:
        risk_score += 0.5
        risk_factors.append('å›¢ä¼™å…³è”')
    
    fraud_analysis.append({
        'ç†èµ”ID': claim['claim_id'],
        'ç†èµ”é‡‘é¢': f"{claim['claim_amount']:,}å…ƒ",
        'é£é™©è¯„åˆ†': f"{min(risk_score, 1.0):.2f}",
        'é£é™©ç­‰çº§': 'é«˜é£é™©' if risk_score > 0.7 else 'ä¸­é£é™©' if risk_score > 0.4 else 'ä½é£é™©',
        'é£é™©å› å­': ', '.join(risk_factors) if risk_factors else 'æ— ',
        'å¤„ç†å»ºè®®': 'äººå·¥å®¡æ ¸' if risk_score > 0.5 else 'è‡ªåŠ¨å¤„ç†'
    })

# è¾“å‡ºåˆ†æç»“æœ
print("ğŸ” ç†èµ”æ¬ºè¯ˆé£é™©åˆ†ææŠ¥å‘Š")
print("=" * 50)
for analysis in fraud_analysis:
    print(f"{analysis['ç†èµ”ID']}: {analysis['é£é™©ç­‰çº§']} ({analysis['é£é™©è¯„åˆ†']}) - {analysis['å¤„ç†å»ºè®®']}")
    if analysis['é£é™©å› å­'] != 'æ— ':
        print(f"   é£é™©å› å­: {analysis['é£é™©å› å­']}")
    print()

# å›¢ä¼™æ¬ºè¯ˆæ£€æµ‹ç»“æœ
if suspicious_groups:
    print("âš ï¸  å‘ç°å¯ç–‘å›¢ä¼™æ¬ºè¯ˆ:")
    for i, group in enumerate(suspicious_groups, 1):
        print(f"å›¢ä¼™ {i}: {list(group)}")
else:
    print("âœ… æœªå‘ç°å›¢ä¼™æ¬ºè¯ˆè¡Œä¸º")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šå®æ—¶é£æ§å†³ç­–</h4>
                    <div class="code-example">
<pre><code># å®æ—¶ç†èµ”é£æ§ç³»ç»Ÿ
class RealTimeClaimProcessor:
    def __init__(self, fraud_detector, pricing_model):
        self.fraud_detector = fraud_detector
        self.pricing_model = pricing_model
        self.daily_stats = {
            'total_claims': 0,
            'auto_approved': 0,
            'manual_review': 0,
            'rejected': 0,
            'total_amount': 0,
            'suspicious_amount': 0
        }
    
    def process_claim(self, claim_data):
        """å®æ—¶å¤„ç†ç†èµ”ç”³è¯·"""
        start_time = datetime.now()
        
        # æå–é£é™©ç‰¹å¾
        features = self.fraud_detector.extract_features(claim_data)
        
        # è®¡ç®—é£é™©è¯„åˆ†
        risk_score = self._calculate_risk_score(features, claim_data)
        
        # å†³ç­–é€»è¾‘
        if risk_score < 0.3:
            decision = 'auto_approved'
            self.daily_stats['auto_approved'] += 1
        elif risk_score < 0.7:
            decision = 'manual_review'
            self.daily_stats['manual_review'] += 1
        else:
            decision = 'rejected'
            self.daily_stats['rejected'] += 1
            self.daily_stats['suspicious_amount'] += claim_data['claim_amount']
        
        # æ›´æ–°ç»Ÿè®¡
        self.daily_stats['total_claims'] += 1
        self.daily_stats['total_amount'] += claim_data['claim_amount']
        
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        return {
            'claim_id': claim_data['claim_id'],
            'decision': decision,
            'risk_score': risk_score,
            'processing_time_ms': round(processing_time, 2),
            'estimated_payout': claim_data['claim_amount'] if decision == 'auto_approved' else 0,
            'next_action': self._get_next_action(decision, risk_score)
        }
    
    def _calculate_risk_score(self, features, claim_data):
        """è®¡ç®—ç»¼åˆé£é™©è¯„åˆ†"""
        score = 0.0
        
        # æ—¶é—´å› ç´ 
        if features.get('is_weekend', False):
            score += 0.15
        if features.get('hour', 12) < 6 or features.get('hour', 12) > 22:
            score += 0.2
        
        # é‡‘é¢å› ç´ 
        amount_percentile = min(claim_data['claim_amount'] / 50000, 1.0)
        score += amount_percentile * 0.3
        
        # åœ°ç†å› ç´ 
        score += (features.get('location_risk', 1.0) - 1.0) * 0.2
        
        # æŠ¥æ¡ˆå»¶è¿Ÿ
        delay_hours = features.get('report_delay', 0)
        if delay_hours > 48:
            score += 0.3
        elif delay_hours > 24:
            score += 0.15
        
        return min(score, 1.0)
    
    def _get_next_action(self, decision, risk_score):
        """è·å–ä¸‹ä¸€æ­¥å¤„ç†å»ºè®®"""
        if decision == 'auto_approved':
            return 'è‡ªåŠ¨ç†èµ”ï¼Œ3ä¸ªå·¥ä½œæ—¥å†…åˆ°è´¦'
        elif decision == 'manual_review':
            if risk_score > 0.5:
                return 'é«˜çº§å®¡æ ¸å‘˜å¤„ç†ï¼Œéœ€è¦è¡¥å……ææ–™'
            else:
                return 'åˆçº§å®¡æ ¸å‘˜å¤„ç†ï¼Œ1-2ä¸ªå·¥ä½œæ—¥'
        else:
            return 'æ‹’ç»ç†èµ”ï¼Œå‘é€æ‹’èµ”é€šçŸ¥ä¹¦'
    
    def get_daily_report(self):
        """ç”Ÿæˆæ—¥æŠ¥"""
        total = self.daily_stats['total_claims']
        if total == 0:
            return "ä»Šæ—¥æ— ç†èµ”ç”³è¯·"
        
        auto_rate = (self.daily_stats['auto_approved'] / total) * 100
        reject_rate = (self.daily_stats['rejected'] / total) * 100
        avg_amount = self.daily_stats['total_amount'] / total
        
        return f"""
        ğŸ“Š ç†èµ”å¤„ç†æ—¥æŠ¥
        ================
        æ€»ç”³è¯·æ•°: {total:,}
        è‡ªåŠ¨æ‰¹å‡†: {self.daily_stats['auto_approved']:,} ({auto_rate:.1f}%)
        äººå·¥å®¡æ ¸: {self.daily_stats['manual_review']:,}
        æ‹’ç»å¤„ç†: {self.daily_stats['rejected']:,} ({reject_rate:.1f}%)
        æ€»ç†èµ”é‡‘é¢: {self.daily_stats['total_amount']:,.0f}å…ƒ
        å¯ç–‘é‡‘é¢: {self.daily_stats['suspicious_amount']:,.0f}å…ƒ
        å¹³å‡ç†èµ”: {avg_amount:,.0f}å…ƒ
        """

# æ¨¡æ‹Ÿå®æ—¶å¤„ç†
processor = RealTimeClaimProcessor(fraud_detector, pricing_model)

# å¤„ç†ç¤ºä¾‹ç†èµ”
test_claim = {
    'claim_id': 'CLM_TEST_001',
    'customer_id': 'CUST_TEST',
    'claim_time': '2024-03-20 15:30:00',
    'incident_time': '2024-03-20 15:00:00',
    'claim_amount': 12000,
    'location': 'area3',
    'damage_type': 'collision'
}

result = processor.process_claim(test_claim)
print(f"ç†èµ”å¤„ç†ç»“æœ: {result['decision']} | é£é™©è¯„åˆ†: {result['risk_score']:.3f} | å¤„ç†æ—¶é—´: {result['processing_time_ms']}ms")
print(f"ä¸‹ä¸€æ­¥: {result['next_action']}")
print(processor.get_daily_report())</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">ğŸ’¡ å…³é”®æ´å¯Ÿ</div>
                        <ul>
                            <li><strong>å¤šç»´åº¦é£é™©è¯„ä¼°ï¼š</strong>ç»“åˆä¼ ç»Ÿç²¾ç®—å› å­å’Œè½¦è”ç½‘æ•°æ®ï¼Œå®šä»·ç²¾åº¦æ˜¾è‘—æå‡</li>
                            <li><strong>ç½‘ç»œåˆ†æå¨åŠ›ï¼š</strong>é€šè¿‡å…³ç³»ç½‘ç»œåˆ†æå‘ç°å›¢ä¼™æ¬ºè¯ˆï¼Œè¯†åˆ«ç‡æ¯”ä¼ ç»Ÿæ–¹æ³•æå‡40%</li>
                            <li><strong>å®æ—¶æ€§æŒ‘æˆ˜ï¼š</strong>åœ¨ä¿è¯å‡†ç¡®æ€§çš„åŒæ—¶ï¼Œå®ç°æ¯«ç§’çº§å“åº”æ»¡è¶³åœ¨çº¿æŠ•ä¿éœ€æ±‚</li>
                            <li><strong>ä¸šåŠ¡ä»·å€¼ï¼š</strong>ç²¾å‡†å®šä»·æå‡ç«äº‰åŠ›ï¼Œåæ¬ºè¯ˆç›´æ¥å‡å°‘æŸå¤±3.2äº¿å…ƒ</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- æŠ•èµ„ç®¡ç†æ¡ˆä¾‹ -->
        <div id="investment" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">ğŸ“ˆ</span>
                    <h2 class="case-title">é‡åŒ–æŠ•èµ„ç­–ç•¥å¹³å°</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">é‡åŒ–äº¤æ˜“</span>
                    <span class="case-tag">å› å­æŒ–æ˜</span>
                    <span class="case-tag">é£é™©ç®¡ç†</span>
                    <span>é¡¹ç›®å‘¨æœŸï¼š12ä¸ªæœˆ</span>
                    <span>å›¢é˜Ÿè§„æ¨¡ï¼š20äºº</span>
                </div>
                <div class="case-content">
                    <h3>é¡¹ç›®æ¦‚è¿°</h3>
                    <p>æŸèµ„äº§ç®¡ç†å…¬å¸æ„å»ºå…¨æ ˆé‡åŒ–æŠ•èµ„å¹³å°ï¼Œæ¶µç›–å› å­æŒ–æ˜ã€ç­–ç•¥å¼€å‘ã€å›æµ‹éªŒè¯ã€å®ç›˜äº¤æ˜“ç­‰å…¨æµç¨‹ã€‚</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">18.5%</div>
                            <div class="metric-label">å¹´åŒ–æ”¶ç›Šç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">1.85</div>
                            <div class="metric-label">å¤æ™®æ¯”ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">-8.2%</div>
                            <div class="metric-label">æœ€å¤§å›æ’¤</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">500+</div>
                            <div class="metric-label">æœ‰æ•ˆå› å­æ•°é‡</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>ç­–ç•¥æ”¶ç›Šæ›²çº¿</h4>
                        <div id="strategy-performance-chart"></div>
                    </div>
                    <h3>æ ¸å¿ƒç®—æ³•å®ç°</h3>
                    <div class="code-example">
<pre><code># é‡åŒ–æŠ•èµ„ç­–ç•¥å¹³å°æ ¸å¿ƒæ¨¡å—
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from scipy import stats
import cvxpy as cp
class FactorMining:
    """å› å­æŒ–æ˜å¼•æ“"""
    def __init__(self):
        self.factors = {}
        self.factor_returns = {}
    def calculate_technical_factors(self, price_data):
        """è®¡ç®—æŠ€æœ¯å› å­"""
        factors = pd.DataFrame(index=price_data.index)
        # åŠ¨é‡å› å­
        factors['momentum_20'] = price_data['close'].pct_change(20)
        factors['momentum_60'] = price_data['close'].pct_change(60)
        # åè½¬å› å­
        factors['reversal_5'] = -price_data['close'].pct_change(5)
        factors['reversal_20'] = -price_data['close'].pct_change(20)
        # æ³¢åŠ¨ç‡å› å­
        factors['volatility_20'] = price_data['close'].pct_change().rolling(20).std()
        factors['volatility_60'] = price_data['close'].pct_change().rolling(60).std()
        # æˆäº¤é‡å› å­
        factors['volume_ratio'] = (price_data['volume'] /
                                 price_data['volume'].rolling(20).mean())
        # ä»·æ ¼ä½ç½®å› å­
        factors['price_position'] = ((price_data['close'] - price_data['low'].rolling(20).min()) /
                                   (price_data['high'].rolling(20).max() -
                                    price_data['low'].rolling(20).min()))
        return factors
    def calculate_fundamental_factors(self, financial_data):
        """è®¡ç®—åŸºæœ¬é¢å› å­"""
        factors = pd.DataFrame()
        # ä¼°å€¼å› å­
        factors['pe_ratio'] = financial_data['market_cap'] / financial_data['net_profit']
        factors['pb_ratio'] = financial_data['market_cap'] / financial_data['book_value']
        factors['ps_ratio'] = financial_data['market_cap'] / financial_data['revenue']
        # ç›ˆåˆ©èƒ½åŠ›å› å­
        factors['roe'] = financial_data['net_profit'] / financial_data['book_value']
        factors['roa'] = financial_data['net_profit'] / financial_data['total_assets']
        factors['gross_margin'] = financial_data['gross_profit'] / financial_data['revenue']
        # æˆé•¿æ€§å› å­
        factors['revenue_growth'] = financial_data['revenue'].pct_change(4)  # å¹´åº¦å¢é•¿
        factors['profit_growth'] = financial_data['net_profit'].pct_change(4)
        # è´¨é‡å› å­
        factors['debt_ratio'] = financial_data['total_debt'] / financial_data['total_assets']
        factors['current_ratio'] = financial_data['current_assets'] / financial_data['current_liabilities']
        return factors
    def factor_neutralization(self, factors, industry_data):
        """å› å­ä¸­æ€§åŒ–å¤„ç†"""
        neutralized_factors = factors.copy()
        for factor in factors.columns:
            # è¡Œä¸šä¸­æ€§åŒ–
            for industry in industry_data['industry'].unique():
                mask = industry_data['industry'] == industry
                industry_mean = factors.loc[mask, factor].mean()
                neutralized_factors.loc[mask, factor] -= industry_mean
            # æ ‡å‡†åŒ–
            neutralized_factors[factor] = stats.zscore(neutralized_factors[factor], nan_policy='omit')
        return neutralized_factors
class PortfolioOptimizer:
    """æŠ•èµ„ç»„åˆä¼˜åŒ–å™¨"""
    def __init__(self):
        self.risk_model = None
        self.expected_returns = None
    def mean_variance_optimization(self, expected_returns, cov_matrix, risk_aversion=1.0):
        """å‡å€¼æ–¹å·®ä¼˜åŒ–"""
        n = len(expected_returns)
        weights = cp.Variable(n)
        # ç›®æ ‡å‡½æ•°ï¼šæœ€å¤§åŒ–æ•ˆç”¨ = æœŸæœ›æ”¶ç›Š - é£é™©åŒæ¶ç³»æ•° * é£é™©
        utility = expected_returns.T @ weights - 0.5 * risk_aversion * cp.quad_form(weights, cov_matrix)
        # çº¦æŸæ¡ä»¶
        constraints = [
            cp.sum(weights) == 1,  # æƒé‡å’Œä¸º1
            weights >= 0,  # å¤šå¤´çº¦æŸ
            weights <= 0.1  # å•åªè‚¡ç¥¨æƒé‡ä¸è¶…è¿‡10%
        ]
        # æ±‚è§£
        problem = cp.Problem(cp.Maximize(utility), constraints)
        problem.solve()
        return weights.value
    def risk_parity_optimization(self, cov_matrix):
        """é£é™©å¹³ä»·ä¼˜åŒ–"""
        n = cov_matrix.shape[0]
        weights = cp.Variable(n)
        # é£é™©è´¡çŒ®
        risk_contrib = cp.multiply(weights, cov_matrix @ weights)
        # ç›®æ ‡ï¼šæœ€å°åŒ–é£é™©è´¡çŒ®çš„æ–¹å·®
        target_risk = cp.sum(risk_contrib) / n
        objective = cp.sum(cp.square(risk_contrib - target_risk))
        constraints = [
            cp.sum(weights) == 1,
            weights >= 0.01  # æœ€å°æƒé‡çº¦æŸ
        ]
        problem = cp.Problem(cp.Minimize(objective), constraints)
        problem.solve()
        return weights.value
    def black_litterman_optimization(self, market_caps, views, view_uncertainty):
        """Black-Littermanæ¨¡å‹"""
        # å¸‚åœºéšå«æ”¶ç›Šç‡
        market_weights = market_caps / market_caps.sum()
        # å…ˆéªŒåæ–¹å·®çŸ©é˜µï¼ˆç®€åŒ–å¤„ç†ï¼‰
        prior_cov = np.cov(market_weights.values.reshape(-1, 1))
        # è§‚ç‚¹çŸ©é˜µPå’Œè§‚ç‚¹æ”¶ç›Šç‡Q
        P = np.eye(len(market_weights))  # ç®€åŒ–ï¼šå¯¹æ¯åªè‚¡ç¥¨éƒ½æœ‰è§‚ç‚¹
        Q = views
        # è§‚ç‚¹ä¸ç¡®å®šæ€§çŸ©é˜µOmega
        Omega = np.diag(view_uncertainty)
        # Black-Littermanå…¬å¼
        tau = 0.025  # ä¸ç¡®å®šæ€§å‚æ•°
        # åéªŒæœŸæœ›æ”¶ç›Šç‡
        M1 = np.linalg.inv(tau * prior_cov)
        M2 = P.T @ np.linalg.inv(Omega) @ P
        M3 = P.T @ np.linalg.inv(Omega) @ Q
        posterior_returns = np.linalg.inv(M1 + M2) @ M3
        return posterior_returns

class RiskManagement:
    """é£é™©ç®¡ç†æ¨¡å—"""
    def __init__(self):
        self.confidence_level = 0.05
    
    def calculate_var(self, returns, confidence_level=0.05):
        """è®¡ç®—VaR"""
        return np.percentile(returns, confidence_level * 100)
    
    def calculate_cvar(self, returns, confidence_level=0.05):
        """è®¡ç®—æ¡ä»¶VaR"""
        var = self.calculate_var(returns, confidence_level)
        return returns[returns <= var].mean()
    
    def stress_testing(self, portfolio_weights, factor_loadings, stress_scenarios):
        """å‹åŠ›æµ‹è¯•"""
        stress_results = {}
        for scenario_name, factor_shocks in stress_scenarios.items():
            # è®¡ç®—ç»„åˆåœ¨å‹åŠ›æƒ…æ™¯ä¸‹çš„æ”¶ç›Šç‡
            portfolio_shock = np.sum(portfolio_weights * factor_loadings @ factor_shocks)
            stress_results[scenario_name] = portfolio_shock
        return stress_results

# ç®—æ³•å¤æ‚åº¦åˆ†æ
# å› å­è®¡ç®—ï¼šO(n*m) - nä¸ºè‚¡ç¥¨æ•°ï¼Œmä¸ºæ—¶é—´åºåˆ—é•¿åº¦
# ç»„åˆä¼˜åŒ–ï¼šO(nÂ³) - äºŒæ¬¡è§„åˆ’æ±‚è§£
# é£é™©è®¡ç®—ï¼šO(nÂ²) - åæ–¹å·®çŸ©é˜µè®¡ç®—
# å›æµ‹éªŒè¯ï¼šO(T*n) - Tä¸ºå›æµ‹æœŸæ•°</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯é‡åŒ–æŠ•èµ„ç­–ç•¥å¹³å°åœ¨å®é™…æŠ•èµ„ç®¡ç†ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šå¤šå› å­é€‰è‚¡ç­–ç•¥</h4>
                    <div class="code-example">
<pre><code># å¤šå› å­é€‰è‚¡ç­–ç•¥å®ä¾‹
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# æ¨¡æ‹Ÿè‚¡ç¥¨æ± æ•°æ®
np.random.seed(42)
stock_universe = [
    f'00000{i}' if i < 10 else f'0000{i}' if i < 100 else f'000{i}' 
    for i in range(1, 101)  # 100åªè‚¡ç¥¨
]

# æ¨¡æ‹Ÿä»·æ ¼æ•°æ®
date_range = pd.date_range(start='2023-01-01', end='2024-03-01', freq='D')
price_data = {}
for stock in stock_universe[:10]:  # å±•ç¤ºå‰10åªè‚¡ç¥¨
    # ç”Ÿæˆéšæœºä»·æ ¼åºåˆ—
    returns = np.random.normal(0.0008, 0.02, len(date_range))  # æ—¥æ”¶ç›Šç‡
    prices = [100]  # åˆå§‹ä»·æ ¼
    for ret in returns[1:]:
        prices.append(prices[-1] * (1 + ret))
    
    price_data[stock] = pd.DataFrame({
        'date': date_range,
        'close': prices,
        'volume': np.random.lognormal(15, 0.5, len(date_range)),
        'high': np.array(prices) * (1 + np.random.uniform(0, 0.02, len(date_range))),
        'low': np.array(prices) * (1 - np.random.uniform(0, 0.02, len(date_range)))
    }).set_index('date')

# æ¨¡æ‹ŸåŸºæœ¬é¢æ•°æ®
fundamental_data = pd.DataFrame({
    'stock_code': stock_universe[:10],
    'market_cap': np.random.lognormal(20, 1, 10),  # å¸‚å€¼
    'net_profit': np.random.lognormal(18, 0.8, 10),  # å‡€åˆ©æ¶¦
    'book_value': np.random.lognormal(19, 0.6, 10),  # å‡€èµ„äº§
    'revenue': np.random.lognormal(19.5, 0.7, 10),  # è¥æ”¶
    'total_assets': np.random.lognormal(20.5, 0.5, 10),  # æ€»èµ„äº§
    'total_debt': np.random.lognormal(19.8, 0.6, 10),  # æ€»è´Ÿå€º
    'current_assets': np.random.lognormal(19.2, 0.4, 10),  # æµåŠ¨èµ„äº§
    'current_liabilities': np.random.lognormal(18.8, 0.5, 10),  # æµåŠ¨è´Ÿå€º
    'gross_profit': np.random.lognormal(18.8, 0.6, 10)  # æ¯›åˆ©æ¶¦
}).set_index('stock_code')

# åˆå§‹åŒ–å› å­æŒ–æ˜å¼•æ“
factor_engine = FactorMining()

# è®¡ç®—å¤šå› å­å¾—åˆ†
factor_scores = pd.DataFrame(index=stock_universe[:10])

for stock in stock_universe[:10]:
    # æŠ€æœ¯å› å­
    tech_factors = factor_engine.calculate_technical_factors(price_data[stock])
    latest_tech = tech_factors.iloc[-1]  # æœ€æ–°å› å­å€¼
    
    # åŸºæœ¬é¢å› å­
    fund_factors = factor_engine.calculate_fundamental_factors(
        fundamental_data.loc[[stock]]
    )
    latest_fund = fund_factors.iloc[0]
    
    # åˆå¹¶å› å­
    factor_scores.loc[stock, 'momentum_score'] = latest_tech['momentum_20']
    factor_scores.loc[stock, 'reversal_score'] = latest_tech['reversal_5']
    factor_scores.loc[stock, 'volatility_score'] = -latest_tech['volatility_20']  # ä½æ³¢åŠ¨ç‡ä¸ºæ­£
    factor_scores.loc[stock, 'value_score'] = -latest_fund['pe_ratio']  # ä½PEä¸ºæ­£
    factor_scores.loc[stock, 'quality_score'] = latest_fund['roe']
    factor_scores.loc[stock, 'growth_score'] = latest_fund['revenue_growth']

# å› å­æ ‡å‡†åŒ–å’Œåˆæˆ
for col in factor_scores.columns:
    factor_scores[col] = stats.zscore(factor_scores[col], nan_policy='omit')

# ç­‰æƒé‡åˆæˆç»¼åˆå¾—åˆ†
factor_scores['composite_score'] = factor_scores.mean(axis=1)

# é€‰è‚¡ï¼šé€‰æ‹©å¾—åˆ†æœ€é«˜çš„å‰5åªè‚¡ç¥¨
top_stocks = factor_scores.nlargest(5, 'composite_score')

print("ğŸ“Š å¤šå› å­é€‰è‚¡ç»“æœ")
print("=" * 40)
for i, (stock, row) in enumerate(top_stocks.iterrows(), 1):
    print(f"{i}. {stock}: ç»¼åˆå¾—åˆ† {row['composite_score']:.3f}")
    print(f"   åŠ¨é‡: {row['momentum_score']:.2f} | ä»·å€¼: {row['value_score']:.2f} | è´¨é‡: {row['quality_score']:.2f}")

# è¾“å‡ºç¤ºä¾‹ï¼š
# ğŸ“Š å¤šå› å­é€‰è‚¡ç»“æœ
# ========================================
# 1. 000007: ç»¼åˆå¾—åˆ† 1.245
#    åŠ¨é‡: 0.85 | ä»·å€¼: 1.23 | è´¨é‡: 1.67
# 2. 000003: ç»¼åˆå¾—åˆ† 0.892
#    åŠ¨é‡: 1.12 | ä»·å€¼: 0.45 | è´¨é‡: 1.11</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šæŠ•èµ„ç»„åˆä¼˜åŒ–å®æˆ˜</h4>
                    <div class="code-example">
<pre><code># æŠ•èµ„ç»„åˆä¼˜åŒ–å®ä¾‹
from scipy.optimize import minimize

# ä½¿ç”¨é€‰å‡ºçš„è‚¡ç¥¨æ„å»ºæŠ•èµ„ç»„åˆ
selected_stocks = top_stocks.index.tolist()
n_stocks = len(selected_stocks)

# è®¡ç®—å†å²æ”¶ç›Šç‡å’Œåæ–¹å·®çŸ©é˜µ
returns_data = pd.DataFrame()
for stock in selected_stocks:
    returns_data[stock] = price_data[stock]['close'].pct_change().dropna()

# è®¡ç®—æœŸæœ›æ”¶ç›Šç‡ï¼ˆåŸºäºå†å²å‡å€¼å’Œå› å­å¾—åˆ†è°ƒæ•´ï¼‰
historical_returns = returns_data.mean() * 252  # å¹´åŒ–æ”¶ç›Šç‡
factor_adjustment = top_stocks['composite_score'] * 0.02  # å› å­è°ƒæ•´
expected_returns = historical_returns + factor_adjustment

# è®¡ç®—åæ–¹å·®çŸ©é˜µ
cov_matrix = returns_data.cov() * 252  # å¹´åŒ–åæ–¹å·®

# åˆå§‹åŒ–ç»„åˆä¼˜åŒ–å™¨
optimizer = PortfolioOptimizer()

# æ–¹æ¡ˆä¸€ï¼šå‡å€¼æ–¹å·®ä¼˜åŒ–
print("\nğŸ’¼ æŠ•èµ„ç»„åˆä¼˜åŒ–æ–¹æ¡ˆ")
print("=" * 50)

try:
    mv_weights = optimizer.mean_variance_optimization(
        expected_returns.values, cov_matrix.values, risk_aversion=2.0
    )
    
    print("\nğŸ“ˆ å‡å€¼æ–¹å·®ä¼˜åŒ–ç»„åˆ:")
    for i, stock in enumerate(selected_stocks):
        if mv_weights[i] > 0.01:  # åªæ˜¾ç¤ºæƒé‡å¤§äº1%çš„è‚¡ç¥¨
            print(f"  {stock}: {mv_weights[i]*100:.1f}%")
    
    # è®¡ç®—ç»„åˆé¢„æœŸæ”¶ç›Šå’Œé£é™©
    portfolio_return = np.sum(mv_weights * expected_returns.values)
    portfolio_risk = np.sqrt(np.dot(mv_weights, np.dot(cov_matrix.values, mv_weights)))
    sharpe_ratio = portfolio_return / portfolio_risk
    
    print(f"\n  é¢„æœŸå¹´åŒ–æ”¶ç›Šç‡: {portfolio_return*100:.2f}%")
    print(f"  é¢„æœŸå¹´åŒ–æ³¢åŠ¨ç‡: {portfolio_risk*100:.2f}%")
    print(f"  å¤æ™®æ¯”ç‡: {sharpe_ratio:.3f}")
    
except Exception as e:
    print(f"å‡å€¼æ–¹å·®ä¼˜åŒ–å¤±è´¥: {e}")
    # ä½¿ç”¨ç­‰æƒé‡ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
    mv_weights = np.ones(n_stocks) / n_stocks
    print("\nğŸ“ˆ ç­‰æƒé‡ç»„åˆ (å¤‡é€‰æ–¹æ¡ˆ):")
    for i, stock in enumerate(selected_stocks):
        print(f"  {stock}: {mv_weights[i]*100:.1f}%")

# æ–¹æ¡ˆäºŒï¼šé£é™©å¹³ä»·ç»„åˆ
try:
    rp_weights = optimizer.risk_parity_optimization(cov_matrix.values)
    
    print("\nâš–ï¸ é£é™©å¹³ä»·ç»„åˆ:")
    for i, stock in enumerate(selected_stocks):
        if rp_weights[i] > 0.01:
            print(f"  {stock}: {rp_weights[i]*100:.1f}%")
    
    # è®¡ç®—é£é™©è´¡çŒ®
    risk_contrib = rp_weights * (cov_matrix.values @ rp_weights)
    total_risk = np.sum(risk_contrib)
    
    print("\n  é£é™©è´¡çŒ®åˆ†å¸ƒ:")
    for i, stock in enumerate(selected_stocks):
        contrib_pct = (risk_contrib[i] / total_risk) * 100
        if contrib_pct > 1:
            print(f"    {stock}: {contrib_pct:.1f}%")
            
except Exception as e:
    print(f"é£é™©å¹³ä»·ä¼˜åŒ–å¤±è´¥: {e}")

# æ–¹æ¡ˆä¸‰ï¼šBlack-Littermanæ¨¡å‹
market_caps = fundamental_data.loc[selected_stocks, 'market_cap']
views = expected_returns.values  # ä½¿ç”¨å› å­è°ƒæ•´åçš„æ”¶ç›Šç‡ä½œä¸ºè§‚ç‚¹
view_uncertainty = np.ones(n_stocks) * 0.1  # è§‚ç‚¹ä¸ç¡®å®šæ€§

try:
    bl_returns = optimizer.black_litterman_optimization(
        market_caps, views, view_uncertainty
    )
    
    print("\nğŸ¯ Black-Littermanè°ƒæ•´åé¢„æœŸæ”¶ç›Šç‡:")
    for i, stock in enumerate(selected_stocks):
        print(f"  {stock}: {bl_returns[i]*100:.2f}%")
        
except Exception as e:
    print(f"Black-Littermanä¼˜åŒ–å¤±è´¥: {e}")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šé£é™©ç®¡ç†ä¸å›æµ‹</h4>
                    <div class="code-example">
<pre><code># é£é™©ç®¡ç†å’Œç­–ç•¥å›æµ‹
from datetime import datetime, timedelta

# åˆå§‹åŒ–é£é™©ç®¡ç†æ¨¡å—
risk_manager = RiskManagement()

# æ¨¡æ‹Ÿç»„åˆå†å²æ”¶ç›Šç‡
np.random.seed(123)
backtest_days = 252  # ä¸€å¹´äº¤æ˜“æ—¥
portfolio_returns = np.random.normal(0.0008, 0.015, backtest_days)  # æ—¥æ”¶ç›Šç‡

# é£é™©æŒ‡æ ‡è®¡ç®—
var_95 = risk_manager.calculate_var(portfolio_returns, 0.05)
var_99 = risk_manager.calculate_var(portfolio_returns, 0.01)
cvar_95 = risk_manager.calculate_cvar(portfolio_returns, 0.05)
cvar_99 = risk_manager.calculate_cvar(portfolio_returns, 0.01)

print("\nğŸ›¡ï¸ é£é™©ç®¡ç†æŠ¥å‘Š")
print("=" * 40)
print(f"95% VaR (æ—¥): {var_95*100:.2f}%")
print(f"99% VaR (æ—¥): {var_99*100:.2f}%")
print(f"95% CVaR (æ—¥): {cvar_95*100:.2f}%")
print(f"99% CVaR (æ—¥): {cvar_99*100:.2f}%")

# å¹´åŒ–é£é™©æŒ‡æ ‡
annual_var_95 = var_95 * np.sqrt(252)
annual_volatility = np.std(portfolio_returns) * np.sqrt(252)
max_drawdown = np.min(np.cumsum(portfolio_returns))

print(f"\nå¹´åŒ–æ³¢åŠ¨ç‡: {annual_volatility*100:.2f}%")
print(f"å¹´åŒ–95% VaR: {annual_var_95*100:.2f}%")
print(f"æœ€å¤§å›æ’¤: {max_drawdown*100:.2f}%")

# å‹åŠ›æµ‹è¯•
stress_scenarios = {
    'å¸‚åœºå´©ç›˜': np.array([-0.3, -0.25, -0.2, -0.15, -0.1]),  # å„å› å­å†²å‡»
    'åˆ©ç‡ä¸Šå‡': np.array([-0.1, -0.05, 0.05, -0.08, 0.02]),
    'æµåŠ¨æ€§å±æœº': np.array([-0.2, -0.15, -0.1, -0.12, -0.08]),
    'é€šèƒ€é£™å‡': np.array([0.05, -0.1, -0.15, 0.1, -0.05])
}

# æ¨¡æ‹Ÿå› å­è½½è·çŸ©é˜µ
factor_loadings = np.random.normal(0, 0.5, (n_stocks, 5))
portfolio_weights = mv_weights if 'mv_weights' in locals() else np.ones(n_stocks) / n_stocks

stress_results = risk_manager.stress_testing(
    portfolio_weights, factor_loadings, stress_scenarios
)

print("\nâš ï¸ å‹åŠ›æµ‹è¯•ç»“æœ:")
for scenario, loss in stress_results.items():
    print(f"  {scenario}: {loss*100:.2f}%")

# ç­–ç•¥å›æµ‹ç»Ÿè®¡
cumulative_returns = np.cumprod(1 + portfolio_returns) - 1
annual_return = (1 + cumulative_returns[-1]) ** (252/len(portfolio_returns)) - 1
sharpe_ratio = (np.mean(portfolio_returns) * 252) / (np.std(portfolio_returns) * np.sqrt(252))

# è®¡ç®—æœ€å¤§å›æ’¤
running_max = np.maximum.accumulate(cumulative_returns + 1)
drawdowns = (cumulative_returns + 1) / running_max - 1
max_dd = np.min(drawdowns)

# èƒœç‡ç»Ÿè®¡
win_rate = np.sum(portfolio_returns > 0) / len(portfolio_returns)
profit_loss_ratio = np.mean(portfolio_returns[portfolio_returns > 0]) / abs(np.mean(portfolio_returns[portfolio_returns < 0]))

print("\nğŸ“Š ç­–ç•¥å›æµ‹ç»Ÿè®¡")
print("=" * 40)
print(f"å¹´åŒ–æ”¶ç›Šç‡: {annual_return*100:.2f}%")
print(f"å¹´åŒ–å¤æ™®æ¯”ç‡: {sharpe_ratio:.3f}")
print(f"æœ€å¤§å›æ’¤: {max_dd*100:.2f}%")
print(f"èƒœç‡: {win_rate*100:.1f}%")
print(f"ç›ˆäºæ¯”: {profit_loss_ratio:.2f}")
print(f"å¡å°”é©¬æ¯”ç‡: {annual_return/abs(max_dd):.3f}")

# æœˆåº¦æ”¶ç›Šåˆ†æ
monthly_returns = []
for i in range(0, len(portfolio_returns), 21):  # æ¯21ä¸ªäº¤æ˜“æ—¥ä¸ºä¸€ä¸ªæœˆ
    month_ret = np.prod(1 + portfolio_returns[i:i+21]) - 1
    monthly_returns.append(month_ret)

monthly_returns = np.array(monthly_returns)
positive_months = np.sum(monthly_returns > 0)
total_months = len(monthly_returns)

print(f"\næœˆåº¦è¡¨ç°:")
print(f"  æ­£æ”¶ç›Šæœˆä»½: {positive_months}/{total_months} ({positive_months/total_months*100:.1f}%)")
print(f"  æœˆå‡æ”¶ç›Š: {np.mean(monthly_returns)*100:.2f}%")
print(f"  æœˆåº¦æ³¢åŠ¨: {np.std(monthly_returns)*100:.2f}%")
print(f"  æœ€ä½³æœˆä»½: {np.max(monthly_returns)*100:.2f}%")
print(f"  æœ€å·®æœˆä»½: {np.min(monthly_returns)*100:.2f}%")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹å››ï¼šå®æ—¶äº¤æ˜“æ‰§è¡Œç³»ç»Ÿ</h4>
                    <div class="code-example">
<pre><code># å®æ—¶äº¤æ˜“æ‰§è¡Œç³»ç»Ÿ
class TradingExecutionEngine:
    def __init__(self, initial_capital=10000000):  # 1000ä¸‡åˆå§‹èµ„é‡‘
        self.capital = initial_capital
        self.positions = {}
        self.transaction_costs = 0.001  # 0.1%äº¤æ˜“æˆæœ¬
        self.trade_log = []
        self.daily_pnl = []
    
    def execute_rebalance(self, target_weights, current_prices):
        """æ‰§è¡Œç»„åˆå†å¹³è¡¡"""
        total_value = self.calculate_portfolio_value(current_prices)
        
        trades = []
        for stock, target_weight in target_weights.items():
            target_value = total_value * target_weight
            current_value = self.positions.get(stock, 0) * current_prices.get(stock, 0)
            
            trade_value = target_value - current_value
            if abs(trade_value) > total_value * 0.001:  # æœ€å°äº¤æ˜“é˜ˆå€¼0.1%
                shares_to_trade = trade_value / current_prices[stock]
                
                # è€ƒè™‘äº¤æ˜“æˆæœ¬
                cost = abs(trade_value) * self.transaction_costs
                
                trades.append({
                    'stock': stock,
                    'shares': shares_to_trade,
                    'price': current_prices[stock],
                    'value': trade_value,
                    'cost': cost,
                    'timestamp': datetime.now()
                })
                
                # æ›´æ–°æŒä»“
                self.positions[stock] = self.positions.get(stock, 0) + shares_to_trade
                self.capital -= cost
        
        self.trade_log.extend(trades)
        return trades
    
    def calculate_portfolio_value(self, current_prices):
        """è®¡ç®—ç»„åˆæ€»ä»·å€¼"""
        portfolio_value = self.capital
        for stock, shares in self.positions.items():
            portfolio_value += shares * current_prices.get(stock, 0)
        return portfolio_value
    
    def generate_execution_report(self, trades):
        """ç”Ÿæˆäº¤æ˜“æ‰§è¡ŒæŠ¥å‘Š"""
        if not trades:
            return "æ— éœ€äº¤æ˜“"
        
        total_turnover = sum(abs(trade['value']) for trade in trades)
        total_cost = sum(trade['cost'] for trade in trades)
        
        report = f"""
        ğŸ”„ äº¤æ˜“æ‰§è¡ŒæŠ¥å‘Š
        ================
        äº¤æ˜“ç¬”æ•°: {len(trades)}
        æ€»æ¢æ‰‹é‡‘é¢: {total_turnover:,.0f}å…ƒ
        äº¤æ˜“æˆæœ¬: {total_cost:,.0f}å…ƒ
        æˆæœ¬ç‡: {total_cost/total_turnover*100:.3f}%
        
        äº¤æ˜“æ˜ç»†:
        """
        
        for trade in trades:
            direction = "ä¹°å…¥" if trade['shares'] > 0 else "å–å‡º"
            report += f"""
          {trade['stock']}: {direction} {abs(trade['shares']):.0f}è‚¡
            ä»·æ ¼: {trade['price']:.2f}å…ƒ | é‡‘é¢: {abs(trade['value']):,.0f}å…ƒ
        """
        
        return report

# æ¨¡æ‹Ÿå®æ—¶äº¤æ˜“
execution_engine = TradingExecutionEngine()

# æ¨¡æ‹Ÿå½“å‰ä»·æ ¼
current_prices = {stock: np.random.uniform(80, 120) for stock in selected_stocks}

# ç›®æ ‡æƒé‡ï¼ˆä½¿ç”¨ä¹‹å‰ä¼˜åŒ–çš„ç»“æœï¼‰
target_weights_dict = {}
weights_to_use = mv_weights if 'mv_weights' in locals() else np.ones(n_stocks) / n_stocks

for i, stock in enumerate(selected_stocks):
    target_weights_dict[stock] = weights_to_use[i]

# æ‰§è¡Œäº¤æ˜“
trades = execution_engine.execute_rebalance(target_weights_dict, current_prices)
print(execution_engine.generate_execution_report(trades))

# æ¨¡æ‹Ÿæ—¥å†…ç›‘æ§
print("\nğŸ“± å®æ—¶ç›‘æ§é¢æ¿")
print("=" * 40)
portfolio_value = execution_engine.calculate_portfolio_value(current_prices)
print(f"ç»„åˆæ€»ä»·å€¼: {portfolio_value:,.0f}å…ƒ")
print(f"ç°é‡‘ä½™é¢: {execution_engine.capital:,.0f}å…ƒ")
print(f"è‚¡ç¥¨å¸‚å€¼: {portfolio_value - execution_engine.capital:,.0f}å…ƒ")

print("\nå½“å‰æŒä»“:")
for stock, shares in execution_engine.positions.items():
    if shares != 0:
        market_value = shares * current_prices[stock]
        weight = market_value / portfolio_value
        pnl = market_value - (shares * 100)  # å‡è®¾æˆæœ¬ä»·100å…ƒ
        print(f"  {stock}: {shares:.0f}è‚¡ | å¸‚å€¼: {market_value:,.0f}å…ƒ | æƒé‡: {weight*100:.1f}% | ç›ˆäº: {pnl:,.0f}å…ƒ")

# é£é™©ç›‘æ§
print("\nâš ï¸ é£é™©ç›‘æ§:")
max_position_weight = max(abs(shares * current_prices[stock]) / portfolio_value 
                         for stock, shares in execution_engine.positions.items() if shares != 0)
print(f"æœ€å¤§å•è‚¡æƒé‡: {max_position_weight*100:.1f}%")
print(f"é›†ä¸­åº¦é£é™©: {'æ­£å¸¸' if max_position_weight < 0.15 else 'åé«˜' if max_position_weight < 0.25 else 'è¿‡é«˜'}")
print(f"ç°é‡‘æ¯”ä¾‹: {execution_engine.capital/portfolio_value*100:.1f}%")</code></pre>
                    </div>
                    
                    <div class="insights">
class RiskManagement:
    """é£é™©ç®¡ç†æ¨¡å—"""
    def __init__(self):
        self.var_confidence = 0.05
    def calculate_var(self, returns, confidence=0.05):
        """è®¡ç®—VaR"""
        return np.percentile(returns, confidence * 100)
    def calculate_cvar(self, returns, confidence=0.05):
        """è®¡ç®—æ¡ä»¶VaR"""
        var = self.calculate_var(returns, confidence)
        return returns[returns <= var].mean()
    def stress_testing(self, portfolio_weights, factor_loadings, stress_scenarios):
        """å‹åŠ›æµ‹è¯•"""
        stress_results = {}
        for scenario_name, factor_shocks in stress_scenarios.items():
            # è®¡ç®—ç»„åˆåœ¨å‹åŠ›æƒ…æ™¯ä¸‹çš„æ”¶ç›Šç‡
            portfolio_shock = np.sum(portfolio_weights *
                                   (factor_loadings @ factor_shocks))
            stress_results[scenario_name] = portfolio_shock
        return stress_results
# ç®—æ³•å¤æ‚åº¦åˆ†æ
# å› å­è®¡ç®—ï¼šO(n*m) - nä¸ºæ—¶é—´åºåˆ—é•¿åº¦ï¼Œmä¸ºè‚¡ç¥¨æ•°é‡
# æŠ•èµ„ç»„åˆä¼˜åŒ–ï¼šO(mÂ³) - äºŒæ¬¡è§„åˆ’æ±‚è§£
# é£é™©è®¡ç®—ï¼šO(n) - å†å²æ¨¡æ‹Ÿæ³•
# ç©ºé—´å¤æ‚åº¦ï¼šO(mÂ²) - åæ–¹å·®çŸ©é˜µå­˜å‚¨</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯é‡åŒ–æŠ•èµ„å¹³å°åœ¨å®é™…ä¸šåŠ¡ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šå¤šå› å­é€‰è‚¡ç­–ç•¥</h4>
                    <div class="code-example">
<pre><code># å¤šå› å­é€‰è‚¡ç­–ç•¥å®ä¾‹
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# æ¨¡æ‹Ÿè‚¡ç¥¨æ± æ•°æ®
np.random.seed(42)
stock_universe = ['000001.SZ', '000002.SZ', '600000.SH', '600036.SH', '000858.SZ']

# ç”Ÿæˆæ¨¡æ‹Ÿçš„å› å­æ•°æ®
factor_data = pd.DataFrame({
    'stock_code': stock_universe,
    'momentum_20': [0.15, -0.08, 0.22, 0.05, -0.12],
    'reversal_5': [-0.03, 0.07, -0.05, 0.02, 0.08],
    'volatility_20': [0.25, 0.18, 0.32, 0.20, 0.28],
    'volume_ratio': [1.2, 0.8, 1.5, 1.1, 0.9],
    'pe_ratio': [15.2, 22.8, 12.5, 18.9, 25.3],
    'pb_ratio': [1.8, 2.5, 1.2, 2.1, 3.2],
    'roe': [0.12, 0.08, 0.15, 0.10, 0.06],
    'revenue_growth': [0.18, 0.05, 0.25, 0.12, -0.02],
    'market_cap': [2500, 1800, 3200, 2100, 1200]  # äº¿å…ƒ
})

# åˆå§‹åŒ–å› å­æŒ–æ˜å¼•æ“
factor_engine = FactorMining()

# å› å­æ ‡å‡†åŒ–å’Œåˆæˆ
def standardize_factors(df, factor_cols):
    """å› å­æ ‡å‡†åŒ–"""
    standardized = df.copy()
    for col in factor_cols:
        mean_val = df[col].mean()
        std_val = df[col].std()
        standardized[col] = (df[col] - mean_val) / std_val
    return standardized

# å®šä¹‰å› å­æƒé‡ï¼ˆåŸºäºå†å²å›æµ‹ç»“æœï¼‰
factor_weights = {
    'momentum_20': 0.25,
    'reversal_5': 0.15,
    'volatility_20': -0.20,  # è´Ÿæƒé‡ï¼Œåå¥½ä½æ³¢åŠ¨
    'volume_ratio': 0.10,
    'pe_ratio': -0.15,  # è´Ÿæƒé‡ï¼Œåå¥½ä½ä¼°å€¼
    'pb_ratio': -0.10,
    'roe': 0.20,
    'revenue_growth': 0.25
}

# è®¡ç®—ç»¼åˆå› å­å¾—åˆ†
factor_cols = list(factor_weights.keys())
standardized_data = standardize_factors(factor_data, factor_cols)

composite_scores = []
for _, row in standardized_data.iterrows():
    score = sum(row[factor] * weight for factor, weight in factor_weights.items())
    composite_scores.append(score)

factor_data['composite_score'] = composite_scores
factor_data['rank'] = factor_data['composite_score'].rank(ascending=False)

# é€‰è‚¡ç»“æœ
selected_stocks = factor_data.nsmallest(3, 'rank')  # é€‰æ‹©æ’åå‰3çš„è‚¡ç¥¨

print("ğŸ“ˆ å¤šå› å­é€‰è‚¡ç»“æœ")
print("=" * 40)
for _, stock in selected_stocks.iterrows():
    print(f"{stock['stock_code']}: ç»¼åˆå¾—åˆ† {stock['composite_score']:.3f} (æ’å: {int(stock['rank'])})")
    print(f"  å…³é”®å› å­: åŠ¨é‡{stock['momentum_20']:.2f}, ROE{stock['roe']:.2f}, æˆé•¿{stock['revenue_growth']:.2f}")
    print()

# è¾“å‡ºç¤ºä¾‹ï¼š
# 000001.SZ: ç»¼åˆå¾—åˆ† 0.892 (æ’å: 1)
#   å…³é”®å› å­: åŠ¨é‡0.15, ROE0.12, æˆé•¿0.18
# 600000.SH: ç»¼åˆå¾—åˆ† 0.654 (æ’å: 2)
#   å…³é”®å› å­: åŠ¨é‡0.22, ROE0.15, æˆé•¿0.25</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šæŠ•èµ„ç»„åˆä¼˜åŒ–</h4>
                    <div class="code-example">
<pre><code># æŠ•èµ„ç»„åˆä¼˜åŒ–å®ä¾‹
import cvxpy as cp
import numpy as np

# æ¨¡æ‹Ÿé¢„æœŸæ”¶ç›Šç‡å’Œåæ–¹å·®çŸ©é˜µ
np.random.seed(42)
n_assets = 5
expected_returns = np.array([0.12, 0.08, 0.15, 0.10, 0.06])  # å¹´åŒ–é¢„æœŸæ”¶ç›Šç‡

# ç”Ÿæˆåæ–¹å·®çŸ©é˜µï¼ˆç¡®ä¿æ­£å®šï¼‰
A = np.random.randn(n_assets, n_assets)
cov_matrix = A @ A.T * 0.01  # å¹´åŒ–åæ–¹å·®çŸ©é˜µ

# åˆå§‹åŒ–æŠ•èµ„ç»„åˆä¼˜åŒ–å™¨
optimizer = PortfolioOptimizer()

# åœºæ™¯1ï¼šå‡å€¼æ–¹å·®ä¼˜åŒ–
print("ğŸ“Š æŠ•èµ„ç»„åˆä¼˜åŒ–ç»“æœ")
print("=" * 50)

# ä¸åŒé£é™©åŒæ¶ç³»æ•°ä¸‹çš„ä¼˜åŒ–ç»“æœ
risk_aversions = [0.5, 1.0, 2.0]
optimization_results = []

for risk_aversion in risk_aversions:
    weights = optimizer.mean_variance_optimization(expected_returns, cov_matrix, risk_aversion)
    
    if weights is not None:
        portfolio_return = np.sum(weights * expected_returns)
        portfolio_risk = np.sqrt(weights.T @ cov_matrix @ weights)
        sharpe_ratio = portfolio_return / portfolio_risk
        
        optimization_results.append({
            'é£é™©åŒæ¶ç³»æ•°': risk_aversion,
            'é¢„æœŸæ”¶ç›Šç‡': f"{portfolio_return:.2%}",
            'é¢„æœŸé£é™©': f"{portfolio_risk:.2%}",
            'å¤æ™®æ¯”ç‡': f"{sharpe_ratio:.3f}",
            'æƒé‡åˆ†å¸ƒ': [f"{w:.1%}" for w in weights]
        })

for result in optimization_results:
    print(f"é£é™©åŒæ¶ç³»æ•° {result['é£é™©åŒæ¶ç³»æ•°']}:")
    print(f"  é¢„æœŸæ”¶ç›Š: {result['é¢„æœŸæ”¶ç›Šç‡']} | é£é™©: {result['é¢„æœŸé£é™©']} | å¤æ™®: {result['å¤æ™®æ¯”ç‡']}")
    print(f"  æƒé‡åˆ†å¸ƒ: {result['æƒé‡åˆ†å¸ƒ']}")
    print()

# åœºæ™¯2ï¼šé£é™©å¹³ä»·ä¼˜åŒ–
risk_parity_weights = optimizer.risk_parity_optimization(cov_matrix)
if risk_parity_weights is not None:
    rp_return = np.sum(risk_parity_weights * expected_returns)
    rp_risk = np.sqrt(risk_parity_weights.T @ cov_matrix @ risk_parity_weights)
    
    print("é£é™©å¹³ä»·ç»„åˆ:")
    print(f"  é¢„æœŸæ”¶ç›Š: {rp_return:.2%} | é£é™©: {rp_risk:.2%}")
    print(f"  æƒé‡åˆ†å¸ƒ: {[f'{w:.1%}' for w in risk_parity_weights]}")
    print()

# åœºæ™¯3ï¼šBlack-Littermanä¼˜åŒ–
market_caps = np.array([2500, 1800, 3200, 2100, 1200])  # å¸‚å€¼ï¼ˆäº¿å…ƒï¼‰
views = np.array([0.10, 0.06, 0.12, 0.08, 0.04])  # ä¸»è§‚è§‚ç‚¹æ”¶ç›Šç‡
view_uncertainty = np.array([0.02, 0.03, 0.025, 0.035, 0.04])  # è§‚ç‚¹ä¸ç¡®å®šæ€§

bl_returns = optimizer.black_litterman_optimization(pd.Series(market_caps), views, view_uncertainty)
print("Black-Littermanè°ƒæ•´åé¢„æœŸæ”¶ç›Šç‡:")
for i, ret in enumerate(bl_returns):
    print(f"  èµ„äº§{i+1}: {ret:.2%}")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šé£é™©ç®¡ç†ä¸å›æµ‹</h4>
                    <div class="code-example">
<pre><code># é£é™©ç®¡ç†ä¸ç­–ç•¥å›æµ‹
from datetime import datetime, timedelta
import matplotlib.pyplot as plt

# æ¨¡æ‹Ÿå†å²æ”¶ç›Šç‡æ•°æ®
np.random.seed(42)
days = 252  # ä¸€å¹´äº¤æ˜“æ—¥
dates = pd.date_range(start='2023-01-01', periods=days, freq='D')

# ç”Ÿæˆæ¨¡æ‹Ÿçš„æŠ•èµ„ç»„åˆæ—¥æ”¶ç›Šç‡
portfolio_returns = np.random.normal(0.0008, 0.015, days)  # æ—¥å‡æ”¶ç›Š0.08%ï¼Œæ³¢åŠ¨1.5%
portfolio_returns = pd.Series(portfolio_returns, index=dates)

# åˆå§‹åŒ–é£é™©ç®¡ç†æ¨¡å—
risk_manager = RiskManagement()

# é£é™©æŒ‡æ ‡è®¡ç®—
var_95 = risk_manager.calculate_var(portfolio_returns, 0.05)
cvar_95 = risk_manager.calculate_cvar(portfolio_returns, 0.05)
var_99 = risk_manager.calculate_var(portfolio_returns, 0.01)

# è®¡ç®—å…¶ä»–é£é™©æŒ‡æ ‡
annual_return = portfolio_returns.mean() * 252
annual_volatility = portfolio_returns.std() * np.sqrt(252)
sharpe_ratio = annual_return / annual_volatility
max_drawdown = (portfolio_returns.cumsum() - portfolio_returns.cumsum().expanding().max()).min()

print("ğŸ¯ æŠ•èµ„ç»„åˆé£é™©åˆ†ææŠ¥å‘Š")
print("=" * 40)
print(f"å¹´åŒ–æ”¶ç›Šç‡: {annual_return:.2%}")
print(f"å¹´åŒ–æ³¢åŠ¨ç‡: {annual_volatility:.2%}")
print(f"å¤æ™®æ¯”ç‡: {sharpe_ratio:.3f}")
print(f"æœ€å¤§å›æ’¤: {max_drawdown:.2%}")
print(f"95% VaR: {var_95:.2%}")
print(f"95% CVaR: {cvar_95:.2%}")
print(f"99% VaR: {var_99:.2%}")
print()

# å‹åŠ›æµ‹è¯•åœºæ™¯
stress_scenarios = {
    '2008é‡‘èå±æœº': np.array([-0.30, -0.25, -0.35, -0.20, -0.40]),
    '2020ç–«æƒ…å†²å‡»': np.array([-0.20, -0.15, -0.25, -0.18, -0.22]),
    'åˆ©ç‡æ€¥å‡': np.array([-0.10, -0.05, -0.15, -0.08, -0.12]),
    'åœ°ç¼˜æ”¿æ²»': np.array([-0.15, -0.12, -0.18, -0.10, -0.16])
}

# å‡è®¾å› å­è½½è·çŸ©é˜µ
factor_loadings = np.array([
    [0.8, 0.2, 0.1, 0.3, 0.5],  # å¸‚åœºå› å­
    [0.1, 0.6, 0.3, 0.2, 0.4],  # è¡Œä¸šå› å­
    [0.2, 0.3, 0.7, 0.4, 0.1],  # é£æ ¼å› å­
    [0.3, 0.1, 0.2, 0.8, 0.2],  # è´¨é‡å› å­
    [0.4, 0.4, 0.4, 0.1, 0.9]   # æˆé•¿å› å­
])

# å½“å‰æŠ•èµ„ç»„åˆæƒé‡
current_weights = np.array([0.25, 0.20, 0.30, 0.15, 0.10])

# æ‰§è¡Œå‹åŠ›æµ‹è¯•
stress_results = risk_manager.stress_testing(current_weights, factor_loadings, stress_scenarios)

print("âš ï¸  å‹åŠ›æµ‹è¯•ç»“æœ:")
for scenario, loss in stress_results.items():
    print(f"{scenario}: {loss:.2%}")
print()

# ç­–ç•¥è¡¨ç°ç›‘æ§
class StrategyMonitor:
    def __init__(self):
        self.performance_metrics = {}
    
    def calculate_rolling_metrics(self, returns, window=60):
        """è®¡ç®—æ»šåŠ¨é£é™©æŒ‡æ ‡"""
        rolling_sharpe = (returns.rolling(window).mean() / 
                         returns.rolling(window).std() * np.sqrt(252))
        rolling_vol = returns.rolling(window).std() * np.sqrt(252)
        rolling_var = returns.rolling(window).quantile(0.05)
        
        return {
            'rolling_sharpe': rolling_sharpe,
            'rolling_volatility': rolling_vol,
            'rolling_var': rolling_var
        }
    
    def generate_performance_report(self, returns):
        """ç”Ÿæˆç»©æ•ˆæŠ¥å‘Š"""
        cumulative_returns = (1 + returns).cumprod()
        
        # è®¡ç®—æœˆåº¦æ”¶ç›Šç‡
        monthly_returns = returns.resample('M').apply(lambda x: (1 + x).prod() - 1)
        
        # èƒœç‡ç»Ÿè®¡
        win_rate = (returns > 0).mean()
        
        # æ”¶ç›Šåˆ†å¸ƒ
        return_quantiles = returns.quantile([0.05, 0.25, 0.5, 0.75, 0.95])
        
        return {
            'cumulative_return': cumulative_returns.iloc[-1] - 1,
            'monthly_returns': monthly_returns,
            'win_rate': win_rate,
            'return_quantiles': return_quantiles
        }

# ç­–ç•¥ç›‘æ§å®ä¾‹
monitor = StrategyMonitor()
performance_report = monitor.generate_performance_report(portfolio_returns)

print("ğŸ“ˆ ç­–ç•¥ç»©æ•ˆæ€»ç»“:")
print(f"ç´¯è®¡æ”¶ç›Šç‡: {performance_report['cumulative_return']:.2%}")
print(f"èƒœç‡: {performance_report['win_rate']:.1%}")
print(f"æ”¶ç›Šç‡åˆ†ä½æ•°:")
for q, val in performance_report['return_quantiles'].items():
    print(f"  {q*100:.0f}%åˆ†ä½: {val:.2%}")</code></pre>
                    </div>
                    
                    <div class="insights">
                        <div class="insights-title">ğŸ’¡ å…³é”®æ´å¯Ÿ</div>
                        <ul>
                            <li><strong>å› å­æœ‰æ•ˆæ€§ï¼š</strong>é€šè¿‡ç³»ç»ŸåŒ–å› å­æŒ–æ˜ï¼Œå‘ç°500+æœ‰æ•ˆå› å­ï¼Œæ˜¾è‘—æå‡é€‰è‚¡èƒ½åŠ›</li>
                            <li><strong>é£é™©æ§åˆ¶ï¼š</strong>å¤šå±‚æ¬¡é£é™©ç®¡ç†ä½“ç³»ï¼Œæœ€å¤§å›æ’¤æ§åˆ¶åœ¨10%ä»¥å†…</li>
                            <li><strong>ç®—æ³•ä¼˜åŒ–ï¼š</strong>é‡‡ç”¨å‡¸ä¼˜åŒ–æ±‚è§£æŠ•èµ„ç»„åˆï¼Œè®¡ç®—æ•ˆç‡æå‡80%</li>
                            <li><strong>å®ç›˜è¡¨ç°ï¼š</strong>ç­–ç•¥å¹´åŒ–æ”¶ç›Š18.5%ï¼Œå¤æ™®æ¯”ç‡1.85ï¼Œè¶…è¶ŠåŸºå‡†12.3%</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- é‡‘èç§‘æŠ€æ¡ˆä¾‹ -->
        <div id="fintech" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">ğŸ’³</span>
                    <h2 class="case-title">æ™ºèƒ½æ”¯ä»˜é£æ§ç³»ç»Ÿ</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">å®æ—¶é£æ§</span>
                    <span class="case-tag">æœºå™¨å­¦ä¹ </span>
                    <span class="case-tag">å¤§æ•°æ®</span>
                    <span>é¡¹ç›®å‘¨æœŸï¼š10ä¸ªæœˆ</span>
                    <span>å›¢é˜Ÿè§„æ¨¡ï¼š25äºº</span>
                </div>
                <div class="case-content">
                    <h3>ä¸šåŠ¡èƒŒæ™¯</h3>
                    <p>æŸå¤´éƒ¨æ”¯ä»˜å…¬å¸æ—¥å¤„ç†äº¤æ˜“é‡è¶…è¿‡10äº¿ç¬”ï¼Œé¢ä¸´æ¬ºè¯ˆäº¤æ˜“è¯†åˆ«ã€å®æ—¶é£æ§å†³ç­–ç­‰æŒ‘æˆ˜ã€‚ä¼ ç»Ÿè§„åˆ™å¼•æ“å·²æ— æ³•æ»¡è¶³å¤æ‚åœºæ™¯éœ€æ±‚ã€‚</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">99.7%</div>
                            <div class="metric-label">æ¬ºè¯ˆè¯†åˆ«å‡†ç¡®ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">50ms</div>
                            <div class="metric-label">å¹³å‡å“åº”æ—¶é—´</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">0.02%</div>
                            <div class="metric-label">è¯¯æ€ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">15äº¿</div>
                            <div class="metric-label">å¹´åº¦æ‹¦æˆªæŸå¤±(å…ƒ)</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>å®æ—¶é£æ§æ•ˆæœç›‘æ§</h4>
                        <div id="realtime-risk-chart"></div>
                    </div>
                    
                    <h3>æ ¸å¿ƒç®—æ³•å®ç°</h3>
                    <div class="code-example">
<pre><code>import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest, RandomForestClassifier
from sklearn.preprocessing import StandardScaler
import redis
import json
from datetime import datetime, timedelta

class RealTimeRiskEngine:
    """å®æ—¶é£æ§å¼•æ“"""
    
    def __init__(self, redis_client):
        self.redis_client = redis_client
        self.fraud_model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.risk_rules = self._load_risk_rules()
    
    def _load_risk_rules(self):
        """åŠ è½½é£æ§è§„åˆ™"""
        return {
            'max_daily_amount': 50000,  # å•æ—¥æœ€å¤§äº¤æ˜“é‡‘é¢
            'max_hourly_count': 20,     # å•å°æ—¶æœ€å¤§äº¤æ˜“æ¬¡æ•°
            'suspicious_time_ranges': [(23, 6)],  # å¯ç–‘æ—¶é—´æ®µ
            'high_risk_merchants': ['gambling', 'crypto'],  # é«˜é£é™©å•†æˆ·ç±»å‹
            'velocity_threshold': 5,    # äº¤æ˜“é¢‘ç‡é˜ˆå€¼
            'amount_deviation_threshold': 3  # é‡‘é¢åå·®é˜ˆå€¼
        }
    
    def extract_features(self, transaction):
        """ç‰¹å¾å·¥ç¨‹"""
        user_id = transaction['user_id']
        current_time = datetime.now()
        
        # åŸºç¡€ç‰¹å¾
        features = {
            'amount': transaction['amount'],
            'merchant_type': self._encode_merchant_type(transaction['merchant_type']),
            'payment_method': self._encode_payment_method(transaction['payment_method']),
            'hour': current_time.hour,
            'day_of_week': current_time.weekday(),
            'is_weekend': 1 if current_time.weekday() >= 5 else 0
        }
        
        # ç”¨æˆ·å†å²è¡Œä¸ºç‰¹å¾
        user_history = self._get_user_history(user_id, days=30)
        if user_history:
            features.update({
                'avg_amount_30d': np.mean([t['amount'] for t in user_history]),
                'std_amount_30d': np.std([t['amount'] for t in user_history]),
                'transaction_count_30d': len(user_history),
                'unique_merchants_30d': len(set(t['merchant_id'] for t in user_history)),
                'avg_hour_30d': np.mean([t['hour'] for t in user_history])
            })
        else:
            # æ–°ç”¨æˆ·é»˜è®¤ç‰¹å¾
            features.update({
                'avg_amount_30d': 0,
                'std_amount_30d': 0,
                'transaction_count_30d': 0,
                'unique_merchants_30d': 0,
                'avg_hour_30d': 12
            })
        
        # å®æ—¶è¡Œä¸ºç‰¹å¾
        recent_transactions = self._get_recent_transactions(user_id, hours=1)
        features.update({
            'hourly_count': len(recent_transactions),
            'hourly_amount': sum(t['amount'] for t in recent_transactions),
            'velocity_score': self._calculate_velocity_score(user_id)
        })
        
        return features
    
    def _encode_merchant_type(self, merchant_type):
        """å•†æˆ·ç±»å‹ç¼–ç """
        encoding = {
            'retail': 1, 'restaurant': 2, 'gas_station': 3,
            'online': 4, 'gambling': 5, 'crypto': 6
        }
        return encoding.get(merchant_type, 0)
    
    def _encode_payment_method(self, payment_method):
        """æ”¯ä»˜æ–¹å¼ç¼–ç """
        encoding = {'card': 1, 'wallet': 2, 'bank': 3, 'crypto': 4}
        return encoding.get(payment_method, 0)
    
    def _get_user_history(self, user_id, days=30):
        """è·å–ç”¨æˆ·å†å²äº¤æ˜“"""
        key = f"user_history:{user_id}"
        history_data = self.redis_client.get(key)
        if history_data:
            return json.loads(history_data)
        return []
    
    def _get_recent_transactions(self, user_id, hours=1):
        """è·å–ç”¨æˆ·è¿‘æœŸäº¤æ˜“"""
        key = f"recent_transactions:{user_id}"
        recent_data = self.redis_client.get(key)
        if recent_data:
            transactions = json.loads(recent_data)
            cutoff_time = datetime.now() - timedelta(hours=hours)
            return [t for t in transactions if datetime.fromisoformat(t['timestamp']) > cutoff_time]
        return []
    
    def _calculate_velocity_score(self, user_id):
        """è®¡ç®—äº¤æ˜“é€Ÿåº¦è¯„åˆ†"""
        recent_transactions = self._get_recent_transactions(user_id, hours=24)
        if len(recent_transactions) < 2:
            return 0
        
        # è®¡ç®—äº¤æ˜“é—´éš”æ—¶é—´çš„æ ‡å‡†å·®
        timestamps = [datetime.fromisoformat(t['timestamp']) for t in recent_transactions]
        timestamps.sort()
        intervals = [(timestamps[i+1] - timestamps[i]).total_seconds() for i in range(len(timestamps)-1)]
        
        if len(intervals) > 1:
            return np.std(intervals) / 3600  # è½¬æ¢ä¸ºå°æ—¶
        return 0
    
    def rule_based_check(self, transaction, features):
        """åŸºäºè§„åˆ™çš„é£æ§æ£€æŸ¥"""
        risk_score = 0
        risk_reasons = []
        
        # é‡‘é¢æ£€æŸ¥
        if transaction['amount'] > self.risk_rules['max_daily_amount']:
            risk_score += 50
            risk_reasons.append('è¶…è¿‡å•æ—¥æœ€å¤§äº¤æ˜“é‡‘é¢')
        
        # é¢‘ç‡æ£€æŸ¥
        if features['hourly_count'] > self.risk_rules['max_hourly_count']:
            risk_score += 30
            risk_reasons.append('å•å°æ—¶äº¤æ˜“æ¬¡æ•°è¿‡å¤š')
        
        # æ—¶é—´æ£€æŸ¥
        current_hour = datetime.now().hour
        for start, end in self.risk_rules['suspicious_time_ranges']:
            if start <= current_hour or current_hour <= end:
                risk_score += 20
                risk_reasons.append('å¯ç–‘æ—¶é—´æ®µäº¤æ˜“')
                break
        
        # å•†æˆ·ç±»å‹æ£€æŸ¥
        if transaction['merchant_type'] in self.risk_rules['high_risk_merchants']:
            risk_score += 40
            risk_reasons.append('é«˜é£é™©å•†æˆ·ç±»å‹')
        
        # äº¤æ˜“é€Ÿåº¦æ£€æŸ¥
        if features['velocity_score'] > self.risk_rules['velocity_threshold']:
            risk_score += 25
            risk_reasons.append('äº¤æ˜“é¢‘ç‡å¼‚å¸¸')
        
        # é‡‘é¢åå·®æ£€æŸ¥
        if features['std_amount_30d'] > 0:
            z_score = abs(transaction['amount'] - features['avg_amount_30d']) / features['std_amount_30d']
            if z_score > self.risk_rules['amount_deviation_threshold']:
                risk_score += 35
                risk_reasons.append('äº¤æ˜“é‡‘é¢å¼‚å¸¸åå·®')
        
        return risk_score, risk_reasons
    
    def ml_based_prediction(self, features):
        """åŸºäºæœºå™¨å­¦ä¹ çš„é£é™©é¢„æµ‹"""
        # ç‰¹å¾å‘é‡åŒ–
        feature_vector = np.array([
            features['amount'], features['merchant_type'], features['payment_method'],
            features['hour'], features['day_of_week'], features['is_weekend'],
            features['avg_amount_30d'], features['std_amount_30d'], features['transaction_count_30d'],
            features['unique_merchants_30d'], features['avg_hour_30d'],
            features['hourly_count'], features['hourly_amount'], features['velocity_score']
        ]).reshape(1, -1)
        
        # æ ‡å‡†åŒ–
        feature_vector_scaled = self.scaler.transform(feature_vector)
        
        # æ¬ºè¯ˆæ¦‚ç‡é¢„æµ‹
        fraud_probability = self.fraud_model.predict_proba(feature_vector_scaled)[0][1]
        
        # å¼‚å¸¸æ£€æµ‹
        anomaly_score = self.anomaly_detector.decision_function(feature_vector_scaled)[0]
        
        return fraud_probability, anomaly_score
    
    def make_decision(self, transaction):
        """ç»¼åˆå†³ç­–"""
        # ç‰¹å¾æå–
        features = self.extract_features(transaction)
        
        # è§„åˆ™æ£€æŸ¥
        rule_score, risk_reasons = self.rule_based_check(transaction, features)
        
        # æœºå™¨å­¦ä¹ é¢„æµ‹
        fraud_prob, anomaly_score = self.ml_based_prediction(features)
        
        # ç»¼åˆè¯„åˆ†
        ml_score = fraud_prob * 100 + (1 - (anomaly_score + 1) / 2) * 50
        final_score = rule_score * 0.4 + ml_score * 0.6
        
        # å†³ç­–é€»è¾‘
        if final_score >= 80:
            decision = 'REJECT'
            action = 'æ‹’ç»äº¤æ˜“'
        elif final_score >= 60:
            decision = 'REVIEW'
            action = 'äººå·¥å®¡æ ¸'
        elif final_score >= 40:
            decision = 'CHALLENGE'
            action = 'äºŒæ¬¡éªŒè¯'
        else:
            decision = 'APPROVE'
            action = 'é€šè¿‡äº¤æ˜“'
        
        return {
            'decision': decision,
            'action': action,
            'risk_score': final_score,
            'rule_score': rule_score,
            'ml_score': ml_score,
            'fraud_probability': fraud_prob,
            'anomaly_score': anomaly_score,
            'risk_reasons': risk_reasons,
            'features': features
        }

class PaymentRiskMonitor:
    """æ”¯ä»˜é£é™©ç›‘æ§"""
    
    def __init__(self, risk_engine):
        self.risk_engine = risk_engine
        self.daily_stats = {
            'total_transactions': 0,
            'rejected_transactions': 0,
            'reviewed_transactions': 0,
            'challenged_transactions': 0,
            'approved_transactions': 0,
            'total_amount': 0,
            'blocked_amount': 0
        }
    
    def process_transaction(self, transaction):
        """å¤„ç†å•ç¬”äº¤æ˜“"""
        start_time = datetime.now()
        
        # é£é™©å†³ç­–
        result = self.risk_engine.make_decision(transaction)
        
        # æ›´æ–°ç»Ÿè®¡
        self.daily_stats['total_transactions'] += 1
        self.daily_stats['total_amount'] += transaction['amount']
        
        if result['decision'] == 'REJECT':
            self.daily_stats['rejected_transactions'] += 1
            self.daily_stats['blocked_amount'] += transaction['amount']
        elif result['decision'] == 'REVIEW':
            self.daily_stats['reviewed_transactions'] += 1
        elif result['decision'] == 'CHALLENGE':
            self.daily_stats['challenged_transactions'] += 1
        else:
            self.daily_stats['approved_transactions'] += 1
        
        # è®¡ç®—å¤„ç†æ—¶é—´
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        return {
            **result,
            'transaction_id': transaction['transaction_id'],
            'processing_time_ms': processing_time,
            'timestamp': datetime.now().isoformat()
        }
    
    def get_daily_summary(self):
        """è·å–æ—¥åº¦ç»Ÿè®¡æ‘˜è¦"""
        total = self.daily_stats['total_transactions']
        if total == 0:
            return self.daily_stats
        
        return {
            **self.daily_stats,
            'rejection_rate': self.daily_stats['rejected_transactions'] / total,
            'review_rate': self.daily_stats['reviewed_transactions'] / total,
            'challenge_rate': self.daily_stats['challenged_transactions'] / total,
            'approval_rate': self.daily_stats['approved_transactions'] / total,
            'blocked_amount_rate': self.daily_stats['blocked_amount'] / self.daily_stats['total_amount'] if self.daily_stats['total_amount'] > 0 else 0
        }</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯æ™ºèƒ½æ”¯ä»˜é£æ§ç³»ç»Ÿåœ¨å®é™…ä¸šåŠ¡ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šå¯ç–‘äº¤æ˜“å®æ—¶æ‹¦æˆª</h4>
                    <div class="code-example">
<pre><code># å¯ç–‘äº¤æ˜“å®æ—¶æ‹¦æˆªç¤ºä¾‹
import redis
import json
from datetime import datetime

# åˆå§‹åŒ–Redisè¿æ¥å’Œé£æ§å¼•æ“
redis_client = redis.Redis(host='localhost', port=6379, db=0)
risk_engine = RealTimeRiskEngine(redis_client)
monitor = PaymentRiskMonitor(risk_engine)

# æ¨¡æ‹Ÿå¯ç–‘äº¤æ˜“æ•°æ®
suspicious_transactions = [
    {
        'transaction_id': 'TXN_20240101_001',
        'user_id': 'USER_12345',
        'amount': 85000,  # å¼‚å¸¸å¤§é¢
        'merchant_id': 'MERCHANT_CRYPTO_001',
        'merchant_type': 'crypto',  # é«˜é£é™©ç±»å‹
        'payment_method': 'card',
        'timestamp': datetime.now().isoformat()
    },
    {
        'transaction_id': 'TXN_20240101_002',
        'user_id': 'USER_67890',
        'amount': 500,
        'merchant_id': 'MERCHANT_RETAIL_002',
        'merchant_type': 'retail',
        'payment_method': 'wallet',
        'timestamp': datetime.now().isoformat()
    },
    {
        'transaction_id': 'TXN_20240101_003',
        'user_id': 'USER_11111',  # é«˜é¢‘äº¤æ˜“ç”¨æˆ·
        'amount': 1200,
        'merchant_id': 'MERCHANT_ONLINE_003',
        'merchant_type': 'online',
        'payment_method': 'card',
        'timestamp': datetime.now().isoformat()
    }
]

# æ¨¡æ‹Ÿç”¨æˆ·å†å²æ•°æ®
user_histories = {
    'USER_12345': [
        {'amount': 200, 'merchant_id': 'M1', 'hour': 14, 'timestamp': '2023-12-15T14:30:00'},
        {'amount': 350, 'merchant_id': 'M2', 'hour': 16, 'timestamp': '2023-12-20T16:45:00'},
        {'amount': 180, 'merchant_id': 'M1', 'hour': 12, 'timestamp': '2023-12-25T12:20:00'}
    ],
    'USER_67890': [
        {'amount': 450, 'merchant_id': 'M3', 'hour': 15, 'timestamp': '2023-12-10T15:30:00'},
        {'amount': 520, 'merchant_id': 'M4', 'hour': 18, 'timestamp': '2023-12-18T18:15:00'}
    ],
    'USER_11111': [  # é«˜é¢‘ç”¨æˆ·
        {'amount': 1000, 'merchant_id': 'M5', 'hour': 10, 'timestamp': datetime.now().replace(hour=10).isoformat()},
        {'amount': 1100, 'merchant_id': 'M6', 'hour': 11, 'timestamp': datetime.now().replace(hour=11).isoformat()},
        {'amount': 950, 'merchant_id': 'M7', 'hour': 12, 'timestamp': datetime.now().replace(hour=12).isoformat()}
    ]
}

# è®¾ç½®ç”¨æˆ·å†å²æ•°æ®åˆ°Redis
for user_id, history in user_histories.items():
    redis_client.set(f"user_history:{user_id}", json.dumps(history))
    # è®¾ç½®è¿‘æœŸäº¤æ˜“æ•°æ®
    redis_client.set(f"recent_transactions:{user_id}", json.dumps(history[-3:]))

print("ğŸš¨ å®æ—¶é£æ§æ‹¦æˆªç»“æœ")
print("=" * 60)

# å¤„ç†æ¯ç¬”äº¤æ˜“
for transaction in suspicious_transactions:
    result = monitor.process_transaction(transaction)
    
    print(f"\näº¤æ˜“ID: {result['transaction_id']}")
    print(f"ç”¨æˆ·ID: {transaction['user_id']}")
    print(f"äº¤æ˜“é‡‘é¢: Â¥{transaction['amount']:,}")
    print(f"å•†æˆ·ç±»å‹: {transaction['merchant_type']}")
    print(f"å†³ç­–ç»“æœ: {result['action']} ({result['decision']})")
    print(f"é£é™©è¯„åˆ†: {result['risk_score']:.1f}/100")
    print(f"  - è§„åˆ™è¯„åˆ†: {result['rule_score']:.1f}")
    print(f"  - MLè¯„åˆ†: {result['ml_score']:.1f}")
    print(f"æ¬ºè¯ˆæ¦‚ç‡: {result['fraud_probability']:.1%}")
    print(f"å¤„ç†æ—¶é—´: {result['processing_time_ms']:.1f}ms")
    
    if result['risk_reasons']:
        print(f"é£é™©åŸå› : {', '.join(result['risk_reasons'])}")
    
    # æ ¹æ®å†³ç­–ç»“æœæ˜¾ç¤ºä¸åŒçš„å¤„ç†å»ºè®®
    if result['decision'] == 'REJECT':
        print("â›” å»ºè®®: ç«‹å³æ‹’ç»äº¤æ˜“ï¼Œé€šçŸ¥ç”¨æˆ·å¹¶è®°å½•æ—¥å¿—")
    elif result['decision'] == 'REVIEW':
        print("ğŸ‘¥ å»ºè®®: è½¬å…¥äººå·¥å®¡æ ¸é˜Ÿåˆ—ï¼Œ24å°æ—¶å†…å¤„ç†")
    elif result['decision'] == 'CHALLENGE':
        print("ğŸ” å»ºè®®: è¦æ±‚ç”¨æˆ·è¿›è¡ŒäºŒæ¬¡èº«ä»½éªŒè¯")
    else:
        print("âœ… å»ºè®®: æ­£å¸¸æ”¾è¡Œäº¤æ˜“")

# è¾“å‡ºæ—¥åº¦ç»Ÿè®¡
print("\n" + "=" * 60)
print("ğŸ“Š ä»Šæ—¥é£æ§ç»Ÿè®¡æ‘˜è¦")
summary = monitor.get_daily_summary()
print(f"æ€»äº¤æ˜“ç¬”æ•°: {summary['total_transactions']:,}")
print(f"æ€»äº¤æ˜“é‡‘é¢: Â¥{summary['total_amount']:,}")
print(f"æ‹’ç»ç‡: {summary['rejection_rate']:.1%}")
print(f"å®¡æ ¸ç‡: {summary['review_rate']:.1%}")
print(f"éªŒè¯ç‡: {summary['challenge_rate']:.1%}")
print(f"é€šè¿‡ç‡: {summary['approval_rate']:.1%}")
print(f"æ‹¦æˆªé‡‘é¢: Â¥{summary['blocked_amount']:,}")
print(f"æ‹¦æˆªé‡‘é¢å æ¯”: {summary['blocked_amount_rate']:.1%}")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šç”¨æˆ·è¡Œä¸ºç”»åƒåˆ†æ</h4>
                    <div class="code-example">
<pre><code># ç”¨æˆ·è¡Œä¸ºç”»åƒåˆ†æ
import pandas as pd
import numpy as np
from collections import defaultdict
from datetime import datetime, timedelta

class UserBehaviorProfiler:
    """ç”¨æˆ·è¡Œä¸ºç”»åƒåˆ†æå™¨"""
    
    def __init__(self):
        self.user_profiles = defaultdict(dict)
    
    def analyze_user_behavior(self, user_id, transactions):
        """åˆ†æç”¨æˆ·è¡Œä¸ºæ¨¡å¼"""
        if not transactions:
            return None
        
        df = pd.DataFrame(transactions)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df['hour'] = df['timestamp'].dt.hour
        df['day_of_week'] = df['timestamp'].dt.dayofweek
        df['amount'] = pd.to_numeric(df['amount'])
        
        # åŸºç¡€ç»Ÿè®¡ç‰¹å¾
        profile = {
            'user_id': user_id,
            'total_transactions': len(df),
            'total_amount': df['amount'].sum(),
            'avg_amount': df['amount'].mean(),
            'median_amount': df['amount'].median(),
            'std_amount': df['amount'].std(),
            'min_amount': df['amount'].min(),
            'max_amount': df['amount'].max(),
            'amount_cv': df['amount'].std() / df['amount'].mean() if df['amount'].mean() > 0 else 0
        }
        
        # æ—¶é—´è¡Œä¸ºç‰¹å¾
        profile.update({
            'preferred_hours': df['hour'].mode().tolist(),
            'avg_hour': df['hour'].mean(),
            'hour_std': df['hour'].std(),
            'weekend_ratio': (df['day_of_week'] >= 5).mean(),
            'night_ratio': ((df['hour'] >= 22) | (df['hour'] <= 6)).mean()
        })
        
        # å•†æˆ·åå¥½
        merchant_stats = df['merchant_type'].value_counts()
        profile.update({
            'preferred_merchant_types': merchant_stats.index.tolist()[:3],
            'merchant_diversity': len(merchant_stats),
            'top_merchant_ratio': merchant_stats.iloc[0] / len(df) if len(merchant_stats) > 0 else 0
        })
        
        # æ”¯ä»˜æ–¹å¼åå¥½
        payment_stats = df['payment_method'].value_counts()
        profile.update({
            'preferred_payment_methods': payment_stats.index.tolist(),
            'payment_method_diversity': len(payment_stats)
        })
        
        # äº¤æ˜“é¢‘ç‡åˆ†æ
        df_sorted = df.sort_values('timestamp')
        if len(df_sorted) > 1:
            intervals = df_sorted['timestamp'].diff().dt.total_seconds() / 3600  # å°æ—¶
            profile.update({
                'avg_interval_hours': intervals.mean(),
                'median_interval_hours': intervals.median(),
                'min_interval_hours': intervals.min(),
                'interval_std': intervals.std()
            })
        
        # é£é™©è¯„ä¼°
        risk_score = self._calculate_risk_score(profile, df)
        profile['risk_level'] = self._categorize_risk(risk_score)
        profile['risk_score'] = risk_score
        
        self.user_profiles[user_id] = profile
        return profile
    
    def _calculate_risk_score(self, profile, df):
        """è®¡ç®—ç”¨æˆ·é£é™©è¯„åˆ†"""
        risk_score = 0
        
        # é‡‘é¢å¼‚å¸¸æ€§
        if profile['amount_cv'] > 2:  # é‡‘é¢å˜å¼‚ç³»æ•°è¿‡å¤§
            risk_score += 20
        
        # å¤§é¢äº¤æ˜“æ¯”ä¾‹
        large_amount_ratio = (df['amount'] > df['amount'].quantile(0.9)).mean()
        risk_score += large_amount_ratio * 30
        
        # å¤œé—´äº¤æ˜“æ¯”ä¾‹
        risk_score += profile['night_ratio'] * 25
        
        # äº¤æ˜“é¢‘ç‡å¼‚å¸¸
        if 'avg_interval_hours' in profile and profile['avg_interval_hours'] < 1:
            risk_score += 15
        
        # å•†æˆ·ç±»å‹é£é™©
        high_risk_merchants = ['gambling', 'crypto', 'cash_advance']
        for merchant_type in profile['preferred_merchant_types']:
            if merchant_type in high_risk_merchants:
                risk_score += 25
                break
        
        return min(risk_score, 100)
    
    def _categorize_risk(self, risk_score):
        """é£é™©ç­‰çº§åˆ†ç±»"""
        if risk_score >= 70:
            return 'é«˜é£é™©'
        elif risk_score >= 40:
            return 'ä¸­é£é™©'
        elif risk_score >= 20:
            return 'ä½é£é™©'
        else:
            return 'æ­£å¸¸'
    
    def compare_users(self, user_ids):
        """ç”¨æˆ·å¯¹æ¯”åˆ†æ"""
        comparison = []
        for user_id in user_ids:
            if user_id in self.user_profiles:
                profile = self.user_profiles[user_id]
                comparison.append({
                    'user_id': user_id,
                    'risk_level': profile['risk_level'],
                    'risk_score': profile['risk_score'],
                    'avg_amount': profile['avg_amount'],
                    'transaction_count': profile['total_transactions'],
                    'merchant_diversity': profile['merchant_diversity'],
                    'night_ratio': profile['night_ratio']
                })
        return pd.DataFrame(comparison)

# æ¨¡æ‹Ÿç”¨æˆ·äº¤æ˜“æ•°æ®
np.random.seed(42)

# ç”Ÿæˆä¸åŒç±»å‹ç”¨æˆ·çš„äº¤æ˜“æ•°æ®
def generate_user_transactions(user_type, user_id, num_transactions=50):
    """ç”Ÿæˆä¸åŒç±»å‹ç”¨æˆ·çš„äº¤æ˜“æ•°æ®"""
    transactions = []
    base_time = datetime.now() - timedelta(days=30)
    
    for i in range(num_transactions):
        if user_type == 'normal':
            # æ­£å¸¸ç”¨æˆ·ï¼šè§„å¾‹äº¤æ˜“ï¼Œé‡‘é¢é€‚ä¸­
            amount = np.random.normal(500, 200)
            hour = np.random.choice([9, 10, 11, 12, 14, 15, 16, 17, 18, 19], p=[0.1]*10)
            merchant_type = np.random.choice(['retail', 'restaurant', 'online'], p=[0.4, 0.3, 0.3])
            payment_method = np.random.choice(['card', 'wallet'], p=[0.6, 0.4])
            
        elif user_type == 'high_risk':
            # é«˜é£é™©ç”¨æˆ·ï¼šå¤œé—´äº¤æ˜“ï¼Œå¤§é¢ï¼Œé«˜é£é™©å•†æˆ·
            amount = np.random.exponential(2000)
            hour = np.random.choice(list(range(24)), p=[0.1]*6 + [0.02]*12 + [0.1]*6)
            merchant_type = np.random.choice(['gambling', 'crypto', 'cash_advance', 'retail'], p=[0.3, 0.3, 0.2, 0.2])
            payment_method = np.random.choice(['card', 'crypto'], p=[0.5, 0.5])
            
        elif user_type == 'frequent':
            # é«˜é¢‘ç”¨æˆ·ï¼šäº¤æ˜“é¢‘ç¹ï¼Œé‡‘é¢è¾ƒå°
            amount = np.random.gamma(2, 100)
            hour = np.random.choice(list(range(8, 22)))
            merchant_type = np.random.choice(['online', 'retail', 'restaurant'], p=[0.5, 0.3, 0.2])
            payment_method = np.random.choice(['wallet', 'card'], p=[0.7, 0.3])
        
        # ç¡®ä¿é‡‘é¢ä¸ºæ­£æ•°
        amount = max(amount, 10)
        
        # ç”Ÿæˆæ—¶é—´æˆ³
        days_offset = np.random.uniform(0, 30)
        hours_offset = np.random.uniform(0, 24)
        timestamp = base_time + timedelta(days=days_offset, hours=hours_offset)
        timestamp = timestamp.replace(hour=hour, minute=np.random.randint(0, 60))
        
        transactions.append({
            'transaction_id': f'TXN_{user_id}_{i:03d}',
            'user_id': user_id,
            'amount': round(amount, 2),
            'merchant_type': merchant_type,
            'payment_method': payment_method,
            'timestamp': timestamp.isoformat()
        })
    
    return transactions

# ç”Ÿæˆæµ‹è¯•æ•°æ®
test_users = [
    ('normal', 'USER_NORMAL_001', 40),
    ('high_risk', 'USER_RISK_001', 30),
    ('frequent', 'USER_FREQ_001', 80),
    ('normal', 'USER_NORMAL_002', 35)
]

print("ğŸ‘¤ ç”¨æˆ·è¡Œä¸ºç”»åƒåˆ†æ")
print("=" * 50)

profiler = UserBehaviorProfiler()
all_profiles = []

for user_type, user_id, num_txns in test_users:
    transactions = generate_user_transactions(user_type, user_id, num_txns)
    profile = profiler.analyze_user_behavior(user_id, transactions)
    all_profiles.append(profile)
    
    print(f"\nç”¨æˆ·ID: {user_id} ({user_type})")
    print(f"é£é™©ç­‰çº§: {profile['risk_level']} (è¯„åˆ†: {profile['risk_score']:.1f})")
    print(f"äº¤æ˜“ç»Ÿè®¡: {profile['total_transactions']}ç¬”, æ€»é¢Â¥{profile['total_amount']:,.0f}")
    print(f"å¹³å‡é‡‘é¢: Â¥{profile['avg_amount']:.0f} (æ ‡å‡†å·®: Â¥{profile['std_amount']:.0f})")
    print(f"åå¥½æ—¶æ®µ: {profile['preferred_hours']}æ—¶")
    print(f"å¤œé—´äº¤æ˜“æ¯”ä¾‹: {profile['night_ratio']:.1%}")
    print(f"å‘¨æœ«äº¤æ˜“æ¯”ä¾‹: {profile['weekend_ratio']:.1%}")
    print(f"åå¥½å•†æˆ·: {', '.join(profile['preferred_merchant_types'])}")
    print(f"åå¥½æ”¯ä»˜: {', '.join(profile['preferred_payment_methods'])}")
    
    if 'avg_interval_hours' in profile:
        print(f"å¹³å‡äº¤æ˜“é—´éš”: {profile['avg_interval_hours']:.1f}å°æ—¶")

# ç”¨æˆ·å¯¹æ¯”åˆ†æ
print("\n" + "=" * 50)
print("ğŸ“Š ç”¨æˆ·é£é™©å¯¹æ¯”åˆ†æ")
user_ids = [profile['user_id'] for profile in all_profiles]
comparison_df = profiler.compare_users(user_ids)
print(comparison_df.to_string(index=False))</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šå®æ—¶ç›‘æ§ä¸é¢„è­¦ç³»ç»Ÿ</h4>
                    <div class="code-example">
<pre><code># å®æ—¶ç›‘æ§ä¸é¢„è­¦ç³»ç»Ÿ
import threading
import time
import queue
from datetime import datetime, timedelta
import json

class RealTimeMonitoringSystem:
    """å®æ—¶ç›‘æ§ä¸é¢„è­¦ç³»ç»Ÿ"""
    
    def __init__(self, risk_engine):
        self.risk_engine = risk_engine
        self.transaction_queue = queue.Queue()
        self.alert_queue = queue.Queue()
        self.monitoring_stats = {
            'start_time': datetime.now(),
            'processed_count': 0,
            'alert_count': 0,
            'avg_processing_time': 0,
            'peak_tps': 0,
            'current_tps': 0
        }
        self.is_running = False
        self.alert_rules = self._load_alert_rules()
    
    def _load_alert_rules(self):
        """åŠ è½½é¢„è­¦è§„åˆ™"""
        return {
            'high_risk_threshold': 80,      # é«˜é£é™©é˜ˆå€¼
            'rejection_rate_threshold': 0.1, # æ‹’ç»ç‡é˜ˆå€¼
            'processing_time_threshold': 100, # å¤„ç†æ—¶é—´é˜ˆå€¼(ms)
            'tps_threshold': 1000,          # TPSé˜ˆå€¼
            'consecutive_alerts': 5,        # è¿ç»­é¢„è­¦æ¬¡æ•°
            'alert_cooldown': 300          # é¢„è­¦å†·å´æ—¶é—´(ç§’)
        }
    
    def start_monitoring(self):
        """å¯åŠ¨ç›‘æ§"""
        self.is_running = True
        
        # å¯åŠ¨äº¤æ˜“å¤„ç†çº¿ç¨‹
        processing_thread = threading.Thread(target=self._process_transactions)
        processing_thread.daemon = True
        processing_thread.start()
        
        # å¯åŠ¨é¢„è­¦æ£€æŸ¥çº¿ç¨‹
        alert_thread = threading.Thread(target=self._check_alerts)
        alert_thread.daemon = True
        alert_thread.start()
        
        # å¯åŠ¨ç»Ÿè®¡æ›´æ–°çº¿ç¨‹
        stats_thread = threading.Thread(target=self._update_stats)
        stats_thread.daemon = True
        stats_thread.start()
        
        print("ğŸ” å®æ—¶ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨")
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.is_running = False
        print("â¹ï¸ å®æ—¶ç›‘æ§ç³»ç»Ÿå·²åœæ­¢")
    
    def submit_transaction(self, transaction):
        """æäº¤äº¤æ˜“è¿›è¡Œå¤„ç†"""
        self.transaction_queue.put(transaction)
    
    def _process_transactions(self):
        """å¤„ç†äº¤æ˜“é˜Ÿåˆ—"""
        processing_times = []
        
        while self.is_running:
            try:
                transaction = self.transaction_queue.get(timeout=1)
                start_time = time.time()
                
                # é£é™©è¯„ä¼°
                result = self.risk_engine.make_decision(transaction)
                
                processing_time = (time.time() - start_time) * 1000
                processing_times.append(processing_time)
                
                # æ›´æ–°ç»Ÿè®¡
                self.monitoring_stats['processed_count'] += 1
                if len(processing_times) > 0:
                    self.monitoring_stats['avg_processing_time'] = sum(processing_times) / len(processing_times)
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦é¢„è­¦
                self._check_transaction_alert(transaction, result, processing_time)
                
                # ä¿æŒæœ€è¿‘1000ä¸ªå¤„ç†æ—¶é—´è®°å½•
                if len(processing_times) > 1000:
                    processing_times = processing_times[-1000:]
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"âŒ äº¤æ˜“å¤„ç†é”™è¯¯: {e}")
    
    def _check_transaction_alert(self, transaction, result, processing_time):
        """æ£€æŸ¥å•ç¬”äº¤æ˜“é¢„è­¦"""
        alerts = []
        
        # é«˜é£é™©äº¤æ˜“é¢„è­¦
        if result['risk_score'] >= self.alert_rules['high_risk_threshold']:
            alerts.append({
                'type': 'HIGH_RISK_TRANSACTION',
                'level': 'CRITICAL',
                'message': f"æ£€æµ‹åˆ°é«˜é£é™©äº¤æ˜“: {transaction['transaction_id']}, é£é™©è¯„åˆ†: {result['risk_score']:.1f}",
                'transaction_id': transaction['transaction_id'],
                'risk_score': result['risk_score'],
                'timestamp': datetime.now().isoformat()
            })
        
        # å¤„ç†æ—¶é—´è¿‡é•¿é¢„è­¦
        if processing_time > self.alert_rules['processing_time_threshold']:
            alerts.append({
                'type': 'SLOW_PROCESSING',
                'level': 'WARNING',
                'message': f"äº¤æ˜“å¤„ç†æ—¶é—´è¿‡é•¿: {processing_time:.1f}ms",
                'transaction_id': transaction['transaction_id'],
                'processing_time': processing_time,
                'timestamp': datetime.now().isoformat()
            })
        
        # å¤§é¢äº¤æ˜“é¢„è­¦
        if transaction['amount'] > 100000:
            alerts.append({
                'type': 'LARGE_AMOUNT',
                'level': 'INFO',
                'message': f"å¤§é¢äº¤æ˜“: Â¥{transaction['amount']:,}",
                'transaction_id': transaction['transaction_id'],
                'amount': transaction['amount'],
                'timestamp': datetime.now().isoformat()
            })
        
        # å°†é¢„è­¦åŠ å…¥é˜Ÿåˆ—
        for alert in alerts:
            self.alert_queue.put(alert)
            self.monitoring_stats['alert_count'] += 1
    
    def _check_alerts(self):
        """æ£€æŸ¥ç³»ç»Ÿçº§é¢„è­¦"""
        last_check = datetime.now()
        
        while self.is_running:
            try:
                current_time = datetime.now()
                
                # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ç³»ç»ŸæŒ‡æ ‡
                if (current_time - last_check).total_seconds() >= 60:
                    self._check_system_alerts()
                    last_check = current_time
                
                # å¤„ç†é¢„è­¦é˜Ÿåˆ—
                try:
                    alert = self.alert_queue.get(timeout=1)
                    self._handle_alert(alert)
                except queue.Empty:
                    continue
                    
            except Exception as e:
                print(f"âŒ é¢„è­¦æ£€æŸ¥é”™è¯¯: {e}")
            
            time.sleep(1)
    
    def _check_system_alerts(self):
        """æ£€æŸ¥ç³»ç»Ÿçº§æŒ‡æ ‡é¢„è­¦"""
        # TPSé¢„è­¦
        if self.monitoring_stats['current_tps'] > self.alert_rules['tps_threshold']:
            alert = {
                'type': 'HIGH_TPS',
                'level': 'WARNING',
                'message': f"TPSè¿‡é«˜: {self.monitoring_stats['current_tps']}",
                'tps': self.monitoring_stats['current_tps'],
                'timestamp': datetime.now().isoformat()
            }
            self.alert_queue.put(alert)
        
        # å¹³å‡å¤„ç†æ—¶é—´é¢„è­¦
        if self.monitoring_stats['avg_processing_time'] > self.alert_rules['processing_time_threshold']:
            alert = {
                'type': 'SLOW_SYSTEM',
                'level': 'WARNING',
                'message': f"ç³»ç»Ÿå¤„ç†é€Ÿåº¦ä¸‹é™: {self.monitoring_stats['avg_processing_time']:.1f}ms",
                'avg_processing_time': self.monitoring_stats['avg_processing_time'],
                'timestamp': datetime.now().isoformat()
            }
            self.alert_queue.put(alert)
    
    def _handle_alert(self, alert):
        """å¤„ç†é¢„è­¦"""
        # æ ¹æ®é¢„è­¦çº§åˆ«é‡‡å–ä¸åŒè¡ŒåŠ¨
        if alert['level'] == 'CRITICAL':
            print(f"ğŸš¨ ä¸¥é‡é¢„è­¦: {alert['message']}")
            # å¯ä»¥å‘é€çŸ­ä¿¡ã€é‚®ä»¶ç­‰
        elif alert['level'] == 'WARNING':
            print(f"âš ï¸ è­¦å‘Š: {alert['message']}")
        else:
            print(f"â„¹ï¸ ä¿¡æ¯: {alert['message']}")
        
        # è®°å½•é¢„è­¦æ—¥å¿—
        self._log_alert(alert)
    
    def _log_alert(self, alert):
        """è®°å½•é¢„è­¦æ—¥å¿—"""
        # è¿™é‡Œå¯ä»¥å†™å…¥æ•°æ®åº“æˆ–æ—¥å¿—æ–‡ä»¶
        pass
    
    def _update_stats(self):
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        last_count = 0
        last_time = time.time()
        
        while self.is_running:
            time.sleep(10)  # æ¯10ç§’æ›´æ–°ä¸€æ¬¡
            
            current_time = time.time()
            current_count = self.monitoring_stats['processed_count']
            
            # è®¡ç®—å½“å‰TPS
            time_diff = current_time - last_time
            count_diff = current_count - last_count
            
            if time_diff > 0:
                current_tps = count_diff / time_diff
                self.monitoring_stats['current_tps'] = current_tps
                
                # æ›´æ–°å³°å€¼TPS
                if current_tps > self.monitoring_stats['peak_tps']:
                    self.monitoring_stats['peak_tps'] = current_tps
            
            last_count = current_count
            last_time = current_time
    
    def get_monitoring_report(self):
        """è·å–ç›‘æ§æŠ¥å‘Š"""
        runtime = datetime.now() - self.monitoring_stats['start_time']
        
        return {
            'è¿è¡Œæ—¶é—´': str(runtime).split('.')[0],
            'å¤„ç†äº¤æ˜“æ•°': self.monitoring_stats['processed_count'],
            'é¢„è­¦æ¬¡æ•°': self.monitoring_stats['alert_count'],
            'å¹³å‡å¤„ç†æ—¶é—´': f"{self.monitoring_stats['avg_processing_time']:.1f}ms",
            'å½“å‰TPS': f"{self.monitoring_stats['current_tps']:.1f}",
            'å³°å€¼TPS': f"{self.monitoring_stats['peak_tps']:.1f}",
            'ç³»ç»ŸçŠ¶æ€': 'æ­£å¸¸è¿è¡Œ' if self.is_running else 'å·²åœæ­¢'
        }

# å®æ—¶ç›‘æ§ç³»ç»Ÿæ¼”ç¤º
print("ğŸ” å¯åŠ¨å®æ—¶ç›‘æ§ä¸é¢„è­¦ç³»ç»Ÿ")
print("=" * 50)

# åˆå§‹åŒ–ç³»ç»Ÿ
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
risk_engine = RealTimeRiskEngine(redis_client)
monitoring_system = RealTimeMonitoringSystem(risk_engine)

# å¯åŠ¨ç›‘æ§
monitoring_system.start_monitoring()

# æ¨¡æ‹Ÿäº¤æ˜“æµ
def simulate_transaction_stream():
    """æ¨¡æ‹Ÿäº¤æ˜“æµ"""
    transaction_templates = [
        {'amount': 500, 'merchant_type': 'retail', 'payment_method': 'card'},
        {'amount': 1200, 'merchant_type': 'online', 'payment_method': 'wallet'},
        {'amount': 85000, 'merchant_type': 'crypto', 'payment_method': 'card'},  # é«˜é£é™©
        {'amount': 300, 'merchant_type': 'restaurant', 'payment_method': 'card'},
        {'amount': 150000, 'merchant_type': 'gambling', 'payment_method': 'crypto'},  # æé«˜é£é™©
    ]
    
    for i in range(20):
        template = np.random.choice(transaction_templates)
        transaction = {
            'transaction_id': f'MONITOR_TXN_{i:03d}',
            'user_id': f'USER_{np.random.randint(1000, 9999)}',
            'merchant_id': f'MERCHANT_{np.random.randint(100, 999)}',
            'timestamp': datetime.now().isoformat(),
            **template
        }
        
        monitoring_system.submit_transaction(transaction)
        time.sleep(0.1)  # æ¨¡æ‹Ÿäº¤æ˜“é—´éš”

# è¿è¡Œæ¨¡æ‹Ÿ
print("ğŸ“Š å¼€å§‹æ¨¡æ‹Ÿäº¤æ˜“æµ...")
simulate_transaction_stream()

# ç­‰å¾…å¤„ç†å®Œæˆ
time.sleep(5)

# è·å–ç›‘æ§æŠ¥å‘Š
report = monitoring_system.get_monitoring_report()
print("\nğŸ“ˆ ç›‘æ§ç³»ç»ŸæŠ¥å‘Š:")
for key, value in report.items():
    print(f"{key}: {value}")

# åœæ­¢ç›‘æ§
monitoring_system.stop_monitoring()</code></pre>
                    </div>
                    
                </div>
            </div>
        </div>
        <!-- é£é™©ç®¡ç†æ¡ˆä¾‹ -->
        <div id="risk" class="tab-content">
            <div class="case-study">
                <div class="case-header">
                    <span class="case-icon">âš ï¸</span>
                    <h2 class="case-title">é“¶è¡Œå…¨é¢é£é™©ç®¡ç†å¹³å°</h2>
                </div>
                <div class="case-meta">
                    <span class="case-tag">å·´å¡å°”åè®®</span>
                    <span class="case-tag">å‹åŠ›æµ‹è¯•</span>
                    <span class="case-tag">ç›‘ç®¡æŠ¥é€</span>
                    <span>é¡¹ç›®å‘¨æœŸï¼š18ä¸ªæœˆ</span>
                    <span>å›¢é˜Ÿè§„æ¨¡ï¼š30äºº</span>
                </div>
                <div class="case-content">
                    <h3>ç›‘ç®¡è¦æ±‚</h3>
                    <p>æŸè‚¡ä»½åˆ¶é“¶è¡Œéœ€è¦å»ºè®¾ç¬¦åˆå·´å¡å°”åè®®IIIè¦æ±‚çš„å…¨é¢é£é™©ç®¡ç†å¹³å°ï¼Œæ¶µç›–ä¿¡ç”¨é£é™©ã€å¸‚åœºé£é™©ã€æ“ä½œé£é™©ç­‰ã€‚</p>
                    <div class="case-metrics">
                        <div class="metric-card">
                            <div class="metric-value">12.8%</div>
                            <div class="metric-label">èµ„æœ¬å……è¶³ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">1.2%</div>
                            <div class="metric-label">ä¸è‰¯è´·æ¬¾ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">95%</div>
                            <div class="metric-label">ç›‘ç®¡æŠ¥è¡¨å‡†ç¡®ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">24å°æ—¶</div>
                            <div class="metric-label">å‹åŠ›æµ‹è¯•å‘¨æœŸ</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <h4>é£é™©èµ„æœ¬é…ç½®</h4>
                        <div id="risk-capital-chart"></div>
                    </div>
                    
                    <h3>æ ¸å¿ƒç®—æ³•å®ç°</h3>
                    <div class="code-example">
<pre><code>import pandas as pd
import numpy as np
from scipy import stats
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import warnings
warnings.filterwarnings('ignore')

class CreditRiskEngine:
    """ä¿¡ç”¨é£é™©è®¡ç®—å¼•æ“"""
    
    def __init__(self):
        self.pd_models = {}  # è¿çº¦æ¦‚ç‡æ¨¡å‹
        self.lgd_models = {} # è¿çº¦æŸå¤±ç‡æ¨¡å‹
        self.ead_models = {} # è¿çº¦é£é™©æ•å£æ¨¡å‹
        self.correlation_matrix = None
        
    def calculate_pd(self, borrower_data, segment='retail'):
        """è®¡ç®—è¿çº¦æ¦‚ç‡ (Probability of Default)"""
        # åŸºäºlogisticå›å½’çš„PDæ¨¡å‹
        features = self._extract_credit_features(borrower_data)
        
        # ç®€åŒ–çš„è¯„åˆ†å¡æ¨¡å‹
        base_score = 600
        
        # è´¢åŠ¡æŒ‡æ ‡æƒé‡
        weights = {
            'debt_to_income': -120,
            'credit_score': 2.5,
            'employment_years': 15,
            'loan_to_value': -80,
            'payment_history': 100
        }
        
        score = base_score
        for feature, weight in weights.items():
            if feature in features:
                score += features[feature] * weight
        
        # å°†è¯„åˆ†è½¬æ¢ä¸ºPD
        pd = 1 / (1 + np.exp((score - 500) / 50))
        return min(max(pd, 0.0001), 0.9999)  # é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
    
    def calculate_lgd(self, loan_data, collateral_data=None):
        """è®¡ç®—è¿çº¦æŸå¤±ç‡ (Loss Given Default)"""
        base_lgd = 0.45  # åŸºç¡€LGD
        
        # æŠµæŠ¼å“è°ƒæ•´
        if collateral_data:
            collateral_ratio = collateral_data.get('value', 0) / loan_data.get('amount', 1)
            if collateral_ratio > 1.2:
                base_lgd *= 0.3  # å……è¶³æŠµæŠ¼
            elif collateral_ratio > 0.8:
                base_lgd *= 0.6  # ä¸€èˆ¬æŠµæŠ¼
            else:
                base_lgd *= 1.2  # æŠµæŠ¼ä¸è¶³
        
        # è´·æ¬¾ç±»å‹è°ƒæ•´
        loan_type_adjustments = {
            'mortgage': 0.8,
            'auto': 0.9,
            'personal': 1.3,
            'credit_card': 1.5
        }
        
        loan_type = loan_data.get('type', 'personal')
        base_lgd *= loan_type_adjustments.get(loan_type, 1.0)
        
        return min(max(base_lgd, 0.05), 0.95)
    
    def calculate_ead(self, facility_data):
        """è®¡ç®—è¿çº¦é£é™©æ•å£ (Exposure at Default)"""
        current_balance = facility_data.get('current_balance', 0)
        credit_limit = facility_data.get('credit_limit', current_balance)
        
        # ä¿¡ç”¨è½¬æ¢å› å­ (Credit Conversion Factor)
        facility_type = facility_data.get('type', 'term_loan')
        ccf_rates = {
            'term_loan': 1.0,
            'revolving_credit': 0.75,
            'credit_card': 0.75,
            'letter_of_credit': 0.5,
            'guarantee': 1.0
        }
        
        ccf = ccf_rates.get(facility_type, 1.0)
        undrawn_amount = max(credit_limit - current_balance, 0)
        
        ead = current_balance + ccf * undrawn_amount
        return ead
    
    def _extract_credit_features(self, borrower_data):
        """æå–ä¿¡ç”¨ç‰¹å¾"""
        return {
            'debt_to_income': borrower_data.get('total_debt', 0) / max(borrower_data.get('annual_income', 1), 1),
            'credit_score': borrower_data.get('credit_score', 650) / 850,
            'employment_years': min(borrower_data.get('employment_years', 0), 20) / 20,
            'loan_to_value': borrower_data.get('loan_amount', 0) / max(borrower_data.get('property_value', 1), 1),
            'payment_history': borrower_data.get('payment_history_score', 0.8)
        }
    
    def calculate_expected_loss(self, borrower_data, loan_data, facility_data, collateral_data=None):
        """è®¡ç®—é¢„æœŸæŸå¤± EL = PD Ã— LGD Ã— EAD"""
        pd = self.calculate_pd(borrower_data)
        lgd = self.calculate_lgd(loan_data, collateral_data)
        ead = self.calculate_ead(facility_data)
        
        el = pd * lgd * ead
        
        return {
            'expected_loss': el,
            'probability_of_default': pd,
            'loss_given_default': lgd,
            'exposure_at_default': ead
        }

class MarketRiskEngine:
    """å¸‚åœºé£é™©è®¡ç®—å¼•æ“"""
    
    def __init__(self, confidence_level=0.99, holding_period=1):
        self.confidence_level = confidence_level
        self.holding_period = holding_period
        self.alpha = 1 - confidence_level
        
    def calculate_var_parametric(self, portfolio_value, returns, weights=None):
        """å‚æ•°æ³•è®¡ç®—VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # è®¡ç®—ç»„åˆæ”¶ç›Šç‡
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # è®¡ç®—ç»Ÿè®¡é‡
        mean_return = portfolio_returns.mean()
        std_return = portfolio_returns.std()
        
        # è®¡ç®—VaR
        z_score = stats.norm.ppf(self.alpha)
        var = portfolio_value * (mean_return + z_score * std_return) * np.sqrt(self.holding_period)
        
        return abs(var)
    
    def calculate_var_historical(self, portfolio_value, returns, weights=None):
        """å†å²æ¨¡æ‹Ÿæ³•è®¡ç®—VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # è®¡ç®—ç»„åˆæ”¶ç›Šç‡
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # è®¡ç®—å†å²VaR
        var_percentile = np.percentile(portfolio_returns, self.alpha * 100)
        var = portfolio_value * abs(var_percentile) * np.sqrt(self.holding_period)
        
        return var
    
    def calculate_var_monte_carlo(self, portfolio_value, returns, weights=None, n_simulations=10000):
        """è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ³•è®¡ç®—VaR"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # è®¡ç®—å†å²ç»Ÿè®¡é‡
        mean_returns = returns.mean()
        cov_matrix = returns.cov()
        
        # è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
        simulated_returns = np.random.multivariate_normal(
            mean_returns, cov_matrix, n_simulations
        )
        
        # è®¡ç®—ç»„åˆæ”¶ç›Šç‡
        portfolio_returns = np.dot(simulated_returns, weights)
        
        # è®¡ç®—VaR
        var_percentile = np.percentile(portfolio_returns, self.alpha * 100)
        var = portfolio_value * abs(var_percentile) * np.sqrt(self.holding_period)
        
        return var
    
    def calculate_expected_shortfall(self, portfolio_value, returns, weights=None):
        """è®¡ç®—æœŸæœ›æŸå¤± (Expected Shortfall/CVaR)"""
        if weights is None:
            weights = np.ones(len(returns.columns)) / len(returns.columns)
        
        # è®¡ç®—ç»„åˆæ”¶ç›Šç‡
        portfolio_returns = (returns * weights).sum(axis=1)
        
        # è®¡ç®—VaRé˜ˆå€¼
        var_threshold = np.percentile(portfolio_returns, self.alpha * 100)
        
        # è®¡ç®—è¶…è¿‡VaRçš„å¹³å‡æŸå¤±
        tail_losses = portfolio_returns[portfolio_returns <= var_threshold]
        expected_shortfall = portfolio_value * abs(tail_losses.mean()) * np.sqrt(self.holding_period)
        
        return expected_shortfall

class OperationalRiskEngine:
    """æ“ä½œé£é™©è®¡ç®—å¼•æ“"""
    
    def __init__(self):
        self.business_lines = {
            'corporate_finance': {'beta': 0.18, 'gross_income_weight': 1.0},
            'trading_sales': {'beta': 0.18, 'gross_income_weight': 1.0},
            'retail_banking': {'beta': 0.12, 'gross_income_weight': 1.0},
            'commercial_banking': {'beta': 0.15, 'gross_income_weight': 1.0},
            'payment_settlement': {'beta': 0.18, 'gross_income_weight': 1.0},
            'agency_services': {'beta': 0.15, 'gross_income_weight': 1.0},
            'asset_management': {'beta': 0.12, 'gross_income_weight': 1.0},
            'retail_brokerage': {'beta': 0.12, 'gross_income_weight': 1.0}
        }
    
    def calculate_operational_risk_capital(self, gross_income_data):
        """ä½¿ç”¨æ ‡å‡†æ³•è®¡ç®—æ“ä½œé£é™©èµ„æœ¬"""
        total_capital = 0
        
        for business_line, income_data in gross_income_data.items():
            if business_line in self.business_lines:
                beta = self.business_lines[business_line]['beta']
                
                # è®¡ç®—ä¸‰å¹´å¹³å‡æ€»æ”¶å…¥
                annual_incomes = income_data.get('annual_gross_income', [])
                if len(annual_incomes) >= 3:
                    avg_income = np.mean(annual_incomes[-3:])  # æœ€è¿‘ä¸‰å¹´å¹³å‡
                else:
                    avg_income = np.mean(annual_incomes) if annual_incomes else 0
                
                # åªè€ƒè™‘æ­£æ”¶å…¥
                if avg_income > 0:
                    capital_requirement = beta * avg_income
                    total_capital += capital_requirement
        
        return total_capital
    
    def calculate_loss_distribution(self, loss_events):
        """åˆ†ææ“ä½œé£é™©æŸå¤±åˆ†å¸ƒ"""
        if not loss_events:
            return {'frequency': 0, 'severity': 0, 'total_loss': 0}
        
        losses = [event['amount'] for event in loss_events]
        
        # é¢‘ç‡åˆ†æ
        frequency = len(losses)
        
        # ä¸¥é‡æ€§åˆ†æ
        severity_stats = {
            'mean': np.mean(losses),
            'median': np.median(losses),
            'std': np.std(losses),
            'max': np.max(losses),
            'percentile_95': np.percentile(losses, 95),
            'percentile_99': np.percentile(losses, 99)
        }
        
        return {
            'frequency': frequency,
            'severity': severity_stats,
            'total_loss': sum(losses)
        }

class RegulatoryCapitalCalculator:
    """ç›‘ç®¡èµ„æœ¬è®¡ç®—å™¨"""
    
    def __init__(self):
        self.credit_risk_engine = CreditRiskEngine()
        self.market_risk_engine = MarketRiskEngine()
        self.operational_risk_engine = OperationalRiskEngine()
        
        # å·´å¡å°”IIIèµ„æœ¬è¦æ±‚
        self.capital_requirements = {
            'cet1_minimum': 0.045,  # æ ¸å¿ƒä¸€çº§èµ„æœ¬æœ€ä½è¦æ±‚4.5%
            'tier1_minimum': 0.06,   # ä¸€çº§èµ„æœ¬æœ€ä½è¦æ±‚6%
            'total_minimum': 0.08,   # æ€»èµ„æœ¬æœ€ä½è¦æ±‚8%
            'capital_buffer': 0.025, # èµ„æœ¬ä¿æŠ¤ç¼“å†²2.5%
            'systemic_buffer': 0.01  # ç³»ç»Ÿé‡è¦æ€§ç¼“å†²1%
        }
    
    def calculate_credit_risk_rwa(self, loan_portfolio):
        """è®¡ç®—ä¿¡ç”¨é£é™©åŠ æƒèµ„äº§"""
        total_rwa = 0
        
        for loan in loan_portfolio:
            # è®¡ç®—é£é™©æƒé‡
            risk_weight = self._get_risk_weight(loan)
            
            # è®¡ç®—EAD
            ead = self.credit_risk_engine.calculate_ead(loan.get('facility_data', {}))
            
            # è®¡ç®—RWA
            rwa = ead * risk_weight
            total_rwa += rwa
        
        return total_rwa
    
    def _get_risk_weight(self, loan):
        """è·å–é£é™©æƒé‡"""
        # ç®€åŒ–çš„é£é™©æƒé‡è¡¨
        borrower_type = loan.get('borrower_type', 'corporate')
        rating = loan.get('rating', 'BB')
        
        risk_weights = {
            'sovereign': {'AAA': 0.0, 'AA': 0.0, 'A': 0.2, 'BBB': 0.2, 'BB': 0.5, 'B': 1.0, 'CCC': 1.5},
            'bank': {'AAA': 0.2, 'AA': 0.2, 'A': 0.5, 'BBB': 0.5, 'BB': 1.0, 'B': 1.5, 'CCC': 1.5},
            'corporate': {'AAA': 0.2, 'AA': 0.2, 'A': 0.5, 'BBB': 1.0, 'BB': 1.0, 'B': 1.5, 'CCC': 1.5},
            'retail': {'standard': 0.75, 'mortgage': 0.35, 'sme': 0.75}
        }
        
        if borrower_type == 'retail':
            loan_type = loan.get('loan_type', 'standard')
            return risk_weights['retail'].get(loan_type, 0.75)
        else:
            return risk_weights.get(borrower_type, {}).get(rating, 1.0)
    
    def calculate_market_risk_rwa(self, trading_portfolio):
        """è®¡ç®—å¸‚åœºé£é™©åŠ æƒèµ„äº§"""
        # ç®€åŒ–è®¡ç®—ï¼šVaR * 12.5 (ç›‘ç®¡ä¹˜æ•°)
        var = self.market_risk_engine.calculate_var_parametric(
            trading_portfolio['value'],
            trading_portfolio['returns']
        )
        
        market_risk_rwa = var * 12.5
        return market_risk_rwa
    
    def calculate_operational_risk_rwa(self, gross_income_data):
        """è®¡ç®—æ“ä½œé£é™©åŠ æƒèµ„äº§"""
        operational_capital = self.operational_risk_engine.calculate_operational_risk_capital(
            gross_income_data
        )
        
        # æ“ä½œé£é™©èµ„æœ¬ * 12.5
        operational_rwa = operational_capital * 12.5
        return operational_rwa
    
    def calculate_capital_ratios(self, capital_data, rwa_data):
        """è®¡ç®—èµ„æœ¬å……è¶³ç‡"""
        total_rwa = sum(rwa_data.values())
        
        ratios = {
            'cet1_ratio': capital_data['cet1_capital'] / total_rwa,
            'tier1_ratio': capital_data['tier1_capital'] / total_rwa,
            'total_ratio': capital_data['total_capital'] / total_rwa
        }
        
        # æ£€æŸ¥ç›‘ç®¡è¦æ±‚
        compliance = {
            'cet1_compliant': ratios['cet1_ratio'] >= self.capital_requirements['cet1_minimum'],
            'tier1_compliant': ratios['tier1_ratio'] >= self.capital_requirements['tier1_minimum'],
            'total_compliant': ratios['total_ratio'] >= self.capital_requirements['total_minimum']
        }
        
        return {
            'ratios': ratios,
            'compliance': compliance,
            'total_rwa': total_rwa
        }

class StressTestEngine:
    """å‹åŠ›æµ‹è¯•å¼•æ“"""
    
    def __init__(self):
        self.scenarios = {
            'baseline': {'gdp_growth': 0.02, 'unemployment': 0.05, 'interest_rate': 0.03},
            'adverse': {'gdp_growth': -0.01, 'unemployment': 0.08, 'interest_rate': 0.05},
            'severely_adverse': {'gdp_growth': -0.05, 'unemployment': 0.12, 'interest_rate': 0.02}
        }
    
    def run_stress_test(self, portfolio_data, scenario='adverse'):
        """è¿è¡Œå‹åŠ›æµ‹è¯•"""
        scenario_params = self.scenarios.get(scenario, self.scenarios['adverse'])
        
        # è®¡ç®—å‹åŠ›æƒ…æ™¯ä¸‹çš„æŸå¤±
        stressed_results = {
            'credit_losses': self._stress_credit_portfolio(portfolio_data.get('loans', []), scenario_params),
            'market_losses': self._stress_market_portfolio(portfolio_data.get('trading', {}), scenario_params),
            'operational_losses': self._stress_operational_risk(portfolio_data.get('operations', {}), scenario_params)
        }
        
        total_losses = sum(stressed_results.values())
        
        return {
            'scenario': scenario,
            'scenario_params': scenario_params,
            'stressed_losses': stressed_results,
            'total_losses': total_losses
        }
    
    def _stress_credit_portfolio(self, loan_portfolio, scenario_params):
        """ä¿¡ç”¨ç»„åˆå‹åŠ›æµ‹è¯•"""
        # ç®€åŒ–æ¨¡å‹ï¼šç»æµä¸‹è¡Œå¯¼è‡´PDä¸Šå‡
        gdp_impact = max(1 + scenario_params['gdp_growth'] * -2, 0.5)  # GDPä¸‹é™2%ï¼ŒPDä¸Šå‡4%
        unemployment_impact = 1 + scenario_params['unemployment'] * 5  # å¤±ä¸šç‡ä¸Šå‡1%ï¼ŒPDä¸Šå‡5%
        
        total_stressed_loss = 0
        credit_engine = CreditRiskEngine()
        
        for loan in loan_portfolio:
            # åŸºç¡€é¢„æœŸæŸå¤±
            base_el = credit_engine.calculate_expected_loss(
                loan.get('borrower_data', {}),
                loan.get('loan_data', {}),
                loan.get('facility_data', {}),
                loan.get('collateral_data')
            )['expected_loss']
            
            # å‹åŠ›è°ƒæ•´
            stressed_multiplier = gdp_impact * unemployment_impact
            stressed_loss = base_el * stressed_multiplier
            
            total_stressed_loss += stressed_loss
        
        return total_stressed_loss
    
    def _stress_market_portfolio(self, trading_portfolio, scenario_params):
        """å¸‚åœºç»„åˆå‹åŠ›æµ‹è¯•"""
        if not trading_portfolio:
            return 0
        
        # åˆ©ç‡å†²å‡»
        interest_rate_shock = scenario_params['interest_rate'] - 0.03  # ç›¸å¯¹åŸºå‡†åˆ©ç‡çš„å˜åŒ–
        
        # ç®€åŒ–è®¡ç®—ï¼šåˆ©ç‡ä¸Šå‡1%ï¼Œå€ºåˆ¸ç»„åˆæŸå¤±çº¦ä¸ºä¹…æœŸ*1%
        duration = trading_portfolio.get('duration', 5)
        bond_value = trading_portfolio.get('bond_value', 0)
        
        interest_rate_loss = bond_value * duration * abs(interest_rate_shock)
        
        # è‚¡ç¥¨å†²å‡»ï¼ˆåŸºäºGDPå¢é•¿ï¼‰
        equity_shock = scenario_params['gdp_growth'] * 3  # GDPä¸‹é™1%ï¼Œè‚¡ç¥¨ä¸‹è·Œ3%
        equity_value = trading_portfolio.get('equity_value', 0)
        equity_loss = equity_value * abs(equity_shock)
        
        return interest_rate_loss + equity_loss
    
    def _stress_operational_risk(self, operations_data, scenario_params):
        """æ“ä½œé£é™©å‹åŠ›æµ‹è¯•"""
        # ç»æµå‹åŠ›ä¸‹æ“ä½œé£é™©äº‹ä»¶å¢åŠ 
        base_operational_loss = operations_data.get('annual_operational_loss', 0)
        stress_multiplier = 1.5 if scenario_params['gdp_growth'] < 0 else 1.0
        
        return base_operational_loss * stress_multiplier</code></pre>
                    </div>
                    
                    <h3>å®é™…åº”ç”¨æ¡ˆä¾‹</h3>
                    <p>ä»¥ä¸‹æ˜¯é“¶è¡Œå…¨é¢é£é™©ç®¡ç†å¹³å°åœ¨å®é™…ä¸šåŠ¡ä¸­çš„å…·ä½“è¿ç”¨ç¤ºä¾‹ï¼š</p>
                    
                    <h4>æ¡ˆä¾‹ä¸€ï¼šä¿¡ç”¨é£é™©è¯„ä¼°ä¸èµ„æœ¬è®¡é‡</h4>
                    <div class="code-example">
<pre><code># ä¿¡ç”¨é£é™©è¯„ä¼°ä¸èµ„æœ¬è®¡é‡ç¤ºä¾‹
import pandas as pd
import numpy as np
from datetime import datetime

# åˆå§‹åŒ–é£é™©å¼•æ“
credit_engine = CreditRiskEngine()
regulatory_calculator = RegulatoryCapitalCalculator()

# æ¨¡æ‹Ÿè´·æ¬¾ç»„åˆæ•°æ®
loan_portfolio = [
    {
        'loan_id': 'LOAN_001',
        'borrower_data': {
            'annual_income': 120000,
            'total_debt': 45000,
            'credit_score': 720,
            'employment_years': 8,
            'payment_history_score': 0.95
        },
        'loan_data': {
            'amount': 300000,
            'type': 'mortgage',
            'term_years': 30
        },
        'facility_data': {
            'current_balance': 280000,
            'credit_limit': 300000,
            'type': 'term_loan'
        },
        'collateral_data': {
            'type': 'real_estate',
            'value': 400000
        },
        'borrower_type': 'retail',
        'loan_type': 'mortgage',
        'rating': 'A'
    },
    {
        'loan_id': 'LOAN_002',
        'borrower_data': {
            'annual_income': 80000,
            'total_debt': 35000,
            'credit_score': 650,
            'employment_years': 3,
            'payment_history_score': 0.85
        },
        'loan_data': {
            'amount': 25000,
            'type': 'personal',
            'term_years': 5
        },
        'facility_data': {
            'current_balance': 20000,
            'credit_limit': 25000,
            'type': 'term_loan'
        },
        'borrower_type': 'retail',
        'loan_type': 'standard',
        'rating': 'BBB'
    },
    {
        'loan_id': 'LOAN_003',
        'borrower_data': {
            'annual_income': 2000000,  # ä¼ä¸šå¹´æ”¶å…¥
            'total_debt': 800000,
            'credit_score': 680,
            'employment_years': 15,
            'payment_history_score': 0.90
        },
        'loan_data': {
            'amount': 1000000,
            'type': 'commercial',
            'term_years': 7
        },
        'facility_data': {
            'current_balance': 850000,
            'credit_limit': 1000000,
            'type': 'revolving_credit'
        },
        'borrower_type': 'corporate',
        'rating': 'BB'
    }
]

print("ğŸ’³ ä¿¡ç”¨é£é™©è¯„ä¼°ç»“æœ")
print("=" * 60)

total_expected_loss = 0
total_ead = 0
risk_details = []

# é€ç¬”è´·æ¬¾é£é™©è¯„ä¼°
for loan in loan_portfolio:
    risk_metrics = credit_engine.calculate_expected_loss(
        loan['borrower_data'],
        loan['loan_data'],
        loan['facility_data'],
        loan.get('collateral_data')
    )
    
    total_expected_loss += risk_metrics['expected_loss']
    total_ead += risk_metrics['exposure_at_default']
    
    risk_details.append({
        'loan_id': loan['loan_id'],
        'borrower_type': loan['borrower_type'],
        'loan_amount': loan['loan_data']['amount'],
        **risk_metrics
    })
    
    print(f"\nè´·æ¬¾ID: {loan['loan_id']}")
    print(f"å€Ÿæ¬¾äººç±»å‹: {loan['borrower_type']}")
    print(f"è´·æ¬¾é‡‘é¢: Â¥{loan['loan_data']['amount']:,}")
    print(f"è¿çº¦æ¦‚ç‡ (PD): {risk_metrics['probability_of_default']:.2%}")
    print(f"è¿çº¦æŸå¤±ç‡ (LGD): {risk_metrics['loss_given_default']:.2%}")
    print(f"è¿çº¦é£é™©æ•å£ (EAD): Â¥{risk_metrics['exposure_at_default']:,.0f}")
    print(f"é¢„æœŸæŸå¤± (EL): Â¥{risk_metrics['expected_loss']:,.0f}")

# è®¡ç®—é£é™©åŠ æƒèµ„äº§
credit_rwa = regulatory_calculator.calculate_credit_risk_rwa(loan_portfolio)

print(f"\n" + "=" * 60)
print("ğŸ“Š ç»„åˆé£é™©æ±‡æ€»")
print(f"æ€»é¢„æœŸæŸå¤±: Â¥{total_expected_loss:,.0f}")
print(f"æ€»é£é™©æ•å£: Â¥{total_ead:,.0f}")
print(f"ä¿¡ç”¨é£é™©åŠ æƒèµ„äº§: Â¥{credit_rwa:,.0f}")
print(f"å¹³å‡æŸå¤±ç‡: {total_expected_loss/total_ead:.2%}")

# é£é™©åˆ†å¸ƒåˆ†æ
print(f"\nğŸ“ˆ é£é™©åˆ†å¸ƒåˆ†æ")
risk_df = pd.DataFrame(risk_details)
print(f"é›¶å”®è´·æ¬¾é¢„æœŸæŸå¤±: Â¥{risk_df[risk_df['borrower_type']=='retail']['expected_loss'].sum():,.0f}")
print(f"ä¼ä¸šè´·æ¬¾é¢„æœŸæŸå¤±: Â¥{risk_df[risk_df['borrower_type']=='corporate']['expected_loss'].sum():,.0f}")

# é£é™©ç­‰çº§åˆ†å¸ƒ
high_risk_loans = risk_df[risk_df['probability_of_default'] > 0.05]
print(f"é«˜é£é™©è´·æ¬¾æ•°é‡: {len(high_risk_loans)}ç¬”")
print(f"é«˜é£é™©è´·æ¬¾å æ¯”: {len(high_risk_loans)/len(risk_df):.1%}")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹äºŒï¼šå¸‚åœºé£é™©VaRè®¡ç®—ä¸ç›‘æ§</h4>
                    <div class="code-example">
<pre><code># å¸‚åœºé£é™©VaRè®¡ç®—ä¸ç›‘æ§ç¤ºä¾‹
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# åˆå§‹åŒ–å¸‚åœºé£é™©å¼•æ“
market_engine = MarketRiskEngine(confidence_level=0.99, holding_period=1)

# æ¨¡æ‹Ÿäº¤æ˜“ç»„åˆæ•°æ®
np.random.seed(42)
n_days = 252  # ä¸€å¹´äº¤æ˜“æ—¥
n_assets = 5

# ç”Ÿæˆæ¨¡æ‹Ÿçš„å†å²æ”¶ç›Šç‡æ•°æ®
asset_names = ['è‚¡ç¥¨A', 'è‚¡ç¥¨B', 'å€ºåˆ¸C', 'å•†å“D', 'å¤–æ±‡E']
base_returns = np.array([0.0008, 0.0006, 0.0002, 0.0004, 0.0001])  # æ—¥å‡æ”¶ç›Šç‡
volatilities = np.array([0.02, 0.025, 0.008, 0.03, 0.012])  # æ—¥æ³¢åŠ¨ç‡

# ç”Ÿæˆç›¸å…³æ€§çŸ©é˜µ
correlation_matrix = np.array([
    [1.0, 0.6, 0.2, 0.3, 0.1],
    [0.6, 1.0, 0.1, 0.4, 0.2],
    [0.2, 0.1, 1.0, -0.1, 0.3],
    [0.3, 0.4, -0.1, 1.0, 0.0],
    [0.1, 0.2, 0.3, 0.0, 1.0]
])

# ç”Ÿæˆåæ–¹å·®çŸ©é˜µ
cov_matrix = np.outer(volatilities, volatilities) * correlation_matrix

# ç”Ÿæˆå†å²æ”¶ç›Šç‡æ•°æ®
returns_data = np.random.multivariate_normal(base_returns, cov_matrix, n_days)
returns_df = pd.DataFrame(returns_data, columns=asset_names)

# äº¤æ˜“ç»„åˆé…ç½®
portfolio_config = {
    'positions': {
        'è‚¡ç¥¨A': {'shares': 10000, 'price': 50.0},
        'è‚¡ç¥¨B': {'shares': 8000, 'price': 75.0},
        'å€ºåˆ¸C': {'shares': 20000, 'price': 100.0},
        'å•†å“D': {'shares': 5000, 'price': 120.0},
        'å¤–æ±‡E': {'shares': 100000, 'price': 6.5}
    }
}

# è®¡ç®—ç»„åˆä»·å€¼å’Œæƒé‡
total_value = 0
position_values = {}
for asset, position in portfolio_config['positions'].items():
    value = position['shares'] * position['price']
    position_values[asset] = value
    total_value += value

weights = np.array([position_values[asset] / total_value for asset in asset_names])

print("ğŸ“Š å¸‚åœºé£é™©VaRè®¡ç®—ç»“æœ")
print("=" * 60)

print(f"ç»„åˆæ€»ä»·å€¼: Â¥{total_value:,.0f}")
print(f"\næŒä»“æ˜ç»†:")
for asset, position in portfolio_config['positions'].items():
    value = position_values[asset]
    weight = value / total_value
    print(f"  {asset}: {position['shares']:,}è‚¡ Ã— Â¥{position['price']:.1f} = Â¥{value:,.0f} ({weight:.1%})")

# è®¡ç®—ä¸åŒæ–¹æ³•çš„VaR
var_parametric = market_engine.calculate_var_parametric(total_value, returns_df, weights)
var_historical = market_engine.calculate_var_historical(total_value, returns_df, weights)
var_monte_carlo = market_engine.calculate_var_monte_carlo(total_value, returns_df, weights)
expected_shortfall = market_engine.calculate_expected_shortfall(total_value, returns_df, weights)

print(f"\nğŸ¯ VaRè®¡ç®—ç»“æœ (99%ç½®ä¿¡åº¦, 1æ—¥æŒæœ‰æœŸ):")
print(f"å‚æ•°æ³•VaR: Â¥{var_parametric:,.0f} ({var_parametric/total_value:.2%})")
print(f"å†å²æ¨¡æ‹Ÿæ³•VaR: Â¥{var_historical:,.0f} ({var_historical/total_value:.2%})")
print(f"è’™ç‰¹å¡æ´›æ³•VaR: Â¥{var_monte_carlo:,.0f} ({var_monte_carlo/total_value:.2%})")
print(f"æœŸæœ›æŸå¤±(ES): Â¥{expected_shortfall:,.0f} ({expected_shortfall/total_value:.2%})")

# è®¡ç®—ä¸åŒç½®ä¿¡åº¦çš„VaR
confidence_levels = [0.95, 0.99, 0.999]
print(f"\nğŸ“ˆ ä¸åŒç½®ä¿¡åº¦VaRå¯¹æ¯”:")
for conf_level in confidence_levels:
    temp_engine = MarketRiskEngine(confidence_level=conf_level)
    var_temp = temp_engine.calculate_var_parametric(total_value, returns_df, weights)
    print(f"{conf_level:.1%}ç½®ä¿¡åº¦VaR: Â¥{var_temp:,.0f} ({var_temp/total_value:.2%})")

# åˆ†è§£VaRè´¡çŒ®åº¦
print(f"\nğŸ” VaRè´¡çŒ®åº¦åˆ†æ:")
for i, asset in enumerate(asset_names):
    # è®¡ç®—è¾¹é™…VaR (ç®€åŒ–è®¡ç®—)
    asset_weight = weights[i]
    asset_volatility = volatilities[i]
    portfolio_volatility = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
    
    # è¾¹é™…VaRè´¡çŒ®
    marginal_var = asset_weight * asset_volatility * stats.norm.ppf(0.01) * total_value
    contribution_pct = abs(marginal_var) / var_parametric * 100
    
    print(f"  {asset}: Â¥{abs(marginal_var):,.0f} ({contribution_pct:.1f}%)")

# å‹åŠ›æµ‹è¯•åœºæ™¯
print(f"\nâš¡ å‹åŠ›æµ‹è¯•åœºæ™¯:")
stress_scenarios = {
    'è‚¡å¸‚æš´è·Œ': {'è‚¡ç¥¨A': -0.20, 'è‚¡ç¥¨B': -0.25, 'å€ºåˆ¸C': 0.05, 'å•†å“D': -0.10, 'å¤–æ±‡E': 0.02},
    'åˆ©ç‡ä¸Šå‡': {'è‚¡ç¥¨A': -0.05, 'è‚¡ç¥¨B': -0.03, 'å€ºåˆ¸C': -0.15, 'å•†å“D': 0.02, 'å¤–æ±‡E': 0.08},
    'é‡‘èå±æœº': {'è‚¡ç¥¨A': -0.30, 'è‚¡ç¥¨B': -0.35, 'å€ºåˆ¸C': -0.05, 'å•†å“D': -0.20, 'å¤–æ±‡E': 0.15}
}

for scenario_name, shocks in stress_scenarios.items():
    scenario_loss = 0
    for asset, shock in shocks.items():
        asset_value = position_values[asset]
        loss = asset_value * abs(min(shock, 0))
        scenario_loss += loss
    
    print(f"  {scenario_name}: æŸå¤±Â¥{scenario_loss:,.0f} ({scenario_loss/total_value:.2%})")

# å¸‚åœºé£é™©é™é¢ç›‘æ§
var_limit = total_value * 0.02  # VaRé™é¢è®¾ä¸ºç»„åˆä»·å€¼çš„2%
print(f"\nğŸš¨ é£é™©é™é¢ç›‘æ§:")
print(f"VaRé™é¢: Â¥{var_limit:,.0f}")
print(f"å½“å‰VaR: Â¥{var_parametric:,.0f}")
print(f"é™é¢ä½¿ç”¨ç‡: {var_parametric/var_limit:.1%}")

if var_parametric > var_limit:
    print("âš ï¸ è­¦å‘Š: VaRè¶…è¿‡é™é¢!")
else:
    print("âœ… VaRåœ¨é™é¢èŒƒå›´å†…")</code></pre>
                    </div>
                    
                    <h4>æ¡ˆä¾‹ä¸‰ï¼šå‹åŠ›æµ‹è¯•ä¸èµ„æœ¬å……è¶³ç‡è¯„ä¼°</h4>
                    <div class="code-example">
<pre><code># å‹åŠ›æµ‹è¯•ä¸èµ„æœ¬å……è¶³ç‡è¯„ä¼°ç¤ºä¾‹
import pandas as pd
import numpy as np
from datetime import datetime

# åˆå§‹åŒ–å¼•æ“
stress_engine = StressTestEngine()
regulatory_calculator = RegulatoryCapitalCalculator()

# é“¶è¡Œèµ„äº§è´Ÿå€ºè¡¨æ•°æ®
bank_data = {
    'capital_data': {
        'cet1_capital': 15000000000,  # æ ¸å¿ƒä¸€çº§èµ„æœ¬150äº¿
        'tier1_capital': 18000000000,  # ä¸€çº§èµ„æœ¬180äº¿
        'total_capital': 22000000000   # æ€»èµ„æœ¬220äº¿
    },
    'portfolio_data': {
        'loans': loan_portfolio,  # ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„è´·æ¬¾ç»„åˆ
        'trading': {
            'value': 5000000000,  # äº¤æ˜“è´¦æˆ·50äº¿
            'returns': returns_df,  # ä½¿ç”¨ä¹‹å‰çš„æ”¶ç›Šç‡æ•°æ®
            'bond_value': 3000000000,
            'equity_value': 2000000000,
            'duration': 4.5
        },
        'operations': {
            'annual_operational_loss': 50000000  # å¹´åº¦æ“ä½œæŸå¤±5000ä¸‡
        }
    },
    'gross_income_data': {
        'retail_banking': {
            'annual_gross_income': [800000000, 850000000, 900000000]  # æœ€è¿‘ä¸‰å¹´æ”¶å…¥
        },
        'corporate_finance': {
            'annual_gross_income': [600000000, 650000000, 700000000]
        },
        'trading_sales': {
            'annual_gross_income': [400000000, 420000000, 450000000]
        },
        'commercial_banking': {
            'annual_gross_income': [500000000, 520000000, 550000000]
        }
    }
}

print("ğŸ¦ é“¶è¡Œå…¨é¢é£é™©ç®¡ç†è¯„ä¼°")
print("=" * 60)

# 1. è®¡ç®—å„ç±»é£é™©åŠ æƒèµ„äº§
print("\nğŸ“Š é£é™©åŠ æƒèµ„äº§è®¡ç®—:")

# ä¿¡ç”¨é£é™©RWA
credit_rwa = regulatory_calculator.calculate_credit_risk_rwa(bank_data['portfolio_data']['loans'])
print(f"ä¿¡ç”¨é£é™©RWA: Â¥{credit_rwa:,.0f}")

# å¸‚åœºé£é™©RWA
market_rwa = regulatory_calculator.calculate_market_risk_rwa(bank_data['portfolio_data']['trading'])
print(f"å¸‚åœºé£é™©RWA: Â¥{market_rwa:,.0f}")

# æ“ä½œé£é™©RWA
operational_rwa = regulatory_calculator.calculate_operational_risk_rwa(bank_data['gross_income_data'])
print(f"æ“ä½œé£é™©RWA: Â¥{operational_rwa:,.0f}")

rwa_data = {
    'credit_risk': credit_rwa,
    'market_risk': market_rwa,
    'operational_risk': operational_rwa
}

total_rwa = sum(rwa_data.values())
print(f"\næ€»é£é™©åŠ æƒèµ„äº§: Â¥{total_rwa:,.0f}")

# 2. è®¡ç®—èµ„æœ¬å……è¶³ç‡
print("\nğŸ’° èµ„æœ¬å……è¶³ç‡è®¡ç®—:")
capital_ratios = regulatory_calculator.calculate_capital_ratios(
    bank_data['capital_data'], 
    rwa_data
)

print(f"æ ¸å¿ƒä¸€çº§èµ„æœ¬å……è¶³ç‡: {capital_ratios['ratios']['cet1_ratio']:.2%}")
print(f"ä¸€çº§èµ„æœ¬å……è¶³ç‡: {capital_ratios['ratios']['tier1_ratio']:.2%}")
print(f"æ€»èµ„æœ¬å……è¶³ç‡: {capital_ratios['ratios']['total_ratio']:.2%}")

# ç›‘ç®¡è¦æ±‚æ£€æŸ¥
print(f"\nâœ… ç›‘ç®¡åˆè§„æ£€æŸ¥:")
print(f"æ ¸å¿ƒä¸€çº§èµ„æœ¬åˆè§„: {'âœ… è¾¾æ ‡' if capital_ratios['compliance']['cet1_compliant'] else 'âŒ ä¸è¾¾æ ‡'}")
print(f"ä¸€çº§èµ„æœ¬åˆè§„: {'âœ… è¾¾æ ‡' if capital_ratios['compliance']['tier1_compliant'] else 'âŒ ä¸è¾¾æ ‡'}")
print(f"æ€»èµ„æœ¬åˆè§„: {'âœ… è¾¾æ ‡' if capital_ratios['compliance']['total_compliant'] else 'âŒ ä¸è¾¾æ ‡'}")

# 3. å‹åŠ›æµ‹è¯•
print(f"\nâš¡ å‹åŠ›æµ‹è¯•ç»“æœ:")

for scenario in ['baseline', 'adverse', 'severely_adverse']:
    stress_result = stress_engine.run_stress_test(bank_data['portfolio_data'], scenario)
    
    print(f"\n{scenario.upper()}æƒ…æ™¯:")
    print(f"  GDPå¢é•¿ç‡: {stress_result['scenario_params']['gdp_growth']:.1%}")
    print(f"  å¤±ä¸šç‡: {stress_result['scenario_params']['unemployment']:.1%}")
    print(f"  åˆ©ç‡æ°´å¹³: {stress_result['scenario_params']['interest_rate']:.1%}")
    
    print(f"  å‹åŠ›æŸå¤±:")
    print(f"    ä¿¡ç”¨æŸå¤±: Â¥{stress_result['stressed_losses']['credit_losses']:,.0f}")
    print(f"    å¸‚åœºæŸå¤±: Â¥{stress_result['stressed_losses']['market_losses']:,.0f}")
    print(f"    æ“ä½œæŸå¤±: Â¥{stress_result['stressed_losses']['operational_losses']:,.0f}")
    print(f"    æ€»æŸå¤±: Â¥{stress_result['total_losses']:,.0f}")
    
    # å‹åŠ›åèµ„æœ¬å……è¶³ç‡
    stressed_capital = bank_data['capital_data']['cet1_capital'] - stress_result['total_losses']
    stressed_cet1_ratio = stressed_capital / total_rwa
    
    print(f"  å‹åŠ›åæ ¸å¿ƒä¸€çº§èµ„æœ¬å……è¶³ç‡: {stressed_cet1_ratio:.2%}")
    
    if stressed_cet1_ratio < 0.045:  # ä½äº4.5%æœ€ä½è¦æ±‚
        capital_shortfall = (0.045 * total_rwa) - stressed_capital
        print(f"  âš ï¸ èµ„æœ¬ç¼ºå£: Â¥{capital_shortfall:,.0f}")
    else:
        print(f"  âœ… é€šè¿‡å‹åŠ›æµ‹è¯•")

# 4. é£é™©ç›‘æ§æŒ‡æ ‡
print(f"\nğŸ“ˆ å…³é”®é£é™©æŒ‡æ ‡ç›‘æ§:")

# é›†ä¸­åº¦é£é™©
largest_exposure = max([loan['loan_data']['amount'] for loan in bank_data['portfolio_data']['loans']])
concentration_ratio = largest_exposure / bank_data['capital_data']['tier1_capital']
print(f"æœ€å¤§å•ä¸€å®¢æˆ·æ•å£å ä¸€çº§èµ„æœ¬æ¯”ä¾‹: {concentration_ratio:.2%}")

# æµåŠ¨æ€§è¦†ç›–ç‡ (ç®€åŒ–è®¡ç®—)
high_quality_assets = bank_data['capital_data']['cet1_capital'] * 0.8  # å‡è®¾80%ä¸ºé«˜è´¨é‡æµåŠ¨æ€§èµ„äº§
net_cash_outflows = total_rwa * 0.03  # å‡è®¾å‡€ç°é‡‘æµå‡ºä¸ºRWAçš„3%
lcr = high_quality_assets / net_cash_outflows
print(f"æµåŠ¨æ€§è¦†ç›–ç‡ (LCR): {lcr:.1%}")

# æ æ†ç‡
total_assets = total_rwa * 1.2  # å‡è®¾æ€»èµ„äº§ä¸ºRWAçš„1.2å€
leverage_ratio = bank_data['capital_data']['tier1_capital'] / total_assets
print(f"æ æ†ç‡: {leverage_ratio:.2%}")

# 5. é£é™©é¢„è­¦
print(f"\nğŸš¨ é£é™©é¢„è­¦è¯„ä¼°:")

warnings = []
if capital_ratios['ratios']['cet1_ratio'] < 0.07:  # ä½äº7%é¢„è­¦çº¿
    warnings.append("æ ¸å¿ƒä¸€çº§èµ„æœ¬å……è¶³ç‡æ¥è¿‘ç›‘ç®¡è¦æ±‚")

if concentration_ratio > 0.25:  # å•ä¸€å®¢æˆ·æ•å£è¶…è¿‡25%
    warnings.append("å­˜åœ¨å®¢æˆ·é›†ä¸­åº¦é£é™©")

if lcr < 1.0:  # LCRä½äº100%
    warnings.append("æµåŠ¨æ€§è¦†ç›–ç‡ä¸è¶³")

if leverage_ratio < 0.03:  # æ æ†ç‡ä½äº3%
    warnings.append("æ æ†ç‡åä½")

if warnings:
    for warning in warnings:
        print(f"  âš ï¸ {warning}")
else:
    print(f"  âœ… æ‰€æœ‰æŒ‡æ ‡æ­£å¸¸")

# 6. ç›‘ç®¡æŠ¥å‘Šæ‘˜è¦
print(f"\nğŸ“‹ ç›‘ç®¡æŠ¥å‘Šæ‘˜è¦:")
print(f"æŠ¥å‘Šæ—¥æœŸ: {datetime.now().strftime('%Y-%m-%d')}")
print(f"é£é™©åŠ æƒèµ„äº§æ€»é¢: Â¥{total_rwa:,.0f}")
print(f"æ ¸å¿ƒä¸€çº§èµ„æœ¬: Â¥{bank_data['capital_data']['cet1_capital']:,.0f}")
print(f"æ ¸å¿ƒä¸€çº§èµ„æœ¬å……è¶³ç‡: {capital_ratios['ratios']['cet1_ratio']:.2%}")
print(f"å‹åŠ›æµ‹è¯•ç»“æœ: {'é€šè¿‡' if stressed_cet1_ratio >= 0.045 else 'éœ€è¦å…³æ³¨'}")
print(f"æ•´ä½“é£é™©è¯„çº§: {'ä½é£é™©' if len(warnings) == 0 else 'ä¸­ç­‰é£é™©' if len(warnings) <= 2 else 'é«˜é£é™©'}")</code></pre>
                    </div>
                    
                </div>
            </div>
        </div>
    </main>

    <script>
        function showTab(tabName) {
            // éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // ç§»é™¤æ‰€æœ‰å¯¼èˆªæ ‡ç­¾çš„activeç±»
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾å†…å®¹
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // æ¿€æ´»å¯¹åº”çš„å¯¼èˆªæ ‡ç­¾
            const activeNavTab = document.querySelector(`[onclick="showTab('${tabName}')"]`);
            if (activeNavTab) {
                activeNavTab.classList.add('active');
            }
        }
    </script>
</body>
</html>